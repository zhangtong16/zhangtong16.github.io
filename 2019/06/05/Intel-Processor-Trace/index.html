<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="OverviewIntel PT 是一个处理器架构扩展, 它利用硬件来记录程序执行的 trace, 并且产生很小的开销. 控制流的信息通过数据包收集, 然后使用软件解码器解码. 这些数据包内容包括: 时间, 程序流信息 (e.g., 分支目标, 分支是否执行), program-induced mode related information (e.g., Intel TSX 状态转换, CR3">
<meta property="og:type" content="article">
<meta property="og:title" content="Intel Processor Trace">
<meta property="og:url" content="http://yoursite.com/2019/06/05/Intel-Processor-Trace/index.html">
<meta property="og:site_name" content="Zhangtong&#39;s Notebook">
<meta property="og:description" content="OverviewIntel PT 是一个处理器架构扩展, 它利用硬件来记录程序执行的 trace, 并且产生很小的开销. 控制流的信息通过数据包收集, 然后使用软件解码器解码. 这些数据包内容包括: 时间, 程序流信息 (e.g., 分支目标, 分支是否执行), program-induced mode related information (e.g., Intel TSX 状态转换, CR3">
<meta property="og:locale">
<meta property="article:published_time" content="2019-06-05T06:34:00.000Z">
<meta property="article:modified_time" content="2021-05-22T09:03:11.290Z">
<meta property="article:author" content="Zhangtong">
<meta property="article:tag" content="processer trace">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/2019/06/05/Intel-Processor-Trace/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;06&#x2F;05&#x2F;Intel-Processor-Trace&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;06&#x2F;05&#x2F;Intel-Processor-Trace&#x2F;&quot;,&quot;title&quot;:&quot;Intel Processor Trace&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Intel Processor Trace | Zhangtong's Notebook</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhangtong's Notebook</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Features-and-Capabilities"><span class="nav-number">1.1.</span> <span class="nav-text">Features and Capabilities</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Summary"><span class="nav-number">1.2.</span> <span class="nav-text">Packet Summary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intel-Processor-Trace-Operational-Model"><span class="nav-number">2.</span> <span class="nav-text">Intel Processor Trace Operational Model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Change-of-Flow-Instruction-COFI-Tracing"><span class="nav-number">2.1.</span> <span class="nav-text">Change of Flow Instruction (COFI) Tracing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Direct-Transfer-COFI"><span class="nav-number">2.1.1.</span> <span class="nav-text">Direct Transfer COFI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Indirect-Transfer-COFI"><span class="nav-number">2.1.2.</span> <span class="nav-text">Indirect Transfer COFI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Far-Transfer-COFI"><span class="nav-number">2.1.3.</span> <span class="nav-text">Far Transfer COFI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Software-Trace-Instrumentation-with-PTWRITE"><span class="nav-number">2.2.</span> <span class="nav-text">Software Trace Instrumentation with PTWRITE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Power-Event-Tracing"><span class="nav-number">2.3.</span> <span class="nav-text">Power Event Tracing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trace-Filtering"><span class="nav-number">2.4.</span> <span class="nav-text">Trace Filtering</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Filtering-by-Current-Privilege-Level-CPL"><span class="nav-number">2.4.1.</span> <span class="nav-text">Filtering by Current Privilege Level (CPL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filtering-by-CR3"><span class="nav-number">2.4.2.</span> <span class="nav-text">Filtering by CR3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filtering-by-IP"><span class="nav-number">2.4.3.</span> <span class="nav-text">Filtering by IP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Generation-Enable-Controls"><span class="nav-number">2.5.</span> <span class="nav-text">Packet Generation Enable Controls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Packet-Enable-PacketEn"><span class="nav-number">2.5.1.</span> <span class="nav-text">Packet Enable (PacketEn)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trigger-Enable-TriggerEn"><span class="nav-number">2.5.2.</span> <span class="nav-text">Trigger Enable (TriggerEn)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Context-Enable-ContextEn"><span class="nav-number">2.5.3.</span> <span class="nav-text">Context Enable (ContextEn)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Branch-Enable-BranchEn"><span class="nav-number">2.5.4.</span> <span class="nav-text">Branch Enable (BranchEn)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter-Enable-FilterEn"><span class="nav-number">2.5.5.</span> <span class="nav-text">Filter Enable (FilterEn)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trace-Output"><span class="nav-number">2.6.</span> <span class="nav-text">Trace Output</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Single-Range-Out"><span class="nav-number">2.6.1.</span> <span class="nav-text">Single Range Out</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Table-of-Physical-Addresses"><span class="nav-number">2.6.2.</span> <span class="nav-text">Table of Physical Addresses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trace-Transport-Subsystem"><span class="nav-number">2.6.3.</span> <span class="nav-text">Trace Transport Subsystem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Restricted-Memory-Access"><span class="nav-number">2.6.4.</span> <span class="nav-text">Restricted Memory Access</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enabling-and-Configuration-MSRs"><span class="nav-number">2.7.</span> <span class="nav-text">Enabling and Configuration MSRs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#General-Consideration"><span class="nav-number">2.7.1.</span> <span class="nav-text">General Consideration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32-RTIT-CTL-MSR"><span class="nav-number">2.7.2.</span> <span class="nav-text">IA32_RTIT_CTL MSR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enabling-and-Disabling-Packet-Generation-wth-TraceEn"><span class="nav-number">2.7.3.</span> <span class="nav-text">Enabling and Disabling Packet Generation wth TraceEn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32-RTIT-STATUS-MSR"><span class="nav-number">2.7.4.</span> <span class="nav-text">IA32_RTIT_STATUS MSR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32-RTIT-ADDRn-A-and-IA32-RTIT-ADDRn-B-MSRs"><span class="nav-number">2.7.5.</span> <span class="nav-text">IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32-RTIT-CR3-MATCH-MSR"><span class="nav-number">2.7.6.</span> <span class="nav-text">IA32_RTIT_CR3_MATCH MSR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32-RTIT-OUTPUT-BASE-MSR"><span class="nav-number">2.7.7.</span> <span class="nav-text">IA32_RTIT_OUTPUT_BASE MSR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IA32-RTIT-OUTPUT-MASK-PTRS-MSR"><span class="nav-number">2.7.8.</span> <span class="nav-text">IA32_RTIT_OUTPUT_MASK_PTRS MSR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interaction-of-Intel-Processor-Trace-and-Other-Processor-Features"><span class="nav-number">2.8.</span> <span class="nav-text">Interaction of Intel Processor Trace and Other Processor Features</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CONFIGURATION-AND-PROGRAMMING-GUIDELINE"><span class="nav-number">3.</span> <span class="nav-text">CONFIGURATION AND PROGRAMMING GUIDELINE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Detection-of-Intel-Processor-Trace-and-Capability-Enumeration"><span class="nav-number">3.1.</span> <span class="nav-text">Detection of Intel Processor Trace and Capability Enumeration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Packet-Decoding-of-RIP-versus-LIP"><span class="nav-number">3.1.1.</span> <span class="nav-text">Packet Decoding of RIP versus LIP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model-Specific-Capability-Restrictions"><span class="nav-number">3.1.2.</span> <span class="nav-text">Model Specific Capability Restrictions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enabling-and-Configuration-of-Trace-Packet-Generation"><span class="nav-number">3.2.</span> <span class="nav-text">Enabling and Configuration of Trace Packet Generation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Enabling-Packet-Generation"><span class="nav-number">3.2.1.</span> <span class="nav-text">Enabling Packet Generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Disabling-Packet-Generation"><span class="nav-number">3.2.2.</span> <span class="nav-text">Disabling Packet Generation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flushing-Trace-Output"><span class="nav-number">3.3.</span> <span class="nav-text">Flushing Trace Output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Warm-reset"><span class="nav-number">3.4.</span> <span class="nav-text">Warm reset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Manual-Trace-Configuration-Context-Switch"><span class="nav-number">3.4.1.</span> <span class="nav-text">Manual Trace Configuration Context Switch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trace-Configuration-Context-Switch-Using-XSAVES-XRSTORS"><span class="nav-number">3.4.2.</span> <span class="nav-text">Trace Configuration Context Switch Using XSAVES&#x2F;XRSTORS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cycle-Accurate-Mode"><span class="nav-number">3.5.</span> <span class="nav-text">Cycle-Accurate Mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decoder-Synchronization-PSB"><span class="nav-number">3.6.</span> <span class="nav-text">Decoder Synchronization (PSB+)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Internal-Buffer-Overflow"><span class="nav-number">3.7.</span> <span class="nav-text">Internal Buffer Overflow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trace-Packets-and-Data-Types"><span class="nav-number">4.</span> <span class="nav-text">Trace Packets and Data Types</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Relationships-and-Ordering"><span class="nav-number">4.1.</span> <span class="nav-text">Packet Relationships and Ordering</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Packet-Blocks"><span class="nav-number">4.1.1.</span> <span class="nav-text">Packet Blocks</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhangtong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhangtong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/05/Intel-Processor-Trace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Intel Processor Trace
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-06-05 14:34:00" itemprop="dateCreated datePublished" datetime="2019-06-05T14:34:00+08:00">2019-06-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Intel PT 是一个处理器架构扩展, 它利用硬件来记录程序执行的 trace, 并且产生很小的开销. 控制流的信息通过数据包收集, 然后使用软件解码器解码. 这些数据包内容包括: 时间, 程序流信息 (e.g., 分支目标, 分支是否执行), program-induced mode related information (e.g., Intel TSX 状态转换, CR3 改变). Intel PT 后期的版本增加了 trace sources, 包括使用 <code>PTWRITE</code> 的 software trace instrumentation, 和 Power Event tracing.</p>
<h3 id="Features-and-Capabilities"><a href="#Features-and-Capabilities" class="headerlink" title="Features and Capabilities"></a>Features and Capabilities</h3><p>使用 PT 生成的数据包和程序的二进制文件, 可以重构出程序的执行 trace. 这些数据包记录的信息有: instruction pointers (IP), indirect branch targets, directions of conditional branches within contiguous code regions (basic blocks).</p>
<p>PT 可以使用 <code>PTWRITE</code> 来记录软件生成的数据包, 和一些处理器功耗的事件. 并且, Precise Event-based Sampling (PEBS) 也能通过配置, 在 PT 中记录.</p>
<p>PT 有几种控制和筛选机制, 完成自定义的 trace 信息收集. 比如可以通过 current privilege level 和 CR3 值进行筛选. 这些筛选可以通过设置 MSR 来进行.</p>
<h3 id="Packet-Summary"><a href="#Packet-Summary" class="headerlink" title="Packet Summary"></a>Packet Summary</h3><p>程序执行基本信息的数据包如下:</p>
<ul>
<li><p>Packet Stream Boundary (PSB) packets: 心跳包, 每隔一定周期 (e.g., every 4K trace packet bytes) 自动生成. 可以作为数据包的边界来供 decoder 识别, decoder 解析的第一个包一定要是这个包.</p>
</li>
<li><p>Paging Information Packet (PIP): 记录 CR3 寄存器的修改情况. 通过结合操作系统中每个进程 CR3 的值, debugger 能够将线性地址和对应的进程 (源代码) 结合起来.</p>
</li>
<li><p>Time-Stamp Counter (TSC) packets: 记录时间.</p>
</li>
<li><p>Core Bus Ratio (CBR) packets: 包含 core:bus 的时钟频率比</p>
</li>
<li><p>Overflow (OVF) packets: 当处理器内部缓冲区溢出时设置, 可能其它的包被丢弃了, 解码器利用这个信息来同步正确的解码.</p>
</li>
</ul>
<p>关于控制流信息的数据包如下:</p>
<ul>
<li><p>Taken Not-Taken (TNT) packets: 记录直接条件分支的方向.</p>
</li>
<li><p>Target IP (TIP) packets: 记录间接分支, 异常, 中断和其他分支或事件的目的 IP. 里面存储的 IP 都是被压缩的, 并且存在不同类型的 TIP 包.</p>
</li>
<li><p>Flow Update Packets (FUP): 异步事件 (中断或者异常) 的源 IP. 还有其它不能从二进制文件中获取的源 IP 也通过这个包得到.</p>
</li>
<li><p>MODE packets: 提供解码器重要的处理器执行信息, 使得解码器能够解释反汇编的二进制程序和 trace log.</p>
</li>
</ul>
<p>软件生成的数据包:</p>
<ul>
<li><code>PTWRITE</code> (PTW) packets: 包括传给 <code>PTWRITE</code> 指令的操作数的值.</li>
</ul>
<h2 id="Intel-Processor-Trace-Operational-Model"><a href="#Intel-Processor-Trace-Operational-Model" class="headerlink" title="Intel Processor Trace Operational Model"></a>Intel Processor Trace Operational Model</h2><h3 id="Change-of-Flow-Instruction-COFI-Tracing"><a href="#Change-of-Flow-Instruction-COFI-Tracing" class="headerlink" title="Change of Flow Instruction (COFI) Tracing"></a>Change of Flow Instruction (COFI) Tracing</h3><p>Basic block 之间的控制流转移指令叫做 COFI, 分为三种: 1. Direct transfer COFI, 2. Indirect transfer COFI, 3. Far transfer COFI.</p>
<p>同时, 按照不同的类型:</p>
<table>
<thead>
<tr>
<th>COFI Type</th>
<th>Instructions</th>
</tr>
</thead>
<tbody><tr>
<td>Conditional Branch</td>
<td>Jcc  , J*CXZ, LOOP</td>
</tr>
<tr>
<td>Unconditional Direct Branch</td>
<td>JMP (E9 xx, EB xx), CALL (E8 xx)</td>
</tr>
<tr>
<td>Indirect Branch</td>
<td>JMP (FF /4)， CALL (FF /2)</td>
</tr>
<tr>
<td>Near Ret</td>
<td>RET (C3, C2 xx)</td>
</tr>
<tr>
<td>Far Transfers</td>
<td>INT1, INT3, INT n, INTO, IRE(T/TD/Q), JMP (EA xx, FF/5), CALL (9A xx, FF/3), RET (CB, CA xx), SYSCALL, SYSRET, SYSENTER, SYSEXIT, VMLANUCH, VMRESUME</td>
</tr>
</tbody></table>
<h4 id="Direct-Transfer-COFI"><a href="#Direct-Transfer-COFI" class="headerlink" title="Direct Transfer COFI"></a>Direct Transfer COFI</h4><p>Direct Transfer COFI 是相对分支. 意味着他们的目标地址是当前的 IP 加上一个 offset. 因为二进制反汇编就可以得到直接跳转的 IP, 所以没有必要在 trace 中记录 IP. 对于条件分支, 只需要标记该分支是 taken or not 就行. 无条件分支都不需要任何记录.</p>
<ul>
<li><p>Conditional Branch (Jcc, J*CXZ) and Loop: 编码一个 bit 的 TNT 就可以指示程序的控制流. 同时, 处理器会将多个 TNT bit 压缩成一个数据包.</p>
</li>
<li><p>Unconditional Direct Jumps: 不会生成 trace.</p>
</li>
</ul>
<h4 id="Indirect-Transfer-COFI"><a href="#Indirect-Transfer-COFI" class="headerlink" title="Indirect Transfer COFI"></a>Indirect Transfer COFI</h4><p>Indirect Transfer 指令会从寄存器或者内存地址中更新 IP, 所以 PT 就必须记录目的 IP， 使得 debugger 能够确定 COFI 的目的地址. 这个 IP 可能为 linear addres, 或 effective address.</p>
<p>Indirect Transfer 指令会生成一个包含目的地址的 Target IP Packet(TIP).</p>
<ul>
<li><p>Near JMP Indirect and Near Call Indirect: 生成 TIP.</p>
</li>
<li><p>Near RET: 当 <code>CALL</code> 指令执行时, 它会将 <code>CALL</code> 后面那条指令的地址压栈. 在调用返回后, <code>RET</code> 指令会出栈这个返回i地址, 并 <code>JMP</code> 过去. 因为这个调用本身可能修改这个返回地址, 所以实际的返回地址在反汇编中仍不确定, 所以对于 <code>RET</code> 还是会生成一个 TIP 包.</p>
<ul>
<li>RET Compression: 如果能保证 RET 的返回地址和压栈的返回地址完全一致, 可以仅生成一个 TNT 包表示走了这个分支. 不过这个得需要 decoder 作额外的处理.</li>
</ul>
</li>
</ul>
<h4 id="Far-Transfer-COFI"><a href="#Far-Transfer-COFI" class="headerlink" title="Far Transfer COFI"></a>Far Transfer COFI</h4><p>所有改变 instruction pointer 的非 near jumps 指令都是 “far transfer”. 包括: 异常, 中断, trap, TSX abort, 和进行 far transfer 的指令.</p>
<p>所有的这些指令都会产生一个 TIP 数据包. 有一些 far transfer 在二进制代码中无法推断, 比如异步事件异常和中断, 这种会先产生 FUP 数据包提供事件源 IP, 再产生一个 TIP.</p>
<h3 id="Software-Trace-Instrumentation-with-PTWRITE"><a href="#Software-Trace-Instrumentation-with-PTWRITE" class="headerlink" title="Software Trace Instrumentation with PTWRITE"></a>Software Trace Instrumentation with <code>PTWRITE</code></h3><p><code>PTWRITE</code> 使得软件可以直接利用 PT trace. 每次将 64 bit 数据写入到 PT 产生的 PTW 数据包中. 解码器和分析软件能根据 <code>PTWRITE</code> 指令的 IP, 和数据内容确定这个数据的意义. <code>PTWRITE</code> 通过 IA32_RTIT_CTL.PTWEn[12]开启, 并且用户可以使用 IA32_RTIT_CTL.FUPonPTW[5] 在 PTW 包后面添加 FPU 包, 获取 <code>PTWRITE</code> 指令的 IP.</p>
<h3 id="Power-Event-Tracing"><a href="#Power-Event-Tracing" class="headerlink" title="Power Event Tracing"></a><del>Power Event Tracing</del></h3><h3 id="Trace-Filtering"><a href="#Trace-Filtering" class="headerlink" title="Trace Filtering"></a>Trace Filtering</h3><h4 id="Filtering-by-Current-Privilege-Level-CPL"><a href="#Filtering-by-Current-Privilege-Level-CPL" class="headerlink" title="Filtering by Current Privilege Level (CPL)"></a>Filtering by Current Privilege Level (CPL)</h4><p>Intel PT 设置 trace 条件为 CPL = 0, 或者 CPL &gt; 0, 使得 logical processor 生成对应 CPL 的数据包. CPL 筛选保证了只有满足条件的 IP 或者其它的架构信息能够被 trace, 比如说 trace 条件是 CPL &gt; 0, 当软件执行 SYSCALL (CPL = 0)时, SYSCALL 的目的 IP 就不会出现在生成的数据包中.</p>
<p>在 real-address mode 和 virtual-8086 mode 时, CPL 分别为 0, 3.</p>
<h4 id="Filtering-by-CR3"><a href="#Filtering-by-CR3" class="headerlink" title="Filtering by CR3"></a>Filtering by CR3</h4><p>Intel PT 支持配置 CR3 筛选器, 能根据当前 CR3 的值生成 trace. 如果是多线程的程序, 可以通过切换 RTIT MSRs 的状态来分隔不同线程的输出.</p>
<p>设置 IA32_RTIT_CR3_MATCH MSR寄存器的值为目标 CR3 值, 然后设置 IA32_RTIT_CTL.CR3Filter, 就可以 trace 某个 CR3. 如果处理器被设置为 CPL = 0 时也能记录, 那么生成的 trace 中含有 PIP 数据包.</p>
<h4 id="Filtering-by-IP"><a href="#Filtering-by-IP" class="headerlink" title="Filtering by IP"></a>Filtering by IP</h4><p>如果 CPUID.(EAX=14H, ECX=0):EBX[bit 2] = 1 时, Intel PT 能够仅在程序执行的 IP 在某个确定的范围内时, 生成 trace 数据包. 对 IA32_RTIT_CTL MSR 寄存器中的 ADDR<code>n</code>_CFG 域进行设置, 可以启用 IP filtering. 这个 <code>n</code> 是从零开始的数字, 用来选择配置的是哪个地址范围. 每个 ADDR<code>n</code>_CFG 都确定一组寄存器对的值 [base, limit], [IA32_RTIT_ADDR<code>n</code>_A, IA32_RTIT_ADDR<code>n</code>_B]. 选定的地址范围个数可以通过 CPUID 查看.</p>
<p>这个 base 和 limit 是 inclusive 的, 所以他包含边界.</p>
<p><strong>TraceStop:</strong> 可以通过配置 IP 范围, 不对某些地址进行 trace, 若上述范围重叠, 重叠部分不 trace.</p>
<h3 id="Packet-Generation-Enable-Controls"><a href="#Packet-Generation-Enable-Controls" class="headerlink" title="Packet Generation Enable Controls"></a>Packet Generation Enable Controls</h3><p>Intel PT 包含多种控制机制来确定是否生成数据包. 一般来讲, 只要 Packet Enable (PacketEn) 被设置, 大多数数据包都会生成. PacketEn 是硬件的内部状态, 软件只能通过对 MSR 寄存器进行修改来对他进行配置.</p>
<h4 id="Packet-Enable-PacketEn"><a href="#Packet-Enable-PacketEn" class="headerlink" title="Packet Enable (PacketEn)"></a>Packet Enable (PacketEn)</h4><p>当 PacketEn 被设置时, 处理器就能使用 PT 生成 trace. PacketEn 是几种状态的组合: <code>PacketEn &lt;- TriggerEn AND ContextEn AND FilterEn AND BranchEn</code>. PacketEn 是处理器是否生成 trace 数据包的最根本的因素. 当它 enable 时, 所有的控制流数据包都会被 enable, 当它被 clear 时, 只有一些其它的数据包 (timing and bookkeeping packets) 生成. 不支持 IP Filtering 的处理器中 (i.e., CPUID.(EAX=14H, ECX=0):EBX.IPFILT_WRSTPRSV[bit 2] = 0), FilterEn 总是被 set.</p>
<h4 id="Trigger-Enable-TriggerEn"><a href="#Trigger-Enable-TriggerEn" class="headerlink" title="Trigger Enable (TriggerEn)"></a>Trigger Enable (TriggerEn)</h4><p>Trigger Enable (TriggerEn) 是最主要的生成数据包的指示器. 使用 IA32_RTIT_CTL.TraceEn 来对它 set. 通过以下任意一个条件来 clear 它: (i) 使用软件 clear IA32_RTIT_CTL.TraceEn, (ii) 满足 TraceStop 条件, 并且 IA32_RTIT_STATUES.Stopped 被 set, (iii) IA32_RTIT_STATUS.ERROR 被 set. 软件可以通过查询 IA32_RTIT_STATUS.TriggerEn 来获取当前 TriggerEn 的值.</p>
<h4 id="Context-Enable-ContextEn"><a href="#Context-Enable-ContextEn" class="headerlink" title="Context Enable (ContextEn)"></a>Context Enable (ContextEn)</h4><p>Context Enable (ContextEn) 指示了处理器的 state 和 mode 是否满足软件之前的设置. 例如, 如果在 CPL = 0 状态下的代码执行没有被 trace (IA32_RTIT_CTL.OS = 0), 那么表明 CPL = 0 时, ContextEn 为 0. 软件可以通过查询 IA32_RTIT_STATUS.ContextEn 获取当前 ContextEn 的值.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContextEn <span class="operator">=</span> <span class="operator">!</span>((IA32_RTIT_CTL.OS <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> CPL <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">OR</span> (IA32_RTIT_CTL.USER <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> CPL <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">OR</span> (IS_IN_A_PRODUCTION_ENCLAVE)</span><br><span class="line">              <span class="keyword">OR</span> (IA32_RTIT_CTL.CR3Filter <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> IA32_RTIT_CR3_MATCH does <span class="keyword">not</span> <span class="keyword">match</span> cr3))</span><br></pre></td></tr></table></figure>

<p>如果 clear ContextEn 导致 PacketEn 被 clear, 就会生成一个 Packet Generation Disable (TIP.PGD) 数据包, 但是里面并没有 IP. 如果 set ContextEn 导致 PacketEn set, 那么 Packet Generation Enable (TIP.PGE) 就会生成.</p>
<p>当 ContextEn 被 clear, 控制流相关数据包 (TNT, FUP, TIP.*, MODE.*) 都不会生成, 并且不会暴露出 IP. 其它的包可能会生成.</p>
<p>只有当 TriggerEn = 1 时, ContextEn 的值才会变化, TriggerEn = 0 时, ContextEn 不会改变.</p>
<h4 id="Branch-Enable-BranchEn"><a href="#Branch-Enable-BranchEn" class="headerlink" title="Branch Enable (BranchEn)"></a>Branch Enable (BranchEn)</h4><p>BranchEn 基于 IA32_RTIT_CTL.BranchEn 的值, 如果 BranchEn 没有被 set, 那么相关的 COFI 数据包 (TNT, TIP.*, FUP, MODE.*) 不会生成.</p>
<h4 id="Filter-Enable-FilterEn"><a href="#Filter-Enable-FilterEn" class="headerlink" title="Filter Enable (FilterEn)"></a>Filter Enable (FilterEn)</h4><p>FilterEn 表示 IP 位于之前配置好的 IP 范围中. 软件可以查询 IA32_RTIT_STATUS.FilterEn 获取 FilterEn 的状态.</p>
<p>当 clear FilterEn 之后, 一个 Packet Generation Disable (PGD) 数据包会生成, 但和 ContextEn 不同的是, 目标 IP 数据还是在里面的. 所以可能会有范围之外的 IP 出现在 trace log 中. 当 FilterEn clear, 控制流的数据包就不会生成.</p>
<p>若处理器没有配置 trace range of IP, 或者处理器不支持 IP filtering, 那么 FilterEn 总是被 set. FilterEn 仅仅只会在 TraceEn 和 ContextEn 均为 1 的情况下， 同时在配置好 trace range 之后被开启关闭.</p>
<h3 id="Trace-Output"><a href="#Trace-Output" class="headerlink" title="Trace Output"></a>Trace Output</h3><p>Intel PT 的输出和 trace 内容, 筛选机制独立. 不同的处理器和平台, 支持不同的输出选项. 使用 IA32_RTIT_CTL 中 ToPA 和 FabricEn 域配置输出策略为以下的一种:</p>
<ul>
<li><p>单个, 连续的物理内存地址空间.</p>
</li>
<li><p>多个不同大小的物理内存区域的集合. 这些区域通过一个表来连接和索引, 即 Table of Physical Addresses (ToPA). Trace 的输出绕过 cache 和 TLB 直接写入物理内存, 这个输出策略对性能影响最小, 但输出不一定是序列化的.</p>
</li>
<li><p>平台特定的 trace 传输子系统.</p>
</li>
</ul>
<p>不管选择哪个输出策略, 输出都会绕过 cache. 这保证了 trace 不会消耗宝贵的 cache 空间, 但是和一般的 uncacheable 内存区域的写入不同, trace 输出的写入并不是序列化的. <strong>不要对输出的物理地址区域使用 MTRR 或者 PTE 配置 UnCacheable.</strong></p>
<p>我们并不能控制 trace 在何时输出到物理内存中. 唯一能保证的就是, 将 TraceEn clear, 停止 trace, 并执行 store, fence 或者序列化指令, 从而将处理器内存缓冲区的所有 trace 数据包 flush 到物理内存中.</p>
<h4 id="Single-Range-Out"><a href="#Single-Range-Out" class="headerlink" title="Single Range Out"></a>Single Range Out</h4><p>当 IA32_RTIT_CTL.ToPA 和 IA32_RTIT_CTL.FabricEn 的 bit 是 clear 状态时, trace 数据包会发送到一块连续的物理内存空间 (or MMIO) 中. 这个物理内存空间通过 IA32_RTIT_OUTPUT_BASE 和 IA32_RTIT_OUTPUT_MASK_PTRS 中的 mask 值来确定. 当前的写入指针也存储在 IA32_RTIT_OUTPUT_MASK_PTRS 中, 这个范围是环形的, 在到达缓冲区末尾之后会重新将写入指针移动到缓冲区的 base.</p>
<p>这个方法最好是用在以下场景:</p>
<ul>
<li><p>DRAM 中有足够大的连续空间时</p>
</li>
<li><p>输出到 MMIO 调试端口.</p>
</li>
</ul>
<h4 id="Table-of-Physical-Addresses"><a href="#Table-of-Physical-Addresses" class="headerlink" title="Table of Physical Addresses"></a>Table of Physical Addresses</h4><p>当 IA32_RTIT_CTL.ToPA 是 set, IA32_RTIT_CTL.FabricEn 是 clear 时, 就使用 ToPA 机制. ToPA 使用的是一个环形链表, 每个节点都是一个 table. Table 中的每个 entry 都包含一个物理内存区域 (output region) 的 base 指针和大小, 如果是最后一个 entry， 那就可能存放下一个 table 的物理内存地址.</p>
<p>处理器将这些物理内存区域看作一个统一的 buffer, 所以一个数据包可能横跨两个 output region.</p>
<p>ToPA 机制可以用以下三个值来控制:</p>
<ul>
<li><p>proc_trace_table_base: 这是当前 table 的物理地址. 从 IA32_RTIT_OUTPUT_BASE MSR 寄存器中获取.</p>
</li>
<li><p>proc_trace_table_offset: 当前 table 正在被使用的 entry. 从 IA32_RTIT_OUTPUT_MASK_PTRS 中的 31:7 位获取.</p>
</li>
<li><p>proc_trace_output_offset: 当前 output region 中的指针. 从 IA32_RTIT_OUTPUT_MASK_PTRS 中的 63:32 位获取.</p>
</li>
</ul>
<p>当 trace packet 按照规则写入物理内存时, 若碰到有 entry 标记为 END, 就需要更新 table_base 来切换到下个 table. 若为 STOP,在充满当前 output region 之后停止 trace. 如果一直没有 END 标记或者 STOP 标记, 那么在到达最大 table 大小 (proc_trace_table_offset = 0x0ffffff8h) 之后, 会将 table_offset 和 output_offset 置 0, 循环输出.</p>
<p>很重要的一点是, 处理器对 IA32_RTIT_OUTPUT_BASE 和 IA32_RTIT_OUTPUT_MASK_PTRS MSR 寄存器的更新和指令执行是异步的, 所以直接读取 MSR 得到的值可能是旧的值. 要得到正确的值必须先停止 trace 数据包生成 (clear IA32_RTIT_CTL.TraceEn), 再读取.</p>
<p>同时, 处理器可能会内部 cache 一些 table 的 entry. 如果要修改这些 entry, 也得先停止 trace 再更改.</p>
<p>第一代实现 PT 的处理器只能将 ToPA 配置为 single output region 的模式.</p>
<p>以下是几个 entry 标记的用途:</p>
<ul>
<li><p>ToPA STOP: 当前 output region 满了之后, set IA32_RTIT_STATUS.Stopped 位, 停止 trace. 这类停止没有 TIP.PGD 数据包发出, 并且意味着 CPU 内部缓冲区中的数据包就被丢弃了.</p>
</li>
<li><p>ToPA PMI: 当 INT 标记被设置时, 当前 output region 充满之后就会发出一个 performance-monitoring interrupt 中断. 这个中断也是异步的, 不精确. 并且中断处理的过程也能被 trace, 可以通过 filtering 来解决这个污染. 所以， PMI handle 如果想读取 trace 数据包, 一定要先 clear TraceEn, 停止 trace.</p>
</li>
</ul>
<p>管理 Intel PT ToPA PMI 和 XSAVES/XSTORES 的算法:</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> (IA32_PERF_GLOBAL_STATUS.ToPA)</span><br><span class="line">    Save IA32_RTIT_CTL Value;</span><br><span class="line">    <span class="keyword">IF</span> (IA32_RTIT_CTL.TraceEn)</span><br><span class="line">        Disable Intel PT by clearing TraceEn;</span><br><span class="line">    FI;</span><br><span class="line">    <span class="keyword">IF</span> (There <span class="keyword">is</span> space available <span class="keyword">to</span> grow the current ToPA table)</span><br><span class="line">        Add one more ToPA entries after the last entry <span class="keyword">in</span> the ToPA table;</span><br><span class="line">        Point new ToPA entry address fields <span class="keyword">to</span> new output region base;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        Modify an upcoming ToPA entry <span class="keyword">in</span> the current table <span class="keyword">to</span> have <span class="keyword">END</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">IF</span> (<span class="keyword">out</span> put should translation <span class="keyword">to</span> a new ToPA table)</span><br><span class="line">            Point the address <span class="keyword">of</span> the &quot;<span class="keyword">END</span> = <span class="number">1</span>&quot; entry <span class="keyword">of</span> the current table <span class="keyword">to</span> the new table address base;</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">            /* make a circular*/</span><br><span class="line">            Point the address <span class="keyword">of</span> the &quot;<span class="keyword">END</span> = <span class="number">1</span>&quot; entry <span class="keyword">to</span> the base <span class="keyword">of</span> the current table;</span><br><span class="line">            Modify the ToPA entry address fields <span class="keyword">for</span> filled output regions <span class="keyword">to</span> point <span class="keyword">to</span> new, unused output regions;</span><br><span class="line">        FI;</span><br><span class="line">    FI;</span><br><span class="line">    Restore saved IA32_RTIT_CTL.value;</span><br><span class="line">FI;</span><br></pre></td></tr></table></figure>

<h4 id="Trace-Transport-Subsystem"><a href="#Trace-Transport-Subsystem" class="headerlink" title="Trace Transport Subsystem"></a><del>Trace Transport Subsystem</del></h4><h4 id="Restricted-Memory-Access"><a href="#Restricted-Memory-Access" class="headerlink" title="Restricted Memory Access"></a>Restricted Memory Access</h4><p>Trace 数据包的输出的目的内存区域不能为限制的区域, 比如说所有的输出区域都会受到 SMRR (System-Management Range Register) 的限制, 所有和它重叠的区域都不能作为 output region.</p>
<p>可以先关闭 trace 数据包生成, 再修改 SMRR, 然后再生成数据包.</p>
<h3 id="Enabling-and-Configuration-MSRs"><a href="#Enabling-and-Configuration-MSRs" class="headerlink" title="Enabling and Configuration MSRs"></a>Enabling and Configuration MSRs</h3><h4 id="General-Consideration"><a href="#General-Consideration" class="headerlink" title="General Consideration"></a>General Consideration</h4><p>Trace 数据包的生成可以通过一系列 MSRs 来进行维护:</p>
<ul>
<li><p>处理器不支持 Intel PT 时, 使用 RDMSR 或 WRMSR 操作 IA32_RTIT_* 系列的 MSRs 都会造成 #GP.</p>
</li>
<li><p>在改变 MSRs 之前, 一定要先 clear IA32_RTIT_CTL.TraceEn, 不然也会 #GP.</p>
</li>
<li><p>每个 logical processor 都是一套不同的 MSRs. 意思是每次配置, 都是在一个 logical processor 上配置的.</p>
</li>
<li><p>在 cold REST 之后, 所有的 MSRs 配置都被清除</p>
<ul>
<li>如果 CPUID.(EAX = 14H, ECX = 0):EBX.IPFILT_WRSTPRSV[bit 2] = 1, 那么在 warm REST 之后, 只有 TraceEn bit 被清除, 同时可能影响 IA32_RTIT_STATUS. 但是其它 MSRs 不受影响.</li>
</ul>
</li>
<li><p>除了可以通过 WRMSR 来显式修改外, 还可以使用 VM-exit 或者 VM-entry, XRSTORS, XSAVE 来修改.</p>
</li>
</ul>
<h4 id="IA32-RTIT-CTL-MSR"><a href="#IA32-RTIT-CTL-MSR" class="headerlink" title="IA32_RTIT_CTL MSR"></a>IA32_RTIT_CTL MSR</h4><table>
<thead>
<tr>
<th>Position</th>
<th>Bit Name</th>
<th>At Reset</th>
<th>Bit Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>TraceEn</td>
<td>0</td>
<td>1: tracing, 0: tracing disabled. 从 1 到 0 时, CPU 内部缓冲区会被 flush</td>
</tr>
<tr>
<td>1</td>
<td>CYCEn</td>
<td>0</td>
<td>0: disables CYC Packet, 1: enable CYC Packets</td>
</tr>
<tr>
<td>2</td>
<td>OS</td>
<td>0</td>
<td>0: 当 CPL = 0 时，不生成数据包, 1: CPL = 0 时生成数据包</td>
</tr>
<tr>
<td>3</td>
<td>User</td>
<td>0</td>
<td>0: 当 CPL &gt; 0 时, 不生成数据包, 1: 当 CPL &gt; 0 时, 生成数据包</td>
</tr>
<tr>
<td>4</td>
<td>PwrEvtEn</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>FUPonPTW</td>
<td>0</td>
<td>0: PTW 包后面不跟 FUP 包, 1: 跟</td>
</tr>
<tr>
<td>6</td>
<td>FabricEN</td>
<td>0</td>
<td>0: 使用 ToPA, 1: 不使用</td>
</tr>
<tr>
<td>7</td>
<td>CR3Filter</td>
<td>0</td>
<td>0: 关闭 CR3 filtering, 1: 开启</td>
</tr>
<tr>
<td>8</td>
<td>ToPA</td>
<td>0</td>
<td>0: Single-range output, 1: ToPA output</td>
</tr>
<tr>
<td>9</td>
<td>MTCEn</td>
<td>0</td>
<td>0: disable MTC packets, 1: enable</td>
</tr>
<tr>
<td>10</td>
<td>TSCEn</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>DisRETC</td>
<td>0</td>
<td>0: enable RET compression, 1: disable</td>
</tr>
<tr>
<td>12</td>
<td>PTWEn</td>
<td>0</td>
<td>0: PTWRITE Packet generation disabled, 1: enable</td>
</tr>
<tr>
<td>13</td>
<td>BranchEn</td>
<td>0</td>
<td>0: disable COFI-based packets, 1:enable</td>
</tr>
<tr>
<td>17:14</td>
<td>MTCFreq</td>
<td>0</td>
<td>定义 MTC 数据包的频率, 可以基于 Always Running Timer (ART).</td>
</tr>
<tr>
<td>22:19</td>
<td>CycThresh</td>
<td>0</td>
<td>CYC packet threshold.</td>
</tr>
<tr>
<td>27:24</td>
<td>PSBFreq</td>
<td>0</td>
<td>控制 PSB 的生成频率, 但是不精确</td>
</tr>
<tr>
<td>35:32</td>
<td>ADDR0_CFG</td>
<td>0</td>
<td>0: 不使用 ADDR0, 1: 相关的 MSRs 定义了 IP Filter 的上下界, 2: 相关的 MSRs 定义了 TraceStop 上下界</td>
</tr>
<tr>
<td>39:36</td>
<td>ADDR1_CFG</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>43:40</td>
<td>ADDR2_CFG</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>47:44</td>
<td>ADDR3_CFG</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>56</td>
<td>InjectPsbPmiOnEnable</td>
<td>0</td>
<td>1: Enable IA32RTIT_STATUS 的 PendPSB, PendTopaPMI, 0: disable</td>
</tr>
</tbody></table>
<h4 id="Enabling-and-Disabling-Packet-Generation-wth-TraceEn"><a href="#Enabling-and-Disabling-Packet-Generation-wth-TraceEn" class="headerlink" title="Enabling and Disabling Packet Generation wth TraceEn"></a>Enabling and Disabling Packet Generation wth TraceEn</h4><p>当 TraceEn 从 0 到 1 时, Intel PT 就开始工作, 一系列的数据包开始生成. 这些包能帮助 decoder 获取处理器的状态. 如果 IA32_RTIT_STATUS.PacketByteCnt = 0, 那么就会生成 full PSB+， 如果不为 0, 那么会生成和 timing 相关的数据包, TSC, TMA, CRR 等.</p>
<p>除了上述包, 还可能会有 TIP.PGE 数据包生成. 当处理器生成 trace 时, CPU 会将 ToPA 相应的数据结构放入 cache 提高性能, 所以要修改 ToPA tables 的话, 必须先停止 TraceEn, 再修改.</p>
<h4 id="IA32-RTIT-STATUS-MSR"><a href="#IA32-RTIT-STATUS-MSR" class="headerlink" title="IA32_RTIT_STATUS MSR"></a>IA32_RTIT_STATUS MSR</h4><p>IA32_RTIT_STATUS MSR 是可以使用软件来读写的, 但是有一些位 ContextEn, TriggerEn, 不能直接被修改.</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Bit Name</th>
<th>At Reset</th>
<th>Bit Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>FilterEn</td>
<td>0</td>
<td>表示当前 IP 是能被 trace 的</td>
</tr>
<tr>
<td>1</td>
<td>ContextEn</td>
<td>0</td>
<td>当前上下文是能被 trace 的</td>
</tr>
<tr>
<td>2</td>
<td>TriggerEn</td>
<td>0</td>
<td>表示 trace 开启</td>
</tr>
<tr>
<td>4</td>
<td>Error</td>
<td>0</td>
<td>表示操作出错, 当它被 set 时, TriggerEn 被 clear, trace 终止</td>
</tr>
<tr>
<td>5</td>
<td>Stopped</td>
<td>0</td>
<td>表示 ToPA STOP 标志</td>
</tr>
<tr>
<td>6</td>
<td>PendPSB</td>
<td>0</td>
<td>set 时会插入一个 PSB+ 到 trace 中, 插入后 clear</td>
</tr>
<tr>
<td>7</td>
<td>PendTopaPMI</td>
<td>0</td>
<td>set 时表示要触发 PMI, 触发完毕就 clear</td>
</tr>
<tr>
<td>48:32</td>
<td>PacketByteCnt</td>
<td>0</td>
<td>表示已经发出数据包的 bytes, 可以用它来触发下一个 PSB 包的发送, 在 trace 过程中, 处理器会一直修改这个值.</td>
</tr>
</tbody></table>
<h4 id="IA32-RTIT-ADDRn-A-and-IA32-RTIT-ADDRn-B-MSRs"><a href="#IA32-RTIT-ADDRn-A-and-IA32-RTIT-ADDRn-B-MSRs" class="headerlink" title="IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs"></a>IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs</h4><p>这些 MSRs 可以通过 IA32_RTIT_CTL 中的 ADDRn_CFG 域来启用.</p>
<h4 id="IA32-RTIT-CR3-MATCH-MSR"><a href="#IA32-RTIT-CR3-MATCH-MSR" class="headerlink" title="IA32_RTIT_CR3_MATCH MSR"></a>IA32_RTIT_CR3_MATCH MSR</h4><p>当 IA32_RTIT_CTL.CR3Filter = 1 时, 会把它与当前 CR3 作比较. 63:5 这几位保存了 CR3 的值.</p>
<h4 id="IA32-RTIT-OUTPUT-BASE-MSR"><a href="#IA32-RTIT-OUTPUT-BASE-MSR" class="headerlink" title="IA32_RTIT_OUTPUT_BASE MSR"></a>IA32_RTIT_OUTPUT_BASE MSR</h4><p>这个是用来配置 trace 输出的目的物理地址, 它的大小受到最大物理地址宽度的限制 (MAXPHYADDR), 从 CPUID.80000008H:EAX[7:0]获取.</p>
<p>当使用 ToPA 输出模式时, 处理器可能会更新这个 MSR 的值, 但是指令的执行和处理器的更新是异步的, 所以这个 MSR 里面的值在 trace 期间是 unreliable 的.</p>
<h4 id="IA32-RTIT-OUTPUT-MASK-PTRS-MSR"><a href="#IA32-RTIT-OUTPUT-MASK-PTRS-MSR" class="headerlink" title="IA32_RTIT_OUTPUT_MASK_PTRS MSR"></a>IA32_RTIT_OUTPUT_MASK_PTRS MSR</h4><p>这个 MSR 存储的是 trace 下一个 byte 输出的位置. 和上面一样, 异步更新, unreliable.</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Bit Name</th>
<th>At Rest</th>
<th>Bit Description</th>
</tr>
</thead>
<tbody><tr>
<td>6:0</td>
<td>LowerMask</td>
<td>7FH</td>
<td>强制为 1</td>
</tr>
<tr>
<td>31：7</td>
<td>MaskOrTableOffset</td>
<td>0</td>
<td>这个值的意义取决于 IA32_RTIT_CTL.ToPA 的值. 若 ToPA = 0, 表示这就是 single, contiguous physical output region 的 <strong>mask value</strong>. 所以, 这个区域的大小一定是在 128B 到 4GB. 若 ToPA = 1, 表示的是当前 <strong>ToPA table 中 offset pointer</strong> 的 27:3 bits, 加上上面的 IA32_RTIT_OUTPUT_BASE 可以获取当前 entry 的指针. 每个 table 大小最大为 256 MB.</td>
</tr>
<tr>
<td>63:32</td>
<td>Output offset</td>
<td>0</td>
<td>这个值的意义取决于 IA32_RTIT_CTL.ToPA 的值. 若 ToPA = 0, 表示这个是 single, contiguous physical output region 的 <strong>offset pointer</strong>. 加上 IA32_RTIT_OUTPUT_BASE 的值就可以得到下个 byte 要写入的地址. 这个值一定要小于等于 MaskOrTableOffset. 若 ToPA = 1, 这个是当前 <strong>ToPA output region 的 offset pointer</strong>. 加上 output region 的 base 之后, 可以获得下个 byte 写入的地址</td>
</tr>
</tbody></table>
<h3 id="Interaction-of-Intel-Processor-Trace-and-Other-Processor-Features"><a href="#Interaction-of-Intel-Processor-Trace-and-Other-Processor-Features" class="headerlink" title="Interaction of Intel Processor Trace and Other Processor Features"></a>Interaction of Intel Processor Trace and Other Processor Features</h3><p>TODO</p>
<h2 id="CONFIGURATION-AND-PROGRAMMING-GUIDELINE"><a href="#CONFIGURATION-AND-PROGRAMMING-GUIDELINE" class="headerlink" title="CONFIGURATION AND PROGRAMMING GUIDELINE"></a>CONFIGURATION AND PROGRAMMING GUIDELINE</h2><h3 id="Detection-of-Intel-Processor-Trace-and-Capability-Enumeration"><a href="#Detection-of-Intel-Processor-Trace-and-Capability-Enumeration" class="headerlink" title="Detection of Intel Processor Trace and Capability Enumeration"></a>Detection of Intel Processor Trace and Capability Enumeration</h3><p>见代码</p>
<h4 id="Packet-Decoding-of-RIP-versus-LIP"><a href="#Packet-Decoding-of-RIP-versus-LIP" class="headerlink" title="Packet Decoding of RIP versus LIP"></a>Packet Decoding of RIP versus LIP</h4><p>FUP, TIP, TIP.PEG 和 TIP.PGD 可能会包含 IP payload. 在有些处理器中, 这个 payload 是 effective address (RIP), 其它就是 linear address (LIP). 前面的模式下, payload 里面的值是距离 code segment base (CS) 的偏移, 后面的是偏移加上 code segment base. 对于执行过程中 CS base address 为 0 的软件 (64 bit mode), 这两者没有区别.</p>
<p>对于 IP filtering 和 TraceStop 中配置的 IP 类型, 也需要和这个保持一致.</p>
<h4 id="Model-Specific-Capability-Restrictions"><a href="#Model-Specific-Capability-Restrictions" class="headerlink" title="Model Specific Capability Restrictions"></a>Model Specific Capability Restrictions</h4><p>有一些处理器在进行 trace 的过程中, 限制了对 LBRs/BTS/BTM/LERs 等 MSRs 的使用.</p>
<h3 id="Enabling-and-Configuration-of-Trace-Packet-Generation"><a href="#Enabling-and-Configuration-of-Trace-Packet-Generation" class="headerlink" title="Enabling and Configuration of Trace Packet Generation"></a>Enabling and Configuration of Trace Packet Generation</h3><p>首先检测是否支持 Intel PT, 然后再配置一系列 MSRs 进行 Trace.</p>
<p>以下是 Skylake (6th gen), Kaby Lake (7th gen), Coffee Lake (8th gen and 9th gen), Cannon Lake (8th gen i3) 的 PT 相关 MSRs.</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>Dec</th>
<th>Register Name</th>
<th>Scope</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>0x560H</td>
<td>1376</td>
<td>IA32_OUTPUT_BASE</td>
<td>Thread</td>
<td>Trace Output Base Register (R/W)</td>
</tr>
<tr>
<td>0x561H</td>
<td>1377</td>
<td>IA32_OUTPUT_MASK_PTRS</td>
<td>Thread</td>
<td>Trace Output Mask Pointer Register (R/W)</td>
</tr>
<tr>
<td>0x570H</td>
<td>1392</td>
<td>IA32_RTIT_CTL</td>
<td>Thread</td>
<td>Trace Control Register (R/W)</td>
</tr>
<tr>
<td>0x571H</td>
<td>1393</td>
<td>IA32_RTIT_STATUS</td>
<td>Thread</td>
<td>Tracing Status Register (R/W)</td>
</tr>
<tr>
<td>0x572H</td>
<td>1394</td>
<td>IA32_RTIT_CR3_MATCH</td>
<td>Thread</td>
<td>Trace Filter CR3 Match Register (R/W)</td>
</tr>
<tr>
<td>0x580H</td>
<td>1408</td>
<td>IA32_RTIT_ADDR0_A</td>
<td>Thread</td>
<td>Region 0 Start Address (R/W)</td>
</tr>
<tr>
<td>0x581H</td>
<td>1409</td>
<td>IA32_RTIT_ADDR0_B</td>
<td>Thread</td>
<td>Region 0 End Address (R/W)</td>
</tr>
<tr>
<td>0x582H</td>
<td>1410</td>
<td>IA32_RTIT_ADDR1_A</td>
<td>Thread</td>
<td>Region 1 Start Address (R/W)</td>
</tr>
<tr>
<td>0x583H</td>
<td>1411</td>
<td>IA32_RTIT_ADDR1_A</td>
<td>Thread</td>
<td>Region 1 End Address (R/W)</td>
</tr>
</tbody></table>
<h4 id="Enabling-Packet-Generation"><a href="#Enabling-Packet-Generation" class="headerlink" title="Enabling Packet Generation"></a>Enabling Packet Generation</h4><p>set IA32_RTIT_CTL 中的 TraceEn.</p>
<h4 id="Disabling-Packet-Generation"><a href="#Disabling-Packet-Generation" class="headerlink" title="Disabling Packet Generation"></a>Disabling Packet Generation</h4><p>clear IA32_RTIT_CTL 中的 TraceEn, 然后再看看 IA32_RTIT_STATUS MSR 中的 Error bit 和 Stopped bit, 判断停止 trace 的原因.</p>
<h3 id="Flushing-Trace-Output"><a href="#Flushing-Trace-Output" class="headerlink" title="Flushing Trace Output"></a>Flushing Trace Output</h3><p>数据包都是在 CPU 内部 buffer 中被异步的写入内存. 所以解码器必须先停止 trace 使得所有的数据包都被 flush out.</p>
<h3 id="Warm-reset"><a href="#Warm-reset" class="headerlink" title="Warm reset"></a>Warm reset</h3><p>在 Warm reset 时, MSR 里面配置的内容不会丢失, 除了 TraceEn, 和 IA32_RTIT_STATUS 中的某些 bit.</p>
<h4 id="Manual-Trace-Configuration-Context-Switch"><a href="#Manual-Trace-Configuration-Context-Switch" class="headerlink" title="Manual Trace Configuration Context Switch"></a>Manual Trace Configuration Context Switch</h4><p>可以通过 RDMSR, WRMSR 来将配置进行 save, 和 restore. 保存 trace 配置上下文的方法如下:</p>
<ol>
<li><p>RDMSR IA32_RTIT_CTL, 将值保存到内存</p>
</li>
<li><p>WRMSR IA32_RTIT_CTL, 将上面保存的值写入 MSR, 但是注意写入之前 clear TraceEn</p>
</li>
<li><p>将其它的 MSR 的配置使用 RDMSR 读取, 将更改后的值保存在内存中</p>
</li>
</ol>
<p>恢复 trace 配置上下文过程:</p>
<ol>
<li><p>将保存在内存的值写入到 MSR, 除了 IA32_RTIT_CTL</p>
</li>
<li><p>将保存在内存中 IA32_RTIT_CTL 的值写入 MSR</p>
</li>
</ol>
<h4 id="Trace-Configuration-Context-Switch-Using-XSAVES-XRSTORS"><a href="#Trace-Configuration-Context-Switch-Using-XSAVES-XRSTORS" class="headerlink" title="Trace Configuration Context Switch Using XSAVES/XRSTORS"></a>Trace Configuration Context Switch Using XSAVES/XRSTORS</h4><p>TODO</p>
<h3 id="Cycle-Accurate-Mode"><a href="#Cycle-Accurate-Mode" class="headerlink" title="Cycle-Accurate Mode"></a>Cycle-Accurate Mode</h3><p>CYC 数据包提供处理器 core clock domain 的底层信息. 只和指令执行的 <em>时间</em> 相关.</p>
<p>TODO</p>
<h3 id="Decoder-Synchronization-PSB"><a href="#Decoder-Synchronization-PSB" class="headerlink" title="Decoder Synchronization (PSB+)"></a>Decoder Synchronization (PSB+)</h3><p>Decoder 使用 PSB 数据包作为 trace log 的同步点. 除了简单的同步之外, decoder 还需要知道一些状态 (state) 信息和潜在的时间信息. Decoder 每次获取的信息一定是在两个 PSB 之间的, 比如 LastIP, call stack, compound packet event.</p>
<p>当 PSB 生成时, 在它之后会有一个 PSBEND 数据包. 在这两个数据包之间的是 decoder 需要了解的处理器状态 (state) 信息. 这些数据包就是 PSB+, 他们表示的是 status, 并不会改变 PSB 的 state, 也和其它指令没什么关系. PSB+ 可以包括当前的 Timestamp.</p>
<h3 id="Internal-Buffer-Overflow"><a href="#Internal-Buffer-Overflow" class="headerlink" title="Internal Buffer Overflow"></a>Internal Buffer Overflow</h3><p>TODO</p>
<h2 id="Trace-Packets-and-Data-Types"><a href="#Trace-Packets-and-Data-Types" class="headerlink" title="Trace Packets and Data Types"></a>Trace Packets and Data Types</h2><h3 id="Packet-Relationships-and-Ordering"><a href="#Packet-Relationships-and-Ordering" class="headerlink" title="Packet Relationships and Ordering"></a>Packet Relationships and Ordering</h3><p>这一节主要讲, 怎么把这些数据包中和反汇编的的代码绑定 (binding) 起来. 有一些数据包 (TIP, FUP) 的 payload 就有关联的 IP, 其它的数据包 (TNT) 需要由 decoder 来查找具体的指令来绑定. Decoder 都需要考虑到这些数据包之间的关系, 然后使用这些关系来确定如何 bind 这些数据包.</p>
<p>有一些叫做 “compound packet event” 的事件, 比如中断, 异常等, 只需要一条指令就能产生多个数据包. 这些 compound event 生成的数据包很多都是以 FUP 开头来表示 source address, 然后以 TIP 或者 TIP.PGD 结尾来表示 destination address. 在这个场景下, 就可以说 FUP is “coupled with” TIP. 有一些其它的包可能处于这两者中间, 比如和时间相关的, 和状态相关的.</p>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Beginning</th>
<th>Middle</th>
<th>End</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Unconditional, uncompressed control-flow transfer</td>
<td>FUP, or none</td>
<td>Any combination of PIP, VMCS, Mode.Exec, or None</td>
<td>TIP or TIP.PGD</td>
<td>FUP only for asynchronous events. Order of middle packets may vary. PIP/VMCS/MODE only if the operation modifies the state tracked by these respective packets</td>
</tr>
<tr>
<td>TSX Update</td>
<td>MODE.TSX, and (FUP or none)</td>
<td>None</td>
<td>TIP, TIP.PGD, or none</td>
<td>FUP TIP/TIP.PGD only for TSX abort case</td>
</tr>
<tr>
<td>Overflow</td>
<td>OVF</td>
<td>PSB, PSBEND, or none</td>
<td>FUP or TIP.PGE</td>
<td>FUP if overflow resolves while ContextEn = 1, else TIP.PGE</td>
</tr>
</tbody></table>
<h4 id="Packet-Blocks"><a href="#Packet-Blocks" class="headerlink" title="Packet Blocks"></a>Packet Blocks</h4><p>Packet blocks 是用来 dump 一些状态值的. 具体看手册.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/processer-trace/" rel="tag"># processer trace</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/05/22/Kaleidoscope-Extending-the-language-Control-Flow/" rel="prev" title="Kaleidoscope: Extending the Language: Control Flow">
                  <i class="fa fa-chevron-left"></i> Kaleidoscope: Extending the Language: Control Flow
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/08/01/Efficient-Context-Sensitive-Pointer-Analysis-for-C-Programs/" rel="next" title="Efficient Context-Sensitive Pointer Analysis for C Programs">
                  Efficient Context-Sensitive Pointer Analysis for C Programs <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhangtong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
