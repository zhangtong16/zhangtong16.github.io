<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="Zhangtong&#39;s Notebook">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zhangtong&#39;s Notebook">
<meta property="og:locale">
<meta property="article:author" content="Zhangtong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Zhangtong's Notebook</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhangtong's Notebook</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhangtong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhangtong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/22/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-22 16:59:23" itemprop="dateCreated datePublished" datetime="2021-05-22T16:59:23+08:00">2021-05-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/22/reborn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/reborn/" class="post-title-link" itemprop="url">reborn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-22 16:17:45 / Modified: 17:03:11" itemprop="dateCreated datePublished" datetime="2021-05-22T16:17:45+08:00">2021-05-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>test</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/Intel-Memory-Protection-Extensions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/17/Intel-Memory-Protection-Extensions/" class="post-title-link" itemprop="url">Intel Memory Protection Extensions</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-01-17 21:22:32" itemprop="dateCreated datePublished" datetime="2020-01-17T21:22:32+08:00">2020-01-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Intel MPX is designed to allow a system to run both Intel MPX enabled software and legacy software. MPX enabled application can link with, call into, or be called from legacy software. MPX associates <strong>bounds</strong> with pointers in a novel manner, and uses <strong>bounds</strong> to check that pointer based accesses are suitably constrained. Futhermore, programmers can <strong>selectively</strong> use MPX to protect a subset of pointers.</p>
<p>The initial goal of MPX is twofold: 1) provide means to defend a system against attacks, 2) provide means to pinpoint accidental logic defects in pointer usage.</p>
<h2 id="Programming-Environment"><a href="#Programming-Environment" class="headerlink" title="Programming Environment"></a>Programming Environment</h2><p>Intel MPX can be enabled for user mode and supervisor mode. And, it is designed to allow software to associate bounds with pointers, and allows software to check memory references against the bounds to prevent out of bound access. The <strong>bounds</strong> registers hold lower bound and upper bound. An OOB access can causes a #BR (Bound Range Exceeded) exception.</p>
<p>The <code>BNDLDX</code> and <code>BNDSTX</code> instructions each take an operand whose bits are used to travese data structure in memory. In 64-bit mode, these instructions operate only on the lower bits in the supplied 64-bit addresses. The number of bits used is 48 plus a value called the <strong>MPX address-width adjust(MAWA)</strong> which depends on CPL (if CPL &lt; 3 then MAWA = 0 else MAWA = <code>CPUID.(EAX=07H,ECX=0H):ECX.MAWAU[bits 21:17]</code>).</p>
<h3 id="Bounds-Registers"><a href="#Bounds-Registers" class="headerlink" title="Bounds Registers"></a>Bounds Registers</h3><p>Intel MPX architectrure defines four registers <code>BND0-3</code>, each of which stores a pair of 64-bit lower bound (LB) and upper bound (UB). The bounds are <strong>inclusive</strong>. The upper bounds are architecturally represented in 1’s complement form. Thus, lower bound = 0, upper bound = 0 will allow access entire address space.</p>
<h3 id="Configuration-and-Status-Registers"><a href="#Configuration-and-Status-Registers" class="headerlink" title="Configuration and Status Registers"></a>Configuration and Status Registers</h3><p>Intel MPX defines two configuration registers for user mode (<code>BNDCFGU</code>) and supervisor mode (<code>BDNCFGS</code>), respectively. Also, Intel MPX defines a status register (<code>BNDSTATUS</code>) primarily used to communicates states information for #BR exception.</p>
<h2 id="Intel-MPX-Instruction-Summary"><a href="#Intel-MPX-Instruction-Summary" class="headerlink" title="Intel MPX Instruction Summary"></a>Intel MPX Instruction Summary</h2><h3 id="Usage-and-Examples"><a href="#Usage-and-Examples" class="headerlink" title="Usage and Examples"></a>Usage and Examples</h3><p><code>BNDMK</code> is typically used after memory is allocated for a buffer. However, many other usages are possible such as when accessing an array member of a structure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume the array A is allocated on the stack at &#x27;offset&#x27; from `RBP`</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// the instruction to store starting address of array will be</span></span><br><span class="line">	LEA RAX, [RBP+offset]</span><br><span class="line"><span class="comment">// the instruction to create the bounds for array A will be</span></span><br><span class="line">	BNDMK BND0, [RAX+<span class="number">399</span>]</span><br><span class="line"><span class="comment">// store RAX into BND0.LB and ~(RAX+399) into BND0.UB</span></span><br></pre></td></tr></table></figure>

<p><code>BNDMOV</code> is typically used to copy bounds from one bound register to another when a pointer is copied from one GP register to another, or to spill/fill bounds into memory corresponding to a spill/fill of a pointer.</p>
<p><code>BNDCL</code>/<code>BNDCU</code>/<code>BNDCN</code> are typically used before writing to a buffer but can be used in other instances as well. The pointer used to write to memory will be compared against lower bound. However, for upper bound check, the software must add the (operand size - 1) to the pointer before upper bound checking.</p>
<p><code>BNDSTX</code> is used to store the bounds associated with a buffer and the “pointer value” of the pointer to that buffer onto a bound table entry via address translation using a two-level structure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume a buffer with bounds stored in `BND0`, the pointer to the buffer is in ESI, the following sequence will store the &quot;pointer value&quot; and the bounds into a a configured bound table entry.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// store the pointer value in the index register ECX</span></span><br><span class="line">MOV ECX, DWORD ptr [ESI]</span><br><span class="line"></span><br><span class="line"><span class="comment">// store the pointer in the base register EAX</span></span><br><span class="line">MOV EAX, ESI</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform address translation from the linear address of the base EAX and store bounds and pointer value ECX onto a bound table entry</span></span><br><span class="line">BNDSTX DWORD ptr [EAX+ECX], BND0</span><br><span class="line"></span><br><span class="line"><span class="comment">// Similarly, to retrieve a buffer and its associated bonds from a bound table entry</span></span><br><span class="line">MOV EAX, DWORD ptr [EBX]</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform address translation from the linear address of the base EBX, and loads bounds and pointer value from a bound table entry</span></span><br><span class="line">BNDLDX BND0, dword ptr [EBX+EAX]</span><br></pre></td></tr></table></figure>

<h3 id="Loading-and-Storing-Bounds-in-Memory"><a href="#Loading-and-Storing-Bounds-in-Memory" class="headerlink" title="Loading and Storing Bounds in Memory"></a>Loading and Storing Bounds in Memory</h3><p>Intel MPX defines two instructions to load and store of the linear address of a pointer to a buffer, along with the bounds of the buffer into a data structure of extended bounds. When storing these extended bounds, the processor parses the address of the pointer (where it is stored) to locate an entry in a <strong>bound table</strong> in which to store the extended bounds.</p>
<p>An extended bound is a 4-tuple consisting of lower bounds, upper bound, pointer value and a reserved field. On 64-bit paging mode, a bound table entry is 4*64 bits (32 bytes). The linear address of a bound table is stored in a <strong>bound directory</strong> entry.The linear address of the bound directory is derived from either <code>BNDCFU</code> or <code>BNDCFGS</code>.</p>
<p>The bound directory and bound table are stored in <strong>application memory</strong> and are allocated by the application. In 64-bit mode, the size of a bound table is 4 MBytes (2 <sup>17</sup> * 32 bytes), and the size of a bound directory is 2 <sup>1 + MAWA</sup> GBytes (2 <sup>28+MAWA</sup>).</p>
<p>Bounds in memory are associated with the memory address where the pointer is stored.</p>
<h4 id="BNDLDX-and-BNDSTX-in-64-Bit-Mode"><a href="#BNDLDX-and-BNDSTX-in-64-Bit-Mode" class="headerlink" title="BNDLDX and BNDSTX in 64-Bit Mode"></a><code>BNDLDX</code> and <code>BNDSTX</code> in 64-Bit Mode</h4><p>The linear address of the bound directory is derived from <code>BNDCFGs</code>. In 64-bit mode, each bound-directory entry (BDE) is 8 bytes. The number of entries in the bound directory is 2<sup>28+MAWA</sup>.</p>
<p>In 64-bit mode, the processor uses the two-level structures to access extended bounds as follows:</p>
<ul>
<li><p>In the first stage, the corresponding BD entry has to be loaded. For that, the CPU: (1) extracts the offset of BD entry from bits 20:47 of the pointer address and shifted it by 3 bits. (2) loads the base address of BD from the <code>BDCFGx</code> register, and (3) sums the base and the offset and loads the BD entry of the resulting address.</p>
</li>
<li><p>In the second stage, the CPU: (4) extracts the offset of BT entry from bits 3:19 of the pointer address and shifts it by 5 bits, (5) shifts the loaded entry by 3 to remove the metadata contained in the first 3 bits, and (6) sums the base and the offset and (7) finally loads the BT entry from the resulting address.</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/How-to-Read-a-Paper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/07/How-to-Read-a-Paper/" class="post-title-link" itemprop="url">How to Read a Paper</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-12-07 17:00:59" itemprop="dateCreated datePublished" datetime="2019-12-07T17:00:59+08:00">2019-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="如何阅读-paper"><a href="#如何阅读-paper" class="headerlink" title="如何阅读 paper?"></a>如何阅读 paper?</h2><p><a target="_blank" rel="noopener" href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf">How to Read a Paper</a></p>
<h3 id="The-three-pass-approach"><a href="#The-three-pass-approach" class="headerlink" title="The three-pass approach"></a>The three-pass approach</h3><h4 id="The-first-pass"><a href="#The-first-pass" class="headerlink" title="The first pass"></a>The first pass</h4><ol>
<li><p>迅速看一遍 title, abstract, 和 introduction</p>
</li>
<li><p>读 section 和 subsection 的<strong>标题</strong></p>
</li>
<li><p>读 conclusion</p>
</li>
<li><p>看 references, 已经看过的 paper 可以忽略</p>
</li>
</ol>
<p>并回答如下几个问题</p>
<ol>
<li><p>Category: 这篇 paper 的类型. 是度量, 是对存在系统的分析, 还是对某个 prototype 的描述?</p>
</li>
<li><p>Context: 它和哪些 paper 相关, 它利用了哪些理论基础来分析这个问题?</p>
</li>
<li><p>Correctness: 论文的假设可行吗?</p>
</li>
<li><p>Contribution: 这篇 paper 的主要贡献点为?</p>
</li>
<li><p>Clarity: 这篇 paper 写作水平如何?</p>
</li>
</ol>
<p>通过回答这些问题, 我们就能知道这篇 paper 是否有看下去的必要. 同时我们在写 paper 的时候, 主要就面向于上述问题.</p>
<h4 id="The-second-pass"><a href="#The-second-pass" class="headerlink" title="The second pass"></a>The second pass</h4><ol>
<li><p>仔细看 figures, diagrams 和其它类型的图表. 它们是否都标了坐标轴? 这些结果是否含有 error bar(置信区间)?</p>
</li>
<li><p>记得标注出这篇 paper 的 reference 中, 你没有读过的部分. 这能有效地帮助你了解背景知识</p>
</li>
</ol>
<p>这个部分大致需要 1 小时地时间. 在走完这步后, 你应该能抓住 paper 的重点, 并向其它人简述它的结构与原理. 如果这篇 paper 不属于你的研究领域, 那么对它理解到这个程度是比较合适的.</p>
<p>有时候你在过完这部分之后还是不理解这篇 paper, 这可能是因为你之前没有接触过相关的内容, 不理解其中的一些术语和缩写. 或者作者可能使用了你不理解的证明或者实验方式. 还有可能是因为 paper 写得不够好. 你现在有 3 个选择: a) 不看它了, b) 重新读一些背景材料, c) 直接读 the third pass</p>
<h4 id="The-third-pass"><a href="#The-third-pass" class="headerlink" title="The third pass"></a>The third pass</h4><p>为了完全理解这篇文章, 需要 the third pass. 这一步的关键在于, 尝试<strong>虚拟复现</strong> (virtually re-implement) 这篇文章, 即做出和作者相同的假设, 复现他的工作. 通过比较这篇文章实际的实现过程, 你不仅可以发现这篇 paper 的创新点, 还可以发现它隐藏的失误和假设.</p>
<p>我们需要专注于细节上, 质疑每条语句中的假设. 并且, 你应该提出一个自己的实现方案. 然后把你的实现方案和 paper 中的方案作比较, 这样你就能够了解这篇文章所使用的证明和技术, 并将它们加入你自己的技能库. 同时这样也可以为 future work 提供想法.</p>
<p>刚开始时, 这一步可能需要 4, 5 个小时, 到后面可能需要差不多 1 小时. 在最后, 你应该能够在脑海中重构这篇 paper 的整个结构, 并能识别出这篇 paper 的优点和缺点. 特别是能够精确识别隐藏的假设, 缺失的引用和实验中存在的问题.</p>
<h3 id="Doing-a-literature-survey"><a href="#Doing-a-literature-survey" class="headerlink" title="Doing a literature survey"></a>Doing a literature survey</h3><p>做 survey 能够测试你的论文阅读能力. 但是 survey 需要几十篇论文的阅读量, 你需要读什么 paper? 这个也能通过 three-pass 的方式来帮助你.</p>
<p>首先利用学术搜索引擎选择 keywords 去找 3 到 5 篇这个领域最近的工作. 在每篇 paper 中做 one pass, 初略了解这些工作, 然后阅读它们中的 <strong>related works</strong> 相关的章节. 如果它们中提到了存在的 survey, 那么直接看就好了.</p>
<p>然后, 去看他们的 reference, 找到相同的引用论文以及重复的作者名字. 这些被引用的 paper 和作者就是这些领域的关键工作和研究者. 将这些文章下载下来, 并去这些作者的个人网站上去看他们的 publications. 通过这样你就能找到领域内的顶会.</p>
<p>第三步就是去顶会网站上找最近的会议论文集, 然后找到一些高质量的相关文献. 将这些文献和前面的关键工作下载之后, 使用 two pass 的方式去阅读, 并组成你的 survey. 如果他们都引用了你之前没有找到的文章, 那么也将这些文章添加到 survey 里面中.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/01/Efficient-Context-Sensitive-Pointer-Analysis-for-C-Programs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/01/Efficient-Context-Sensitive-Pointer-Analysis-for-C-Programs/" class="post-title-link" itemprop="url">Efficient Context-Sensitive Pointer Analysis for C Programs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-08-01 15:27:44" itemprop="dateCreated datePublished" datetime="2019-08-01T15:27:44+08:00">2019-08-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Point analysis promises significant benefits for optimizing and parallelizing compilers. However, the analysis must be efficient without sacrificing the accuracy of results. Moreover, the pointer analysis must handle real C programs.</p>
<p>Our approach is based on the insight that procedures are typically called with the same aliases among their inputs. Our idea is to generate <em>incomplete</em> transfer functions that only cover the input conditions that exists in the program. These incomplete transfer functions are made up of simple <em>partial</em> transfer functions (PTFs) that are only applicable to calling contexts that exhibit certain alias relationships.</p>
<h2 id="Major-Concepts"><a href="#Major-Concepts" class="headerlink" title="Major Concepts"></a>Major Concepts</h2><h3 id="Partial-Transfer-Functions"><a href="#Partial-Transfer-Functions" class="headerlink" title="Partial Transfer Functions"></a>Partial Transfer Functions</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q, <span class="keyword">int</span> *r)</span> </span>&#123;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = *r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">int</span> *x0, *y0, *z0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x0 = &amp;x;</span><br><span class="line">    y0 = &amp;y;</span><br><span class="line">    z0 = &amp;z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test1)</span><br><span class="line">        f(&amp;x0, &amp;y0, &amp;z0);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (test2)</span><br><span class="line">        f(&amp;z0, &amp;x0, &amp;y0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f(&amp;x0, &amp;y0, &amp;x0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The example function <code>int f(int *, int *, int *)</code> illustrates two points. First, the alias among the inputs to a procedure determine its behavior. Second, even for this simple two-statement procedure the complete summary is fairly complex;</p>
<p>The main idea behind our algorithm is that we need not summarize a procedure for all possible aliases among its inputs. Instead, we only to find <strong>summaries that apply to the specific alias patterns that occur in the program</strong>.</p>
<h3 id="Design-of-PTFs"><a href="#Design-of-PTFs" class="headerlink" title="Design of PTFs"></a>Design of PTFs</h3><p>There is a tradeoff between the complexity of the individual PTFs and their applicability. Whenever the analysis encounters another call to the procedure with the same input values, it can reuse the final values recorded in the PTF, which known as <em>memorization</em>.</p>
<p>Since it is not the specific input values but their alias patterns that determine the behavior of a procedure, we use symbolic names called <em>extended parameters</em> to abstract the input values. An extended parameter represents the locations reached through an input pointer at the beginning of a procedure.</p>
<p>Extended parameters’ three important roles:</p>
<ol>
<li><p>Extended parameters make up part of the name space of a procedure.</p>
</li>
<li><p>The initial points-to function for a PTF specifies the input domain.</p>
</li>
<li><p>The final points-to function at the procedure exit summarizes the pointer assignments.</p>
</li>
</ol>
<p>Besides the alias, the input domain of a PTF is also defined by the value of function pointers passed in and used in calls within the procedure. Because they determine what code could be executed.</p>
<h3 id="Algorithm-Outline"><a href="#Algorithm-Outline" class="headerlink" title="Algorithm Outline"></a>Algorithm Outline</h3><p>When we begin analyzing a procedure, the initial points-to function is empty and the parameter mapping only records the actual values for the formal parameters. When we need to know the initial value of an input pointer and it is not already recorded, we add an entry to the initial points-to function. To check for aliases, we need to look up the initial values in the calling context. The process continues recursively up the call graph until the pointer values are known.</p>
<p>When the iterative analysis encounters a procedure call, it needs to find the effects of the call on the points-to function. if the call is through a pointer passed as an input to one or more of the PTFs on the call stack, we add the potential values of that pointer to the specifications of the input domains for those PTFs. For each potential callee procedure, we first check if any of its PTFs apply. This involves building up a parameter mapping and comparing the input alias to those recorded for the PTF.</p>
<h2 id="Pointer-Representations"><a href="#Pointer-Representations" class="headerlink" title="Pointer Representations"></a>Pointer Representations</h2><p>Instead of using types to identify locations that may contain pointers, we assume that any memory location could potentially hold a pointer. we also refer to locations within a block of memory by their positions, not by their field names. We define a new abstraction, the <em>location set</em>, to specify both a block of memory and a set of positions within that block.</p>
<p>We divide memory into blocks of contiguous storage, whose positions relative to one another are undefined. A block of memory may be one of three kinds: a local variable, a locally allocated heap block, or an extended parameter (global variables).</p>
<p>We distinguish heap blocks based on their allocation context, grouping together all the blocks allocated in each context. The minimal context information is simply the statement that creates the block.</p>
<h3 id="Location-Sets"><a href="#Location-Sets" class="headerlink" title="Location Sets"></a>Location Sets</h3><p>Our goal with regard to aggregates is to distinguish between different fields within a structure but not the different element of an array. Our pointer analysis can be combined with data dependence tests to distinguish between different array elements.</p>
<p>A location set is a triple (<em>b</em>, <em>f</em>, <em>s</em>) where the base <em>b</em> is the name for a block of memory, <em>f</em> is an offset within that block, and <em>s</em> is the stride. That i, it represents the set of locations {<em>f</em> + <em>is</em> | <em>i</em> ∈ Ƶ} within block <em>b</em>.</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Location Set</th>
</tr>
</thead>
<tbody><tr>
<td>scalar</td>
<td>(scalar, 0, 0)</td>
</tr>
<tr>
<td>struct.F</td>
<td>(struct, f, 0)</td>
</tr>
<tr>
<td>array</td>
<td>(array, 0, 0)</td>
</tr>
<tr>
<td>array[i]</td>
<td>(array, 0, s)</td>
</tr>
<tr>
<td>array[i].F</td>
<td>(array, f, s)</td>
</tr>
<tr>
<td>struct.F[i]</td>
<td>(struct, f % s, s)</td>
</tr>
<tr>
<td>*(&amp;p + X)</td>
<td>(p, 0, 1)</td>
</tr>
</tbody></table>
<h3 id="Extended-Parameters"><a href="#Extended-Parameters" class="headerlink" title="Extended Parameters"></a>Extended Parameters</h3><p>Every object is represented by at most one extended parameter. When adding an entry to the initial points-to function we first find the values of the pointer in the calling context. If the parameter mapping shows that an existing parameter already includes the same values, we reuse the old parameter instead of creating new one.</p>
<p>For simplicity and efficiency, each initial points-to entry points to a single extended parameter. In cases where the initial values are aliased with more than one parameter, we create a new extended parameter that subsumes all the aliased parameters, and we replace all references to the subsumed parameters. Likewise, when the initial values are aliased with an existing parameter but also include new values, we subsume the aliased parameter with new one.</p>
<p>Aliases involving fields of structures can be a bit more complicated. When updating the initial points-to function, if we find a pointer to a field of an existing parameter, we can easily record that fact. However, if we encounter a pointer to a field before a pointer to the enclosing structure, we will create an extended parameter to represent the field. We simply allow the location set offsets to be negative.</p>
<h3 id="Points-to-Functions"><a href="#Points-to-Functions" class="headerlink" title="Points-to Functions"></a>Points-to Functions</h3><p>A points-to function is a mapping from location sets to sets of location sets. It is important for the analysis to know which locations may contain pointers. Since we do not use the high-level type, and since the points-to function only contain entries for pointers that have been referenced, we record separately for each block of memory the location sets that may hold pointers.</p>
<p>Within the pointer analysis itself, that information can enable <em>strong updates</em>, where assignments overwrite the previous contents of their destinations. We only need that information at the point where a pointer is dereferenced.</p>
<h2 id="Analyzing-a-Procedure"><a href="#Analyzing-a-Procedure" class="headerlink" title="Analyzing a Procedure"></a>Analyzing a Procedure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EvalProc</span><span class="params">(proc *pr, PTF *ptf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* iteratively analyze a procedure */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line">        foreach cfgnode nd in pr.flowgraph &#123;</span><br><span class="line">            <span class="keyword">if</span> (no predecessors of nd evaluated)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nd is meet) EvalMeet(nd, ptf);</span><br><span class="line">            <span class="keyword">if</span> (nd is assign) EvalAssign(nd, ptf);</span><br><span class="line">            <span class="keyword">if</span> (nd is call) EvalCall(nd, ptf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (changed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Strong-Updates"><a href="#Strong-Updates" class="headerlink" title="Strong Updates"></a>Strong Updates</h3><p>Unless we know that an assignment will definitely occur and that it assigns to a unique location, we must conservatively assume that location potentially retains its old values.</p>
<h3 id="Sparse-Representation"><a href="#Sparse-Representation" class="headerlink" title="Sparse Representation"></a>Sparse Representation</h3><p>Since we analyze heap data as well as global and stack variables, many possible memory locations could be included in the points-to functions. Fortunately, the information stored in the point-to function is very sparse.</p>
<p>Because of the sparse point-to function representation, looking up the values of a pointer requires searching back for the most recent assignment to that location. Beginning at the current node, we search back through the dominating flow graph nodes.</p>
<h3 id="Evaluating-Dereferences"><a href="#Evaluating-Dereferences" class="headerlink" title="Evaluating Dereferences"></a>Evaluating Dereferences</h3><p>Because location sets may overlap, more than one location set may refer to the same location. Value assigned to one location set must be observed by references to overlapping locations. Thus, when a pointer is dereferenced, we iterate through all of the overlapping locations and look up in the current points-to function the values that have been assigned to each one. However, if the location being referenced is a unique location, values assigned to overlapping locations may have been overwritten by a strong update.</p>
<h3 id="Evaluating-Assignments"><a href="#Evaluating-Assignments" class="headerlink" title="Evaluating Assignments"></a>Evaluating Assignments</h3><p>An assignment node in a flow graph specifies both the source and destination expressions, as well as the size of the value to be assigned. When building the flow graph from the intermediate representation of a program, we automatically convert the assignments to a “points-to” form. That is, since a variable reference on the right-hand side if an assignment refers to the contents of that variable, we add extra dereference to each expression on the right-hand side.</p>
<p>The process of evaluating an assignment begins by finding the locations identified by the source and destination expressions.</p>
<h2 id="Interprocedural-Algorithm"><a href="#Interprocedural-Algorithm" class="headerlink" title="Interprocedural Algorithm"></a>Interprocedural Algorithm</h2><p>To evaluate the effects of a call on the points-to function, we need to find a PTF that applies in the calling context.</p>
<h3 id="Calls-Through-Pointers"><a href="#Calls-Through-Pointers" class="headerlink" title="Calls Through Pointers"></a>Calls Through Pointers</h3><p>The first step in evaluating procedure calls is to determine the target procedures. Function pointer values may be expressed in terms of extended parameters. This is one situation where we need to know the specific values represented by extended parameters.</p>
<h3 id="Testing-if-a-PTF-Applies"><a href="#Testing-if-a-PTF-Applies" class="headerlink" title="Testing if a PTF Applies"></a>Testing if a PTF Applies</h3><p>The input domain of a PTF is specified by its initial points-to function and by the value of the parameters used as call targets. To test if a PTF applies, we check if these things are the same in the current context as they were when the PTF was created.</p>
<h3 id="Applying-a-PTF"><a href="#Applying-a-PTF" class="headerlink" title="Applying a PTF"></a>Applying a PTF</h3><h3 id="Recursive-Calls"><a href="#Recursive-Calls" class="headerlink" title="Recursive Calls"></a>Recursive Calls</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/05/Intel-Processor-Trace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/06/05/Intel-Processor-Trace/" class="post-title-link" itemprop="url">Intel Processor Trace</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-06-05 14:34:00" itemprop="dateCreated datePublished" datetime="2019-06-05T14:34:00+08:00">2019-06-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Intel PT 是一个处理器架构扩展, 它利用硬件来记录程序执行的 trace, 并且产生很小的开销. 控制流的信息通过数据包收集, 然后使用软件解码器解码. 这些数据包内容包括: 时间, 程序流信息 (e.g., 分支目标, 分支是否执行), program-induced mode related information (e.g., Intel TSX 状态转换, CR3 改变). Intel PT 后期的版本增加了 trace sources, 包括使用 <code>PTWRITE</code> 的 software trace instrumentation, 和 Power Event tracing.</p>
<h3 id="Features-and-Capabilities"><a href="#Features-and-Capabilities" class="headerlink" title="Features and Capabilities"></a>Features and Capabilities</h3><p>使用 PT 生成的数据包和程序的二进制文件, 可以重构出程序的执行 trace. 这些数据包记录的信息有: instruction pointers (IP), indirect branch targets, directions of conditional branches within contiguous code regions (basic blocks).</p>
<p>PT 可以使用 <code>PTWRITE</code> 来记录软件生成的数据包, 和一些处理器功耗的事件. 并且, Precise Event-based Sampling (PEBS) 也能通过配置, 在 PT 中记录.</p>
<p>PT 有几种控制和筛选机制, 完成自定义的 trace 信息收集. 比如可以通过 current privilege level 和 CR3 值进行筛选. 这些筛选可以通过设置 MSR 来进行.</p>
<h3 id="Packet-Summary"><a href="#Packet-Summary" class="headerlink" title="Packet Summary"></a>Packet Summary</h3><p>程序执行基本信息的数据包如下:</p>
<ul>
<li><p>Packet Stream Boundary (PSB) packets: 心跳包, 每隔一定周期 (e.g., every 4K trace packet bytes) 自动生成. 可以作为数据包的边界来供 decoder 识别, decoder 解析的第一个包一定要是这个包.</p>
</li>
<li><p>Paging Information Packet (PIP): 记录 CR3 寄存器的修改情况. 通过结合操作系统中每个进程 CR3 的值, debugger 能够将线性地址和对应的进程 (源代码) 结合起来.</p>
</li>
<li><p>Time-Stamp Counter (TSC) packets: 记录时间.</p>
</li>
<li><p>Core Bus Ratio (CBR) packets: 包含 core:bus 的时钟频率比</p>
</li>
<li><p>Overflow (OVF) packets: 当处理器内部缓冲区溢出时设置, 可能其它的包被丢弃了, 解码器利用这个信息来同步正确的解码.</p>
</li>
</ul>
<p>关于控制流信息的数据包如下:</p>
<ul>
<li><p>Taken Not-Taken (TNT) packets: 记录直接条件分支的方向.</p>
</li>
<li><p>Target IP (TIP) packets: 记录间接分支, 异常, 中断和其他分支或事件的目的 IP. 里面存储的 IP 都是被压缩的, 并且存在不同类型的 TIP 包.</p>
</li>
<li><p>Flow Update Packets (FUP): 异步事件 (中断或者异常) 的源 IP. 还有其它不能从二进制文件中获取的源 IP 也通过这个包得到.</p>
</li>
<li><p>MODE packets: 提供解码器重要的处理器执行信息, 使得解码器能够解释反汇编的二进制程序和 trace log.</p>
</li>
</ul>
<p>软件生成的数据包:</p>
<ul>
<li><code>PTWRITE</code> (PTW) packets: 包括传给 <code>PTWRITE</code> 指令的操作数的值.</li>
</ul>
<h2 id="Intel-Processor-Trace-Operational-Model"><a href="#Intel-Processor-Trace-Operational-Model" class="headerlink" title="Intel Processor Trace Operational Model"></a>Intel Processor Trace Operational Model</h2><h3 id="Change-of-Flow-Instruction-COFI-Tracing"><a href="#Change-of-Flow-Instruction-COFI-Tracing" class="headerlink" title="Change of Flow Instruction (COFI) Tracing"></a>Change of Flow Instruction (COFI) Tracing</h3><p>Basic block 之间的控制流转移指令叫做 COFI, 分为三种: 1. Direct transfer COFI, 2. Indirect transfer COFI, 3. Far transfer COFI.</p>
<p>同时, 按照不同的类型:</p>
<table>
<thead>
<tr>
<th>COFI Type</th>
<th>Instructions</th>
</tr>
</thead>
<tbody><tr>
<td>Conditional Branch</td>
<td>Jcc  , J*CXZ, LOOP</td>
</tr>
<tr>
<td>Unconditional Direct Branch</td>
<td>JMP (E9 xx, EB xx), CALL (E8 xx)</td>
</tr>
<tr>
<td>Indirect Branch</td>
<td>JMP (FF /4)， CALL (FF /2)</td>
</tr>
<tr>
<td>Near Ret</td>
<td>RET (C3, C2 xx)</td>
</tr>
<tr>
<td>Far Transfers</td>
<td>INT1, INT3, INT n, INTO, IRE(T/TD/Q), JMP (EA xx, FF/5), CALL (9A xx, FF/3), RET (CB, CA xx), SYSCALL, SYSRET, SYSENTER, SYSEXIT, VMLANUCH, VMRESUME</td>
</tr>
</tbody></table>
<h4 id="Direct-Transfer-COFI"><a href="#Direct-Transfer-COFI" class="headerlink" title="Direct Transfer COFI"></a>Direct Transfer COFI</h4><p>Direct Transfer COFI 是相对分支. 意味着他们的目标地址是当前的 IP 加上一个 offset. 因为二进制反汇编就可以得到直接跳转的 IP, 所以没有必要在 trace 中记录 IP. 对于条件分支, 只需要标记该分支是 taken or not 就行. 无条件分支都不需要任何记录.</p>
<ul>
<li><p>Conditional Branch (Jcc, J*CXZ) and Loop: 编码一个 bit 的 TNT 就可以指示程序的控制流. 同时, 处理器会将多个 TNT bit 压缩成一个数据包.</p>
</li>
<li><p>Unconditional Direct Jumps: 不会生成 trace.</p>
</li>
</ul>
<h4 id="Indirect-Transfer-COFI"><a href="#Indirect-Transfer-COFI" class="headerlink" title="Indirect Transfer COFI"></a>Indirect Transfer COFI</h4><p>Indirect Transfer 指令会从寄存器或者内存地址中更新 IP, 所以 PT 就必须记录目的 IP， 使得 debugger 能够确定 COFI 的目的地址. 这个 IP 可能为 linear addres, 或 effective address.</p>
<p>Indirect Transfer 指令会生成一个包含目的地址的 Target IP Packet(TIP).</p>
<ul>
<li><p>Near JMP Indirect and Near Call Indirect: 生成 TIP.</p>
</li>
<li><p>Near RET: 当 <code>CALL</code> 指令执行时, 它会将 <code>CALL</code> 后面那条指令的地址压栈. 在调用返回后, <code>RET</code> 指令会出栈这个返回i地址, 并 <code>JMP</code> 过去. 因为这个调用本身可能修改这个返回地址, 所以实际的返回地址在反汇编中仍不确定, 所以对于 <code>RET</code> 还是会生成一个 TIP 包.</p>
<ul>
<li>RET Compression: 如果能保证 RET 的返回地址和压栈的返回地址完全一致, 可以仅生成一个 TNT 包表示走了这个分支. 不过这个得需要 decoder 作额外的处理.</li>
</ul>
</li>
</ul>
<h4 id="Far-Transfer-COFI"><a href="#Far-Transfer-COFI" class="headerlink" title="Far Transfer COFI"></a>Far Transfer COFI</h4><p>所有改变 instruction pointer 的非 near jumps 指令都是 “far transfer”. 包括: 异常, 中断, trap, TSX abort, 和进行 far transfer 的指令.</p>
<p>所有的这些指令都会产生一个 TIP 数据包. 有一些 far transfer 在二进制代码中无法推断, 比如异步事件异常和中断, 这种会先产生 FUP 数据包提供事件源 IP, 再产生一个 TIP.</p>
<h3 id="Software-Trace-Instrumentation-with-PTWRITE"><a href="#Software-Trace-Instrumentation-with-PTWRITE" class="headerlink" title="Software Trace Instrumentation with PTWRITE"></a>Software Trace Instrumentation with <code>PTWRITE</code></h3><p><code>PTWRITE</code> 使得软件可以直接利用 PT trace. 每次将 64 bit 数据写入到 PT 产生的 PTW 数据包中. 解码器和分析软件能根据 <code>PTWRITE</code> 指令的 IP, 和数据内容确定这个数据的意义. <code>PTWRITE</code> 通过 IA32_RTIT_CTL.PTWEn[12]开启, 并且用户可以使用 IA32_RTIT_CTL.FUPonPTW[5] 在 PTW 包后面添加 FPU 包, 获取 <code>PTWRITE</code> 指令的 IP.</p>
<h3 id="Power-Event-Tracing"><a href="#Power-Event-Tracing" class="headerlink" title="Power Event Tracing"></a><del>Power Event Tracing</del></h3><h3 id="Trace-Filtering"><a href="#Trace-Filtering" class="headerlink" title="Trace Filtering"></a>Trace Filtering</h3><h4 id="Filtering-by-Current-Privilege-Level-CPL"><a href="#Filtering-by-Current-Privilege-Level-CPL" class="headerlink" title="Filtering by Current Privilege Level (CPL)"></a>Filtering by Current Privilege Level (CPL)</h4><p>Intel PT 设置 trace 条件为 CPL = 0, 或者 CPL &gt; 0, 使得 logical processor 生成对应 CPL 的数据包. CPL 筛选保证了只有满足条件的 IP 或者其它的架构信息能够被 trace, 比如说 trace 条件是 CPL &gt; 0, 当软件执行 SYSCALL (CPL = 0)时, SYSCALL 的目的 IP 就不会出现在生成的数据包中.</p>
<p>在 real-address mode 和 virtual-8086 mode 时, CPL 分别为 0, 3.</p>
<h4 id="Filtering-by-CR3"><a href="#Filtering-by-CR3" class="headerlink" title="Filtering by CR3"></a>Filtering by CR3</h4><p>Intel PT 支持配置 CR3 筛选器, 能根据当前 CR3 的值生成 trace. 如果是多线程的程序, 可以通过切换 RTIT MSRs 的状态来分隔不同线程的输出.</p>
<p>设置 IA32_RTIT_CR3_MATCH MSR寄存器的值为目标 CR3 值, 然后设置 IA32_RTIT_CTL.CR3Filter, 就可以 trace 某个 CR3. 如果处理器被设置为 CPL = 0 时也能记录, 那么生成的 trace 中含有 PIP 数据包.</p>
<h4 id="Filtering-by-IP"><a href="#Filtering-by-IP" class="headerlink" title="Filtering by IP"></a>Filtering by IP</h4><p>如果 CPUID.(EAX=14H, ECX=0):EBX[bit 2] = 1 时, Intel PT 能够仅在程序执行的 IP 在某个确定的范围内时, 生成 trace 数据包. 对 IA32_RTIT_CTL MSR 寄存器中的 ADDR<code>n</code>_CFG 域进行设置, 可以启用 IP filtering. 这个 <code>n</code> 是从零开始的数字, 用来选择配置的是哪个地址范围. 每个 ADDR<code>n</code>_CFG 都确定一组寄存器对的值 [base, limit], [IA32_RTIT_ADDR<code>n</code>_A, IA32_RTIT_ADDR<code>n</code>_B]. 选定的地址范围个数可以通过 CPUID 查看.</p>
<p>这个 base 和 limit 是 inclusive 的, 所以他包含边界.</p>
<p><strong>TraceStop:</strong> 可以通过配置 IP 范围, 不对某些地址进行 trace, 若上述范围重叠, 重叠部分不 trace.</p>
<h3 id="Packet-Generation-Enable-Controls"><a href="#Packet-Generation-Enable-Controls" class="headerlink" title="Packet Generation Enable Controls"></a>Packet Generation Enable Controls</h3><p>Intel PT 包含多种控制机制来确定是否生成数据包. 一般来讲, 只要 Packet Enable (PacketEn) 被设置, 大多数数据包都会生成. PacketEn 是硬件的内部状态, 软件只能通过对 MSR 寄存器进行修改来对他进行配置.</p>
<h4 id="Packet-Enable-PacketEn"><a href="#Packet-Enable-PacketEn" class="headerlink" title="Packet Enable (PacketEn)"></a>Packet Enable (PacketEn)</h4><p>当 PacketEn 被设置时, 处理器就能使用 PT 生成 trace. PacketEn 是几种状态的组合: <code>PacketEn &lt;- TriggerEn AND ContextEn AND FilterEn AND BranchEn</code>. PacketEn 是处理器是否生成 trace 数据包的最根本的因素. 当它 enable 时, 所有的控制流数据包都会被 enable, 当它被 clear 时, 只有一些其它的数据包 (timing and bookkeeping packets) 生成. 不支持 IP Filtering 的处理器中 (i.e., CPUID.(EAX=14H, ECX=0):EBX.IPFILT_WRSTPRSV[bit 2] = 0), FilterEn 总是被 set.</p>
<h4 id="Trigger-Enable-TriggerEn"><a href="#Trigger-Enable-TriggerEn" class="headerlink" title="Trigger Enable (TriggerEn)"></a>Trigger Enable (TriggerEn)</h4><p>Trigger Enable (TriggerEn) 是最主要的生成数据包的指示器. 使用 IA32_RTIT_CTL.TraceEn 来对它 set. 通过以下任意一个条件来 clear 它: (i) 使用软件 clear IA32_RTIT_CTL.TraceEn, (ii) 满足 TraceStop 条件, 并且 IA32_RTIT_STATUES.Stopped 被 set, (iii) IA32_RTIT_STATUS.ERROR 被 set. 软件可以通过查询 IA32_RTIT_STATUS.TriggerEn 来获取当前 TriggerEn 的值.</p>
<h4 id="Context-Enable-ContextEn"><a href="#Context-Enable-ContextEn" class="headerlink" title="Context Enable (ContextEn)"></a>Context Enable (ContextEn)</h4><p>Context Enable (ContextEn) 指示了处理器的 state 和 mode 是否满足软件之前的设置. 例如, 如果在 CPL = 0 状态下的代码执行没有被 trace (IA32_RTIT_CTL.OS = 0), 那么表明 CPL = 0 时, ContextEn 为 0. 软件可以通过查询 IA32_RTIT_STATUS.ContextEn 获取当前 ContextEn 的值.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContextEn <span class="operator">=</span> <span class="operator">!</span>((IA32_RTIT_CTL.OS <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> CPL <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">OR</span> (IA32_RTIT_CTL.USER <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> CPL <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">OR</span> (IS_IN_A_PRODUCTION_ENCLAVE)</span><br><span class="line">              <span class="keyword">OR</span> (IA32_RTIT_CTL.CR3Filter <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> IA32_RTIT_CR3_MATCH does <span class="keyword">not</span> <span class="keyword">match</span> cr3))</span><br></pre></td></tr></table></figure>

<p>如果 clear ContextEn 导致 PacketEn 被 clear, 就会生成一个 Packet Generation Disable (TIP.PGD) 数据包, 但是里面并没有 IP. 如果 set ContextEn 导致 PacketEn set, 那么 Packet Generation Enable (TIP.PGE) 就会生成.</p>
<p>当 ContextEn 被 clear, 控制流相关数据包 (TNT, FUP, TIP.*, MODE.*) 都不会生成, 并且不会暴露出 IP. 其它的包可能会生成.</p>
<p>只有当 TriggerEn = 1 时, ContextEn 的值才会变化, TriggerEn = 0 时, ContextEn 不会改变.</p>
<h4 id="Branch-Enable-BranchEn"><a href="#Branch-Enable-BranchEn" class="headerlink" title="Branch Enable (BranchEn)"></a>Branch Enable (BranchEn)</h4><p>BranchEn 基于 IA32_RTIT_CTL.BranchEn 的值, 如果 BranchEn 没有被 set, 那么相关的 COFI 数据包 (TNT, TIP.*, FUP, MODE.*) 不会生成.</p>
<h4 id="Filter-Enable-FilterEn"><a href="#Filter-Enable-FilterEn" class="headerlink" title="Filter Enable (FilterEn)"></a>Filter Enable (FilterEn)</h4><p>FilterEn 表示 IP 位于之前配置好的 IP 范围中. 软件可以查询 IA32_RTIT_STATUS.FilterEn 获取 FilterEn 的状态.</p>
<p>当 clear FilterEn 之后, 一个 Packet Generation Disable (PGD) 数据包会生成, 但和 ContextEn 不同的是, 目标 IP 数据还是在里面的. 所以可能会有范围之外的 IP 出现在 trace log 中. 当 FilterEn clear, 控制流的数据包就不会生成.</p>
<p>若处理器没有配置 trace range of IP, 或者处理器不支持 IP filtering, 那么 FilterEn 总是被 set. FilterEn 仅仅只会在 TraceEn 和 ContextEn 均为 1 的情况下， 同时在配置好 trace range 之后被开启关闭.</p>
<h3 id="Trace-Output"><a href="#Trace-Output" class="headerlink" title="Trace Output"></a>Trace Output</h3><p>Intel PT 的输出和 trace 内容, 筛选机制独立. 不同的处理器和平台, 支持不同的输出选项. 使用 IA32_RTIT_CTL 中 ToPA 和 FabricEn 域配置输出策略为以下的一种:</p>
<ul>
<li><p>单个, 连续的物理内存地址空间.</p>
</li>
<li><p>多个不同大小的物理内存区域的集合. 这些区域通过一个表来连接和索引, 即 Table of Physical Addresses (ToPA). Trace 的输出绕过 cache 和 TLB 直接写入物理内存, 这个输出策略对性能影响最小, 但输出不一定是序列化的.</p>
</li>
<li><p>平台特定的 trace 传输子系统.</p>
</li>
</ul>
<p>不管选择哪个输出策略, 输出都会绕过 cache. 这保证了 trace 不会消耗宝贵的 cache 空间, 但是和一般的 uncacheable 内存区域的写入不同, trace 输出的写入并不是序列化的. <strong>不要对输出的物理地址区域使用 MTRR 或者 PTE 配置 UnCacheable.</strong></p>
<p>我们并不能控制 trace 在何时输出到物理内存中. 唯一能保证的就是, 将 TraceEn clear, 停止 trace, 并执行 store, fence 或者序列化指令, 从而将处理器内存缓冲区的所有 trace 数据包 flush 到物理内存中.</p>
<h4 id="Single-Range-Out"><a href="#Single-Range-Out" class="headerlink" title="Single Range Out"></a>Single Range Out</h4><p>当 IA32_RTIT_CTL.ToPA 和 IA32_RTIT_CTL.FabricEn 的 bit 是 clear 状态时, trace 数据包会发送到一块连续的物理内存空间 (or MMIO) 中. 这个物理内存空间通过 IA32_RTIT_OUTPUT_BASE 和 IA32_RTIT_OUTPUT_MASK_PTRS 中的 mask 值来确定. 当前的写入指针也存储在 IA32_RTIT_OUTPUT_MASK_PTRS 中, 这个范围是环形的, 在到达缓冲区末尾之后会重新将写入指针移动到缓冲区的 base.</p>
<p>这个方法最好是用在以下场景:</p>
<ul>
<li><p>DRAM 中有足够大的连续空间时</p>
</li>
<li><p>输出到 MMIO 调试端口.</p>
</li>
</ul>
<h4 id="Table-of-Physical-Addresses"><a href="#Table-of-Physical-Addresses" class="headerlink" title="Table of Physical Addresses"></a>Table of Physical Addresses</h4><p>当 IA32_RTIT_CTL.ToPA 是 set, IA32_RTIT_CTL.FabricEn 是 clear 时, 就使用 ToPA 机制. ToPA 使用的是一个环形链表, 每个节点都是一个 table. Table 中的每个 entry 都包含一个物理内存区域 (output region) 的 base 指针和大小, 如果是最后一个 entry， 那就可能存放下一个 table 的物理内存地址.</p>
<p>处理器将这些物理内存区域看作一个统一的 buffer, 所以一个数据包可能横跨两个 output region.</p>
<p>ToPA 机制可以用以下三个值来控制:</p>
<ul>
<li><p>proc_trace_table_base: 这是当前 table 的物理地址. 从 IA32_RTIT_OUTPUT_BASE MSR 寄存器中获取.</p>
</li>
<li><p>proc_trace_table_offset: 当前 table 正在被使用的 entry. 从 IA32_RTIT_OUTPUT_MASK_PTRS 中的 31:7 位获取.</p>
</li>
<li><p>proc_trace_output_offset: 当前 output region 中的指针. 从 IA32_RTIT_OUTPUT_MASK_PTRS 中的 63:32 位获取.</p>
</li>
</ul>
<p>当 trace packet 按照规则写入物理内存时, 若碰到有 entry 标记为 END, 就需要更新 table_base 来切换到下个 table. 若为 STOP,在充满当前 output region 之后停止 trace. 如果一直没有 END 标记或者 STOP 标记, 那么在到达最大 table 大小 (proc_trace_table_offset = 0x0ffffff8h) 之后, 会将 table_offset 和 output_offset 置 0, 循环输出.</p>
<p>很重要的一点是, 处理器对 IA32_RTIT_OUTPUT_BASE 和 IA32_RTIT_OUTPUT_MASK_PTRS MSR 寄存器的更新和指令执行是异步的, 所以直接读取 MSR 得到的值可能是旧的值. 要得到正确的值必须先停止 trace 数据包生成 (clear IA32_RTIT_CTL.TraceEn), 再读取.</p>
<p>同时, 处理器可能会内部 cache 一些 table 的 entry. 如果要修改这些 entry, 也得先停止 trace 再更改.</p>
<p>第一代实现 PT 的处理器只能将 ToPA 配置为 single output region 的模式.</p>
<p>以下是几个 entry 标记的用途:</p>
<ul>
<li><p>ToPA STOP: 当前 output region 满了之后, set IA32_RTIT_STATUS.Stopped 位, 停止 trace. 这类停止没有 TIP.PGD 数据包发出, 并且意味着 CPU 内部缓冲区中的数据包就被丢弃了.</p>
</li>
<li><p>ToPA PMI: 当 INT 标记被设置时, 当前 output region 充满之后就会发出一个 performance-monitoring interrupt 中断. 这个中断也是异步的, 不精确. 并且中断处理的过程也能被 trace, 可以通过 filtering 来解决这个污染. 所以， PMI handle 如果想读取 trace 数据包, 一定要先 clear TraceEn, 停止 trace.</p>
</li>
</ul>
<p>管理 Intel PT ToPA PMI 和 XSAVES/XSTORES 的算法:</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> (IA32_PERF_GLOBAL_STATUS.ToPA)</span><br><span class="line">    Save IA32_RTIT_CTL Value;</span><br><span class="line">    <span class="keyword">IF</span> (IA32_RTIT_CTL.TraceEn)</span><br><span class="line">        Disable Intel PT by clearing TraceEn;</span><br><span class="line">    FI;</span><br><span class="line">    <span class="keyword">IF</span> (There <span class="keyword">is</span> space available <span class="keyword">to</span> grow the current ToPA table)</span><br><span class="line">        Add one more ToPA entries after the last entry <span class="keyword">in</span> the ToPA table;</span><br><span class="line">        Point new ToPA entry address fields <span class="keyword">to</span> new output region base;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        Modify an upcoming ToPA entry <span class="keyword">in</span> the current table <span class="keyword">to</span> have <span class="keyword">END</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">IF</span> (<span class="keyword">out</span> put should translation <span class="keyword">to</span> a new ToPA table)</span><br><span class="line">            Point the address <span class="keyword">of</span> the &quot;<span class="keyword">END</span> = <span class="number">1</span>&quot; entry <span class="keyword">of</span> the current table <span class="keyword">to</span> the new table address base;</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">            /* make a circular*/</span><br><span class="line">            Point the address <span class="keyword">of</span> the &quot;<span class="keyword">END</span> = <span class="number">1</span>&quot; entry <span class="keyword">to</span> the base <span class="keyword">of</span> the current table;</span><br><span class="line">            Modify the ToPA entry address fields <span class="keyword">for</span> filled output regions <span class="keyword">to</span> point <span class="keyword">to</span> new, unused output regions;</span><br><span class="line">        FI;</span><br><span class="line">    FI;</span><br><span class="line">    Restore saved IA32_RTIT_CTL.value;</span><br><span class="line">FI;</span><br></pre></td></tr></table></figure>

<h4 id="Trace-Transport-Subsystem"><a href="#Trace-Transport-Subsystem" class="headerlink" title="Trace Transport Subsystem"></a><del>Trace Transport Subsystem</del></h4><h4 id="Restricted-Memory-Access"><a href="#Restricted-Memory-Access" class="headerlink" title="Restricted Memory Access"></a>Restricted Memory Access</h4><p>Trace 数据包的输出的目的内存区域不能为限制的区域, 比如说所有的输出区域都会受到 SMRR (System-Management Range Register) 的限制, 所有和它重叠的区域都不能作为 output region.</p>
<p>可以先关闭 trace 数据包生成, 再修改 SMRR, 然后再生成数据包.</p>
<h3 id="Enabling-and-Configuration-MSRs"><a href="#Enabling-and-Configuration-MSRs" class="headerlink" title="Enabling and Configuration MSRs"></a>Enabling and Configuration MSRs</h3><h4 id="General-Consideration"><a href="#General-Consideration" class="headerlink" title="General Consideration"></a>General Consideration</h4><p>Trace 数据包的生成可以通过一系列 MSRs 来进行维护:</p>
<ul>
<li><p>处理器不支持 Intel PT 时, 使用 RDMSR 或 WRMSR 操作 IA32_RTIT_* 系列的 MSRs 都会造成 #GP.</p>
</li>
<li><p>在改变 MSRs 之前, 一定要先 clear IA32_RTIT_CTL.TraceEn, 不然也会 #GP.</p>
</li>
<li><p>每个 logical processor 都是一套不同的 MSRs. 意思是每次配置, 都是在一个 logical processor 上配置的.</p>
</li>
<li><p>在 cold REST 之后, 所有的 MSRs 配置都被清除</p>
<ul>
<li>如果 CPUID.(EAX = 14H, ECX = 0):EBX.IPFILT_WRSTPRSV[bit 2] = 1, 那么在 warm REST 之后, 只有 TraceEn bit 被清除, 同时可能影响 IA32_RTIT_STATUS. 但是其它 MSRs 不受影响.</li>
</ul>
</li>
<li><p>除了可以通过 WRMSR 来显式修改外, 还可以使用 VM-exit 或者 VM-entry, XRSTORS, XSAVE 来修改.</p>
</li>
</ul>
<h4 id="IA32-RTIT-CTL-MSR"><a href="#IA32-RTIT-CTL-MSR" class="headerlink" title="IA32_RTIT_CTL MSR"></a>IA32_RTIT_CTL MSR</h4><table>
<thead>
<tr>
<th>Position</th>
<th>Bit Name</th>
<th>At Reset</th>
<th>Bit Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>TraceEn</td>
<td>0</td>
<td>1: tracing, 0: tracing disabled. 从 1 到 0 时, CPU 内部缓冲区会被 flush</td>
</tr>
<tr>
<td>1</td>
<td>CYCEn</td>
<td>0</td>
<td>0: disables CYC Packet, 1: enable CYC Packets</td>
</tr>
<tr>
<td>2</td>
<td>OS</td>
<td>0</td>
<td>0: 当 CPL = 0 时，不生成数据包, 1: CPL = 0 时生成数据包</td>
</tr>
<tr>
<td>3</td>
<td>User</td>
<td>0</td>
<td>0: 当 CPL &gt; 0 时, 不生成数据包, 1: 当 CPL &gt; 0 时, 生成数据包</td>
</tr>
<tr>
<td>4</td>
<td>PwrEvtEn</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>FUPonPTW</td>
<td>0</td>
<td>0: PTW 包后面不跟 FUP 包, 1: 跟</td>
</tr>
<tr>
<td>6</td>
<td>FabricEN</td>
<td>0</td>
<td>0: 使用 ToPA, 1: 不使用</td>
</tr>
<tr>
<td>7</td>
<td>CR3Filter</td>
<td>0</td>
<td>0: 关闭 CR3 filtering, 1: 开启</td>
</tr>
<tr>
<td>8</td>
<td>ToPA</td>
<td>0</td>
<td>0: Single-range output, 1: ToPA output</td>
</tr>
<tr>
<td>9</td>
<td>MTCEn</td>
<td>0</td>
<td>0: disable MTC packets, 1: enable</td>
</tr>
<tr>
<td>10</td>
<td>TSCEn</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>DisRETC</td>
<td>0</td>
<td>0: enable RET compression, 1: disable</td>
</tr>
<tr>
<td>12</td>
<td>PTWEn</td>
<td>0</td>
<td>0: PTWRITE Packet generation disabled, 1: enable</td>
</tr>
<tr>
<td>13</td>
<td>BranchEn</td>
<td>0</td>
<td>0: disable COFI-based packets, 1:enable</td>
</tr>
<tr>
<td>17:14</td>
<td>MTCFreq</td>
<td>0</td>
<td>定义 MTC 数据包的频率, 可以基于 Always Running Timer (ART).</td>
</tr>
<tr>
<td>22:19</td>
<td>CycThresh</td>
<td>0</td>
<td>CYC packet threshold.</td>
</tr>
<tr>
<td>27:24</td>
<td>PSBFreq</td>
<td>0</td>
<td>控制 PSB 的生成频率, 但是不精确</td>
</tr>
<tr>
<td>35:32</td>
<td>ADDR0_CFG</td>
<td>0</td>
<td>0: 不使用 ADDR0, 1: 相关的 MSRs 定义了 IP Filter 的上下界, 2: 相关的 MSRs 定义了 TraceStop 上下界</td>
</tr>
<tr>
<td>39:36</td>
<td>ADDR1_CFG</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>43:40</td>
<td>ADDR2_CFG</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>47:44</td>
<td>ADDR3_CFG</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>56</td>
<td>InjectPsbPmiOnEnable</td>
<td>0</td>
<td>1: Enable IA32RTIT_STATUS 的 PendPSB, PendTopaPMI, 0: disable</td>
</tr>
</tbody></table>
<h4 id="Enabling-and-Disabling-Packet-Generation-wth-TraceEn"><a href="#Enabling-and-Disabling-Packet-Generation-wth-TraceEn" class="headerlink" title="Enabling and Disabling Packet Generation wth TraceEn"></a>Enabling and Disabling Packet Generation wth TraceEn</h4><p>当 TraceEn 从 0 到 1 时, Intel PT 就开始工作, 一系列的数据包开始生成. 这些包能帮助 decoder 获取处理器的状态. 如果 IA32_RTIT_STATUS.PacketByteCnt = 0, 那么就会生成 full PSB+， 如果不为 0, 那么会生成和 timing 相关的数据包, TSC, TMA, CRR 等.</p>
<p>除了上述包, 还可能会有 TIP.PGE 数据包生成. 当处理器生成 trace 时, CPU 会将 ToPA 相应的数据结构放入 cache 提高性能, 所以要修改 ToPA tables 的话, 必须先停止 TraceEn, 再修改.</p>
<h4 id="IA32-RTIT-STATUS-MSR"><a href="#IA32-RTIT-STATUS-MSR" class="headerlink" title="IA32_RTIT_STATUS MSR"></a>IA32_RTIT_STATUS MSR</h4><p>IA32_RTIT_STATUS MSR 是可以使用软件来读写的, 但是有一些位 ContextEn, TriggerEn, 不能直接被修改.</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Bit Name</th>
<th>At Reset</th>
<th>Bit Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>FilterEn</td>
<td>0</td>
<td>表示当前 IP 是能被 trace 的</td>
</tr>
<tr>
<td>1</td>
<td>ContextEn</td>
<td>0</td>
<td>当前上下文是能被 trace 的</td>
</tr>
<tr>
<td>2</td>
<td>TriggerEn</td>
<td>0</td>
<td>表示 trace 开启</td>
</tr>
<tr>
<td>4</td>
<td>Error</td>
<td>0</td>
<td>表示操作出错, 当它被 set 时, TriggerEn 被 clear, trace 终止</td>
</tr>
<tr>
<td>5</td>
<td>Stopped</td>
<td>0</td>
<td>表示 ToPA STOP 标志</td>
</tr>
<tr>
<td>6</td>
<td>PendPSB</td>
<td>0</td>
<td>set 时会插入一个 PSB+ 到 trace 中, 插入后 clear</td>
</tr>
<tr>
<td>7</td>
<td>PendTopaPMI</td>
<td>0</td>
<td>set 时表示要触发 PMI, 触发完毕就 clear</td>
</tr>
<tr>
<td>48:32</td>
<td>PacketByteCnt</td>
<td>0</td>
<td>表示已经发出数据包的 bytes, 可以用它来触发下一个 PSB 包的发送, 在 trace 过程中, 处理器会一直修改这个值.</td>
</tr>
</tbody></table>
<h4 id="IA32-RTIT-ADDRn-A-and-IA32-RTIT-ADDRn-B-MSRs"><a href="#IA32-RTIT-ADDRn-A-and-IA32-RTIT-ADDRn-B-MSRs" class="headerlink" title="IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs"></a>IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs</h4><p>这些 MSRs 可以通过 IA32_RTIT_CTL 中的 ADDRn_CFG 域来启用.</p>
<h4 id="IA32-RTIT-CR3-MATCH-MSR"><a href="#IA32-RTIT-CR3-MATCH-MSR" class="headerlink" title="IA32_RTIT_CR3_MATCH MSR"></a>IA32_RTIT_CR3_MATCH MSR</h4><p>当 IA32_RTIT_CTL.CR3Filter = 1 时, 会把它与当前 CR3 作比较. 63:5 这几位保存了 CR3 的值.</p>
<h4 id="IA32-RTIT-OUTPUT-BASE-MSR"><a href="#IA32-RTIT-OUTPUT-BASE-MSR" class="headerlink" title="IA32_RTIT_OUTPUT_BASE MSR"></a>IA32_RTIT_OUTPUT_BASE MSR</h4><p>这个是用来配置 trace 输出的目的物理地址, 它的大小受到最大物理地址宽度的限制 (MAXPHYADDR), 从 CPUID.80000008H:EAX[7:0]获取.</p>
<p>当使用 ToPA 输出模式时, 处理器可能会更新这个 MSR 的值, 但是指令的执行和处理器的更新是异步的, 所以这个 MSR 里面的值在 trace 期间是 unreliable 的.</p>
<h4 id="IA32-RTIT-OUTPUT-MASK-PTRS-MSR"><a href="#IA32-RTIT-OUTPUT-MASK-PTRS-MSR" class="headerlink" title="IA32_RTIT_OUTPUT_MASK_PTRS MSR"></a>IA32_RTIT_OUTPUT_MASK_PTRS MSR</h4><p>这个 MSR 存储的是 trace 下一个 byte 输出的位置. 和上面一样, 异步更新, unreliable.</p>
<table>
<thead>
<tr>
<th>Position</th>
<th>Bit Name</th>
<th>At Rest</th>
<th>Bit Description</th>
</tr>
</thead>
<tbody><tr>
<td>6:0</td>
<td>LowerMask</td>
<td>7FH</td>
<td>强制为 1</td>
</tr>
<tr>
<td>31：7</td>
<td>MaskOrTableOffset</td>
<td>0</td>
<td>这个值的意义取决于 IA32_RTIT_CTL.ToPA 的值. 若 ToPA = 0, 表示这就是 single, contiguous physical output region 的 <strong>mask value</strong>. 所以, 这个区域的大小一定是在 128B 到 4GB. 若 ToPA = 1, 表示的是当前 <strong>ToPA table 中 offset pointer</strong> 的 27:3 bits, 加上上面的 IA32_RTIT_OUTPUT_BASE 可以获取当前 entry 的指针. 每个 table 大小最大为 256 MB.</td>
</tr>
<tr>
<td>63:32</td>
<td>Output offset</td>
<td>0</td>
<td>这个值的意义取决于 IA32_RTIT_CTL.ToPA 的值. 若 ToPA = 0, 表示这个是 single, contiguous physical output region 的 <strong>offset pointer</strong>. 加上 IA32_RTIT_OUTPUT_BASE 的值就可以得到下个 byte 要写入的地址. 这个值一定要小于等于 MaskOrTableOffset. 若 ToPA = 1, 这个是当前 <strong>ToPA output region 的 offset pointer</strong>. 加上 output region 的 base 之后, 可以获得下个 byte 写入的地址</td>
</tr>
</tbody></table>
<h3 id="Interaction-of-Intel-Processor-Trace-and-Other-Processor-Features"><a href="#Interaction-of-Intel-Processor-Trace-and-Other-Processor-Features" class="headerlink" title="Interaction of Intel Processor Trace and Other Processor Features"></a>Interaction of Intel Processor Trace and Other Processor Features</h3><p>TODO</p>
<h2 id="CONFIGURATION-AND-PROGRAMMING-GUIDELINE"><a href="#CONFIGURATION-AND-PROGRAMMING-GUIDELINE" class="headerlink" title="CONFIGURATION AND PROGRAMMING GUIDELINE"></a>CONFIGURATION AND PROGRAMMING GUIDELINE</h2><h3 id="Detection-of-Intel-Processor-Trace-and-Capability-Enumeration"><a href="#Detection-of-Intel-Processor-Trace-and-Capability-Enumeration" class="headerlink" title="Detection of Intel Processor Trace and Capability Enumeration"></a>Detection of Intel Processor Trace and Capability Enumeration</h3><p>见代码</p>
<h4 id="Packet-Decoding-of-RIP-versus-LIP"><a href="#Packet-Decoding-of-RIP-versus-LIP" class="headerlink" title="Packet Decoding of RIP versus LIP"></a>Packet Decoding of RIP versus LIP</h4><p>FUP, TIP, TIP.PEG 和 TIP.PGD 可能会包含 IP payload. 在有些处理器中, 这个 payload 是 effective address (RIP), 其它就是 linear address (LIP). 前面的模式下, payload 里面的值是距离 code segment base (CS) 的偏移, 后面的是偏移加上 code segment base. 对于执行过程中 CS base address 为 0 的软件 (64 bit mode), 这两者没有区别.</p>
<p>对于 IP filtering 和 TraceStop 中配置的 IP 类型, 也需要和这个保持一致.</p>
<h4 id="Model-Specific-Capability-Restrictions"><a href="#Model-Specific-Capability-Restrictions" class="headerlink" title="Model Specific Capability Restrictions"></a>Model Specific Capability Restrictions</h4><p>有一些处理器在进行 trace 的过程中, 限制了对 LBRs/BTS/BTM/LERs 等 MSRs 的使用.</p>
<h3 id="Enabling-and-Configuration-of-Trace-Packet-Generation"><a href="#Enabling-and-Configuration-of-Trace-Packet-Generation" class="headerlink" title="Enabling and Configuration of Trace Packet Generation"></a>Enabling and Configuration of Trace Packet Generation</h3><p>首先检测是否支持 Intel PT, 然后再配置一系列 MSRs 进行 Trace.</p>
<p>以下是 Skylake (6th gen), Kaby Lake (7th gen), Coffee Lake (8th gen and 9th gen), Cannon Lake (8th gen i3) 的 PT 相关 MSRs.</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>Dec</th>
<th>Register Name</th>
<th>Scope</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>0x560H</td>
<td>1376</td>
<td>IA32_OUTPUT_BASE</td>
<td>Thread</td>
<td>Trace Output Base Register (R/W)</td>
</tr>
<tr>
<td>0x561H</td>
<td>1377</td>
<td>IA32_OUTPUT_MASK_PTRS</td>
<td>Thread</td>
<td>Trace Output Mask Pointer Register (R/W)</td>
</tr>
<tr>
<td>0x570H</td>
<td>1392</td>
<td>IA32_RTIT_CTL</td>
<td>Thread</td>
<td>Trace Control Register (R/W)</td>
</tr>
<tr>
<td>0x571H</td>
<td>1393</td>
<td>IA32_RTIT_STATUS</td>
<td>Thread</td>
<td>Tracing Status Register (R/W)</td>
</tr>
<tr>
<td>0x572H</td>
<td>1394</td>
<td>IA32_RTIT_CR3_MATCH</td>
<td>Thread</td>
<td>Trace Filter CR3 Match Register (R/W)</td>
</tr>
<tr>
<td>0x580H</td>
<td>1408</td>
<td>IA32_RTIT_ADDR0_A</td>
<td>Thread</td>
<td>Region 0 Start Address (R/W)</td>
</tr>
<tr>
<td>0x581H</td>
<td>1409</td>
<td>IA32_RTIT_ADDR0_B</td>
<td>Thread</td>
<td>Region 0 End Address (R/W)</td>
</tr>
<tr>
<td>0x582H</td>
<td>1410</td>
<td>IA32_RTIT_ADDR1_A</td>
<td>Thread</td>
<td>Region 1 Start Address (R/W)</td>
</tr>
<tr>
<td>0x583H</td>
<td>1411</td>
<td>IA32_RTIT_ADDR1_A</td>
<td>Thread</td>
<td>Region 1 End Address (R/W)</td>
</tr>
</tbody></table>
<h4 id="Enabling-Packet-Generation"><a href="#Enabling-Packet-Generation" class="headerlink" title="Enabling Packet Generation"></a>Enabling Packet Generation</h4><p>set IA32_RTIT_CTL 中的 TraceEn.</p>
<h4 id="Disabling-Packet-Generation"><a href="#Disabling-Packet-Generation" class="headerlink" title="Disabling Packet Generation"></a>Disabling Packet Generation</h4><p>clear IA32_RTIT_CTL 中的 TraceEn, 然后再看看 IA32_RTIT_STATUS MSR 中的 Error bit 和 Stopped bit, 判断停止 trace 的原因.</p>
<h3 id="Flushing-Trace-Output"><a href="#Flushing-Trace-Output" class="headerlink" title="Flushing Trace Output"></a>Flushing Trace Output</h3><p>数据包都是在 CPU 内部 buffer 中被异步的写入内存. 所以解码器必须先停止 trace 使得所有的数据包都被 flush out.</p>
<h3 id="Warm-reset"><a href="#Warm-reset" class="headerlink" title="Warm reset"></a>Warm reset</h3><p>在 Warm reset 时, MSR 里面配置的内容不会丢失, 除了 TraceEn, 和 IA32_RTIT_STATUS 中的某些 bit.</p>
<h4 id="Manual-Trace-Configuration-Context-Switch"><a href="#Manual-Trace-Configuration-Context-Switch" class="headerlink" title="Manual Trace Configuration Context Switch"></a>Manual Trace Configuration Context Switch</h4><p>可以通过 RDMSR, WRMSR 来将配置进行 save, 和 restore. 保存 trace 配置上下文的方法如下:</p>
<ol>
<li><p>RDMSR IA32_RTIT_CTL, 将值保存到内存</p>
</li>
<li><p>WRMSR IA32_RTIT_CTL, 将上面保存的值写入 MSR, 但是注意写入之前 clear TraceEn</p>
</li>
<li><p>将其它的 MSR 的配置使用 RDMSR 读取, 将更改后的值保存在内存中</p>
</li>
</ol>
<p>恢复 trace 配置上下文过程:</p>
<ol>
<li><p>将保存在内存的值写入到 MSR, 除了 IA32_RTIT_CTL</p>
</li>
<li><p>将保存在内存中 IA32_RTIT_CTL 的值写入 MSR</p>
</li>
</ol>
<h4 id="Trace-Configuration-Context-Switch-Using-XSAVES-XRSTORS"><a href="#Trace-Configuration-Context-Switch-Using-XSAVES-XRSTORS" class="headerlink" title="Trace Configuration Context Switch Using XSAVES/XRSTORS"></a>Trace Configuration Context Switch Using XSAVES/XRSTORS</h4><p>TODO</p>
<h3 id="Cycle-Accurate-Mode"><a href="#Cycle-Accurate-Mode" class="headerlink" title="Cycle-Accurate Mode"></a>Cycle-Accurate Mode</h3><p>CYC 数据包提供处理器 core clock domain 的底层信息. 只和指令执行的 <em>时间</em> 相关.</p>
<p>TODO</p>
<h3 id="Decoder-Synchronization-PSB"><a href="#Decoder-Synchronization-PSB" class="headerlink" title="Decoder Synchronization (PSB+)"></a>Decoder Synchronization (PSB+)</h3><p>Decoder 使用 PSB 数据包作为 trace log 的同步点. 除了简单的同步之外, decoder 还需要知道一些状态 (state) 信息和潜在的时间信息. Decoder 每次获取的信息一定是在两个 PSB 之间的, 比如 LastIP, call stack, compound packet event.</p>
<p>当 PSB 生成时, 在它之后会有一个 PSBEND 数据包. 在这两个数据包之间的是 decoder 需要了解的处理器状态 (state) 信息. 这些数据包就是 PSB+, 他们表示的是 status, 并不会改变 PSB 的 state, 也和其它指令没什么关系. PSB+ 可以包括当前的 Timestamp.</p>
<h3 id="Internal-Buffer-Overflow"><a href="#Internal-Buffer-Overflow" class="headerlink" title="Internal Buffer Overflow"></a>Internal Buffer Overflow</h3><p>TODO</p>
<h2 id="Trace-Packets-and-Data-Types"><a href="#Trace-Packets-and-Data-Types" class="headerlink" title="Trace Packets and Data Types"></a>Trace Packets and Data Types</h2><h3 id="Packet-Relationships-and-Ordering"><a href="#Packet-Relationships-and-Ordering" class="headerlink" title="Packet Relationships and Ordering"></a>Packet Relationships and Ordering</h3><p>这一节主要讲, 怎么把这些数据包中和反汇编的的代码绑定 (binding) 起来. 有一些数据包 (TIP, FUP) 的 payload 就有关联的 IP, 其它的数据包 (TNT) 需要由 decoder 来查找具体的指令来绑定. Decoder 都需要考虑到这些数据包之间的关系, 然后使用这些关系来确定如何 bind 这些数据包.</p>
<p>有一些叫做 “compound packet event” 的事件, 比如中断, 异常等, 只需要一条指令就能产生多个数据包. 这些 compound event 生成的数据包很多都是以 FUP 开头来表示 source address, 然后以 TIP 或者 TIP.PGD 结尾来表示 destination address. 在这个场景下, 就可以说 FUP is “coupled with” TIP. 有一些其它的包可能处于这两者中间, 比如和时间相关的, 和状态相关的.</p>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Beginning</th>
<th>Middle</th>
<th>End</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Unconditional, uncompressed control-flow transfer</td>
<td>FUP, or none</td>
<td>Any combination of PIP, VMCS, Mode.Exec, or None</td>
<td>TIP or TIP.PGD</td>
<td>FUP only for asynchronous events. Order of middle packets may vary. PIP/VMCS/MODE only if the operation modifies the state tracked by these respective packets</td>
</tr>
<tr>
<td>TSX Update</td>
<td>MODE.TSX, and (FUP or none)</td>
<td>None</td>
<td>TIP, TIP.PGD, or none</td>
<td>FUP TIP/TIP.PGD only for TSX abort case</td>
</tr>
<tr>
<td>Overflow</td>
<td>OVF</td>
<td>PSB, PSBEND, or none</td>
<td>FUP or TIP.PGE</td>
<td>FUP if overflow resolves while ContextEn = 1, else TIP.PGE</td>
</tr>
</tbody></table>
<h4 id="Packet-Blocks"><a href="#Packet-Blocks" class="headerlink" title="Packet Blocks"></a>Packet Blocks</h4><p>Packet blocks 是用来 dump 一些状态值的. 具体看手册.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/22/Kaleidoscope-Extending-the-language-Control-Flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/22/Kaleidoscope-Extending-the-language-Control-Flow/" class="post-title-link" itemprop="url">Kaleidoscope: Extending the Language: Control Flow</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-22 11:12:33" itemprop="dateCreated datePublished" datetime="2019-05-22T11:12:33+08:00">2019-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Chapter-5-Introduction"><a href="#Chapter-5-Introduction" class="headerlink" title="Chapter 5 Introduction"></a>Chapter 5 Introduction</h2><p>这是该教程的第五章, 前四章讲了 Kaleidoscope 的实现, 并且包括对 JIT 的支持. 在这章我们要给它添加简单的条件分支和循环指令.</p>
<h2 id="If-Then-Else"><a href="#If-Then-Else" class="headerlink" title="If/Then/Else"></a>If/Then/Else</h2><p>给 Kaleidoscope 添加 if/then/else 支持非常直接: 将条件分支的处理分别加入 lexer, AST, parser, 和 LLVM IR 代码生成.</p>
<p>首先我们看一下, 要给它加入什么样的扩展功能 (what):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">x</span>) <span class="title">if</span> <span class="title">x</span> &lt; 3 <span class="title">then</span> 1 <span class="title">else</span> <span class="title">fib</span>(<span class="params">x - <span class="number">1</span></span>) + <span class="title">fib</span>(<span class="params">x - <span class="number">2</span></span>);</span></span><br></pre></td></tr></table></figure>

<p>在 Kaleidoscope 中, 只有表达式 (expression), 没有语句(statement). 所以 if/then/else 表达式需要被计算出一个值, 根据条件表达式的值不同, 最终的结果可能为 then 表达式值, 也可能为 else 表达式值.</p>
<p>条件表达式中, 如果值为 0.0, 则表示 false, 其它都为 true</p>
<h3 id="Lexer-Extension-for-If-Then-Else"><a href="#Lexer-Extension-for-If-Then-Else" class="headerlink" title="Lexer Extension for If/Then/Else"></a>Lexer Extension for If/Then/Else</h3><p>我们先添加关键字:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// control flow</span></span><br><span class="line">    tok_if = <span class="number">-6</span>,</span><br><span class="line">    tok_then = <span class="number">-7</span>,</span><br><span class="line">    tok_else = <span class="number">-8</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>gettok()</code> 中进行识别:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;if&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> tok_if;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;then&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> tok_then;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;else&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> tok_else;</span><br></pre></td></tr></table></figure>

<h3 id="AST-Extensions-for-If-Then-Else"><a href="#AST-Extensions-for-If-Then-Else" class="headerlink" title="AST Extensions for If/Then/Else"></a>AST Extensions for If/Then/Else</h3><p>然后再添加新的 AST 节点:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IfExprAST - This class represents for if/then/else expression</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IfExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IfExprAST</span>(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then, std::unique_ptr&lt;ExprAST&gt; Else) : <span class="built_in">Cond</span> (std::<span class="built_in">move</span>(Cond)), <span class="built_in">Then</span> (std::<span class="built_in">move</span>(Then)), <span class="built_in">Else</span> (std::<span class="built_in">move</span>(Else)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">llvm::Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Parser-Extension-for-If-Then-Else"><a href="#Parser-Extension-for-If-Then-Else" class="headerlink" title="Parser Extension for If/Then/Else"></a>Parser Extension for If/Then/Else</h3><p>新的 Parser 函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ifexpr ::= &#x27;if&#x27; expr &#x27;then&#x27; expr &#x27;else&#x27; expr;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseIfExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// eat &#x27;if&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">auto</span> Cond = <span class="built_in">ParseExpression</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Cond) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CurTok != tok_then) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;Excepted then&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eat &#x27;then&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">auto</span> Then = <span class="built_in">ParseExpression</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Then) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CurTok != tok_else) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;Expected else&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eat &#x27;else&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">auto</span> Else = <span class="built_in">ParseExpression</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Else) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;IfExprAST&gt;(std::<span class="built_in">move</span>(Cond), std::<span class="built_in">move</span>(Then), std::<span class="built_in">move</span>(Else));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个 <code>ParseIfExpr()</code> 添加到 <code>ParsePrimary()</code> 中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (CurTok)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line"><span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line"><span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LLVM-IR-for-If-Then-Else"><a href="#LLVM-IR-for-If-Then-Else" class="headerlink" title="LLVM IR for If/Then/Else"></a>LLVM IR for If/Then/Else</h3><p>在有了 AST 和 Parser 之后, 我们就应该实现 <code>codegen()</code> 方法了, 我们要在这部分介绍新的内容.</p>
<p>我们首先来看一段 LLVM IR:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">double</span> <span class="title">@foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">double</span> <span class="title">@bar</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">double</span> <span class="title">@baz</span>(<span class="keyword">double</span> <span class="variable">%x</span>) &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  <span class="variable">%ifcond</span> <span class="operator">=</span> <span class="keyword">fcmp</span> <span class="keyword">one</span> <span class="keyword">double</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0.000000e+00</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%ifcond</span><span class="punctuation">,</span> label <span class="variable">%then</span><span class="punctuation">,</span> label <span class="variable">%else</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">then:</span>       <span class="comment">; preds = %entry</span></span><br><span class="line">  <span class="variable">%calltmp</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="keyword">double</span> <span class="title">@foo</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%ifcont</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">else:</span>       <span class="comment">; preds = %entry</span></span><br><span class="line">  <span class="variable">%calltmp1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="keyword">double</span> <span class="title">@bar</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%ifcont</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">ifcont:</span>     <span class="comment">; preds = %else, %then</span></span><br><span class="line">  <span class="variable">%iftmp</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="keyword">double</span> [ <span class="variable">%calltmp</span><span class="punctuation">,</span> <span class="variable">%then</span> ]<span class="punctuation">,</span> [ <span class="variable">%calltmp1</span><span class="punctuation">,</span> <span class="variable">%else</span> ]</span><br><span class="line">  <span class="keyword">ret</span> <span class="keyword">double</span> <span class="variable">%iftmp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>llvm-as</code> 和 <code>opt</code> 工具, 我们可以画出这段代码 (t.ll) 的 CFG 图, 运行 <code>llvm-as-7 &lt; t.ll| opt-7 -analyze -view-cfg</code> 之后:</p>
<img src="/2019/05/22/Kaleidoscope-Extending-the-language-Control-Flow/5.1.png" class="" title="CFG">

<p>其它生成 CFG 图的方法还有在代码中调用或者在调试器中调用 <code>F-&gt;viewCFG()</code> 或者 <code>F-&gt;viewCFGOnly()</code>, 其中 <code>F</code>, 是一个 <code>Function*</code>.</p>
<p>不管是 LLVM IR, 还是 CFG 图, 我们都可以发现这些信息: entry block 中将 <code>x</code> 的值和 <code>0</code> 进行 <code>one</code> 类型的 <code>fcmp</code> 比较. <code>one</code> 的意思是 Ordered and not equal, Ordered 的<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/8627368/4684264">解释</a>. <code>fcmp</code> 表示是浮点数的比较. <code>br</code> 表示的是根据 <code>%ifcond</code> 的值跳转到 <code>label %then</code> 或者 <code>%label %else</code>.</p>
<p><code>%then</code> 和 <code>%else</code> 两个 basic block 的指令都差不多, 调用其它函数, 然后跳转到 <code>%ifcont</code>. 所以, 在最后一个 basic block 中, 我们需要确定控制流是从哪个 block 来的, 从而确定整个 if/then/else 表达式的值.</p>
<p>所以这就是 <code>phi</code> 指令的作用, 如果控制流是从 <code>%then</code> 过来, 那么它的值为 <code>%calltmp</code>; 如果控制流是从 <code>%else</code> 过来, 那么它的值为 <code>%calltmp1</code>.</p>
<h3 id="Code-Generation-for-If-Then-Else"><a href="#Code-Generation-for-If-Then-Else" class="headerlink" title="Code Generation for If/Then/Else"></a>Code Generation for If/Then/Else</h3><p>为了给 If/Then/Else 生成代码, 我们就要实现 <code>Value *IfExprAST::codegen()</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">IfExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    llvm::Value * CondV = Cond-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!CondV) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert condition to a bool by comparing non-equal to 0.0</span></span><br><span class="line">    CondV = Builder.<span class="built_in">CreateFCmpONE</span>(CondV, llvm::ConstantFP::<span class="built_in">get</span>(TheContext, llvm::<span class="built_in">APFloat</span>(<span class="number">0.0</span>)), <span class="string">&quot;ifcond&quot;</span>);</span><br><span class="line"></span><br><span class="line">    llvm::Function *TheFunction = Builder.<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create blocks for the then and else </span></span><br><span class="line">    <span class="comment">// cases. Insert the &#x27;then&#x27; block at the </span></span><br><span class="line">    <span class="comment">// end of the function</span></span><br><span class="line">    llvm::BasicBlock *ThenBB = llvm::BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;then&quot;</span>, TheFunction);</span><br><span class="line">    llvm::BasicBlock *ElseBB = llvm::BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;else&quot;</span>);</span><br><span class="line">    llvm::BasicBlock *MergeBB = llvm::BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;ifcont&quot;</span>);</span><br><span class="line">    Builder.<span class="built_in">CreateCondBr</span>(CondV, ThenBB, ElseBB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit then Value</span></span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(ThenBB);</span><br><span class="line">    llvm::Value *ThenV = Then-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ThenV) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder.<span class="built_in">CreateBr</span>(MergeBB);</span><br><span class="line">    ThenBB = Builder.<span class="built_in">GetInsertBlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the &#x27;else&#x27; block</span></span><br><span class="line">    TheFunction-&gt;<span class="built_in">getBasicBlockList</span>().<span class="built_in">push_back</span>(ElseBB);</span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(ElseBB);</span><br><span class="line"></span><br><span class="line">    llvm::Value *ElseV = Else-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span>(!ElseV) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder.<span class="built_in">CreateBr</span>(MergeBB);</span><br><span class="line">    ElseBB = Builder.<span class="built_in">GetInsertBlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the &#x27;merge&#x27; block</span></span><br><span class="line">    TheFunction-&gt;<span class="built_in">getBasicBlockList</span>().<span class="built_in">push_back</span>(MergeBB);</span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(MergeBB);</span><br><span class="line">    llvm::PHINode *PN = Builder.<span class="built_in">CreatePHI</span>(llvm::Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="number">2</span>, <span class="string">&quot;iftmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PN-&gt;<span class="built_in">addIncoming</span>(ThenV, ThenBB);</span><br><span class="line">    PN-&gt;<span class="built_in">addIncoming</span>(ElseV, ElseBB);</span><br><span class="line">    <span class="keyword">return</span> PN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将 <code>CondV</code> 生成代码, 然后使用 <code>Builder-&gt;CreateFCmpONE()</code> 生成条件判断代码.</p>
<p>然后通过 <code>Builder-&gt;GetInsertBlock()-&gt;getParent()</code> 获取整个函数的指针, 用来创建这个函数中其它的 BasicBlock, 也就是 then block, else block 和最后的 merge block. 注意这里的 else block 是直接插入到函数后端的. then block 和 merge block 还没有插入到函数中. 然后使用 <code>Builder.CreateCondBr()</code> 来创建跳转指令, 根据条件判断的值跳转到不同的 Basic Block.</p>
<p>然后使用 <code>Builder.SetInsertPoint(ThenBB)</code> 将当前代码的插入点设置为 then block 的最后, 在后面进行类似于 append 的操作. 然后递归调用 Then 的 <code>codegen()</code> 生成代码, 生成完毕之后创建一个无条件跳转 <code>CreateBr</code>, 将控制流转移到 merge block. (LLVM 中, 所有的 basic block 必须使用控制流指令来终结, 即使是 fall-through 也需要一个无条件的跳转)</p>
<p>最重要的是, 这里我们又需要一个 <code>ThenBB = Builder.getInsetBlock()</code>. 在我们设置 Phi node 时, 我们要创建 basic block 和 value 的 key/value 对, 所以Phi node 需要获取和它直接相邻的前面两个 block 的信息. 然而, 在对 Else block 和 Then block 进行代码生成时, 如果它们中嵌套了 if/then/else, 那么之前的 Then block 和 Else block 就不是和 Phi node 直接相连了. 所以我们要在代码生成完毕之后再获取一次当前的 basic block, 来获取直接与 Phi node 相连的前驱 block.</p>
<p>然后是将 Else block 添加到函数中, 再调用 <code>Builder.SetInsetPoint()</code> 设置需要生成代码的位置, 递归生成代码, 创建跳转, 更新 Phi node 前驱 block.</p>
<p>然后是 merge block, 前面也是一样的操作, 将 basic block 加入函数, 并设置代码插入点. 然后使用 <code>Builder.CreatePHI()</code> 创建一个 Phi node, 来处理分支的合并. 然后再加上进入分支的信息就可以.</p>
<p>最后, 整个 If/Then/Else 表达式的值就是 Phi node 的值.</p>
<h2 id="for-loop-expression"><a href="#for-loop-expression" class="headerlink" title="for loop expression"></a><code>for</code> loop expression</h2><p>我们想添加一个如下的 for loop:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">putchard</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function">def <span class="title">printstar</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> i </span>= <span class="number">1</span>, i &lt; n, <span class="number">1.0</span> <span class="function">in</span></span><br><span class="line"><span class="function">        <span class="title">putchard</span><span class="params">(<span class="number">42</span>)</span></span>;       <span class="meta"># ascii 42 = <span class="meta-string">&#x27;*&#x27;</span></span></span><br><span class="line">printstar(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个表达式定义了一个新的变量 <code>i</code>, 从 <code>1</code> 开始迭代, 当条件 <code>i &lt; n</code> 成立时, 执行循环体中的 <code>putchard(42)</code>, 并将自身加 <code>1</code>. 目前我们将循环表达式的值设置为 0.</p>
<h3 id="Lexer-Extension-for-the-for-Loop"><a href="#Lexer-Extension-for-the-for-Loop" class="headerlink" title="Lexer Extension for the for Loop"></a>Lexer Extension for the <code>for</code> Loop</h3><p>看代码</p>
<h3 id="AST-Extension-for-the-for-Loop"><a href="#AST-Extension-for-the-for-Loop" class="headerlink" title="AST Extension for the for Loop"></a>AST Extension for the <code>for</code> Loop</h3><p>看代码</p>
<h3 id="Parser-Extension-for-the-for-loop"><a href="#Parser-Extension-for-the-for-loop" class="headerlink" title="Parser Extension for the for loop"></a>Parser Extension for the <code>for</code> loop</h3><p>看代码</p>
<h3 id="LLVM-IR-for-the-for-loop"><a href="#LLVM-IR-for-the-for-loop" class="headerlink" title="LLVM IR for the for loop"></a>LLVM IR for the <code>for</code> loop</h3><p>当我们生成代码时, 应该是如下所示的结构:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">double</span> <span class="title">@putchard</span>(<span class="keyword">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">double</span> <span class="title">@printstar</span>(<span class="keyword">double</span> <span class="variable">%n</span>) &#123;</span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">    <span class="comment">; initial value = 1.0 (inlined into phi)</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; preds = %loop, %entry</span></span><br><span class="line"><span class="symbol">loop:</span></span><br><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="keyword">double</span> [<span class="number">1.000000e+00</span><span class="punctuation">,</span> <span class="variable">%entry</span>]<span class="punctuation">,</span> [<span class="variable">%nextvar</span><span class="punctuation">,</span> <span class="variable">%loop</span>]</span><br><span class="line">    <span class="comment">; body</span></span><br><span class="line">    <span class="variable">%calltmp</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="keyword">double</span> <span class="title">@putchard</span>(<span class="keyword">double</span> <span class="number">4.200000e+01</span>)</span><br><span class="line">    <span class="comment">; increment</span></span><br><span class="line">    <span class="variable">%nextvar</span> <span class="operator">=</span> <span class="keyword">fadd</span> <span class="keyword">double</span> <span class="variable">%i</span><span class="punctuation">,</span> <span class="number">1.000000e+00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; termination test</span></span><br><span class="line">    <span class="variable">%cmptmp</span> <span class="operator">=</span> <span class="keyword">fcmp</span> <span class="keyword">ult</span> <span class="keyword">double</span> <span class="variable">%i</span><span class="punctuation">,</span> <span class="variable">%n</span></span><br><span class="line">    <span class="variable">%booltmp</span> <span class="operator">=</span> <span class="keyword">uitofp</span> <span class="type">i1</span> <span class="variable">%cmptmp</span> <span class="keyword">to</span> <span class="keyword">double</span></span><br><span class="line">    <span class="variable">%loopcond</span> <span class="operator">=</span> <span class="keyword">fcmp</span> <span class="keyword">one</span> <span class="keyword">double</span> <span class="variable">%booltmp</span><span class="punctuation">,</span> <span class="number">0.000000e+00</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%loopcond</span><span class="punctuation">,</span> label <span class="variable">%loop</span><span class="punctuation">,</span> label <span class="variable">%afterloop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; preds = %loop</span></span><br><span class="line"><span class="symbol">afterloop:</span></span><br><span class="line">    <span class="comment">; loop always returns 0</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="keyword">double</span> <span class="number">0.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-Generation-for-the-for-Loop"><a href="#Code-Generation-for-the-for-Loop" class="headerlink" title="Code Generation for the for Loop"></a>Code Generation for the <code>for</code> Loop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">ForExprAST::codegen</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Emit the start code first, without &#x27;variable&#x27; in scope</span></span><br><span class="line">    llvm::Value *StartVal = Start-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!StartVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the new basic block for the loop header, </span></span><br><span class="line">    <span class="comment">// inserting after current block</span></span><br><span class="line">    llvm::Function *TheFunction = Builder.<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    llvm::BasicBlock *PreheaderBB = Builder.<span class="built_in">GetInsertBlock</span>();</span><br><span class="line">    llvm::BasicBlock *LoopBB = llvm::BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;loop&quot;</span>, TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserting an explict fall-through from current (PreheaderBB) to LoopBB.</span></span><br><span class="line">    Builder.<span class="built_in">CreateBr</span>(LoopBB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start insertion to LoopBB</span></span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(LoopBB);</span><br><span class="line">    <span class="comment">// Start the PHI node with one Incoming basic block</span></span><br><span class="line">    llvm::PHINode *Variable = Builder.<span class="built_in">CreatePHI</span>(llvm::Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="number">2</span>, VarName.<span class="built_in">c_str</span>());</span><br><span class="line">    Variable-&gt;<span class="built_in">addIncoming</span>(StartVal, PreheaderBB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Within the loop, the variable is defined equal to </span></span><br><span class="line">    <span class="comment">// the PHI node, If it shadows an existing variable, </span></span><br><span class="line">    <span class="comment">// we have to restore it, so save it now.</span></span><br><span class="line">    llvm::Value *OldVal = NamedValues[VarName];</span><br><span class="line">    NamedValues[VarName] = Variable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the body of the loop. This, like any other </span></span><br><span class="line">    <span class="comment">// expr, can change the current BB. Note that we </span></span><br><span class="line">    <span class="comment">// ignore the value computed by the body, but don&#x27;t </span></span><br><span class="line">    <span class="comment">// allow an error.</span></span><br><span class="line">    <span class="keyword">if</span> (!Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the step value</span></span><br><span class="line">    llvm::Value *StepVal = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (Step) &#123;</span><br><span class="line">        StepVal = Step-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">        <span class="keyword">if</span> (!StepVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if not specified, use 1.0</span></span><br><span class="line">        StepVal = llvm::ConstantFP::<span class="built_in">get</span>(TheContext, llvm::<span class="built_in">APFloat</span>(<span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add the step value</span></span><br><span class="line">    llvm::Value *NextVal = Builder.<span class="built_in">CreateFAdd</span>(Variable, StepVal, <span class="string">&quot;nextvar&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the end condition</span></span><br><span class="line">    llvm::Value *EndCond = End-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!EndCond) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0</span></span><br><span class="line">    EndCond = Builder.<span class="built_in">CreateFCmpONE</span>(EndCond, llvm::ConstantFP::<span class="built_in">get</span>(TheContext, llvm::<span class="built_in">APFloat</span>(<span class="number">0.0</span>)), <span class="string">&quot;loopcond&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the &quot;after loop&quot; block and insert it</span></span><br><span class="line">    llvm::BasicBlock *LoopEndBB = Builder.<span class="built_in">GetInsertBlock</span>();</span><br><span class="line">    llvm::BasicBlock *AfterBB = llvm::BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;afterloop&quot;</span>, TheFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the conditional branch into the end of LoopEndBB</span></span><br><span class="line">    Builder.<span class="built_in">CreateCondBr</span>(EndCond, LoopBB, AfterBB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any new code will be inserted in AfterBB</span></span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(AfterBB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a new entry to the PHI node for the backage</span></span><br><span class="line">    Variable-&gt;<span class="built_in">addIncoming</span>(NextVal, LoopEndBB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the unshadowed variable</span></span><br><span class="line">    <span class="keyword">if</span> (OldVal) &#123;</span><br><span class="line">        NamedValues[VarName] = OldVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NamedValues.<span class="built_in">erase</span>(VarName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always returns 0.0</span></span><br><span class="line">    <span class="keyword">return</span> llvm::Constant::<span class="built_in">getNullValue</span>(llvm::Type::<span class="built_in">getDoubleTy</span>(TheContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是生成 start 部分, 对应 parser 来看就是循环变量 <code>i</code> 被赋予的初始值, 所以先计算这部分. 下一步就是生成循环体的代码, 首先获取当前 basic block 所在的函数 <code>Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent()</code>, 然后把当前的 basic block 标记为 <code>BasicBlock *PreheaderBB</code>. 创建循环体 basic block (<code>BasicBlock *LoopBB</code>), 并把它添加到函数末尾. 然后在 <code>PreheaderBB</code> 最后添加一条 fall-through 到 <code>LoopBB</code> 的<code>Br</code> 指令.</p>
<p>这部分代码和之前看到的 <code>if/then/else</code> 代码生成的方式很相似. 由于循环体所在的 basic block 有两个 incoming 的控制流边 (fall-through 和循环尾), 我们要使用 Phi node 来标记控制流是从哪来的. 目前我们创建的只有 <code>PreheaderBB</code>, 所以现在只添加一个 incoming 即可. 所以, 先把函数插入点移到 <code>LoopBB</code>, 然后用 <code>Builder</code> 生成 Phi node 即可.</p>
<p>在对循环变量作处理时, 循环变量可能和函数参数重名, 导致冲突. 所以我们使用一个 shadow 变量先把变量符号表 (NamedValues) 中的同名值存起来, 这样就实现了作用域的概念. 然后我们给循环体生成代码, 递归的调用 <code>Body-&gt;codegen()</code> 即可. 如果我们设置了 <code>StepVal</code>, 那么就生成 Step 的代码, 没有的话默认就是 <code>1</code>. 然后再创建一个 <code>NextVar</code> 用作下一次循环时的循环变量.</p>
<p>最后计算结束条件 <code>EndCond</code>, 首先生成代码. 再使用生成的代码去创建一个 <code>FCmpOne</code>, 用作后续 <code>CondBr</code> 指令的条件判断. 然后使用 <code>BasicBlock *LoopEndBB = Builder.GetInsertBlock()</code> 去更新最新的 basic block, 作为循环体的最后一个 block, 并创建一个 <code>BasicBlock *AfterBB</code> 使得之后的代码生成都是在循环结束之后. 最后就是给 Phi node 添加一个来自于 <code>BasicBlock *LoopEndBB</code> 的边, 并从 shadow object 中恢复原来变量的值, 最后直接返回 0.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/Kaleidoscope-Adding-JIT-and-Optimizer-Support/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/15/Kaleidoscope-Adding-JIT-and-Optimizer-Support/" class="post-title-link" itemprop="url">Kaleidoscope: Adding JIT and Optimizer Support</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-15 21:52:27" itemprop="dateCreated datePublished" datetime="2019-05-15T21:52:27+08:00">2019-05-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Chapter-4-Introduction"><a href="#Chapter-4-Introduction" class="headerlink" title="Chapter 4 Introduction"></a>Chapter 4 Introduction</h2><p>这一章主要是两个部分: (1) 给语言添加一个 Optimizer, (2) 添加 JIT 支持.</p>
<h2 id="Trivial-Constant-Folding"><a href="#Trivial-Constant-Folding" class="headerlink" title="Trivial Constant Folding"></a>Trivial Constant Folding</h2><p>第二章中我们并没有添加任何的优化操作, 然而, <code>IRBuilder</code> 自动帮我们完成了下列的优化:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def test(<span class="keyword">x</span>) <span class="number">1</span>+<span class="number">2</span>+<span class="keyword">x</span><span class="comment">;</span></span><br><span class="line">Read function definition:</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">double</span> <span class="title">@test</span>(<span class="keyword">double</span> <span class="variable">%x</span>) &#123;</span><br><span class="line"><span class="symbol">    entry:</span></span><br><span class="line">        <span class="variable">%addtmp</span> <span class="operator">=</span> <span class="keyword">fadd</span> <span class="keyword">double</span> <span class="number">3.000000e+00</span><span class="punctuation">,</span> <span class="variable">%x</span></span><br><span class="line">        <span class="keyword">ret</span> <span class="keyword">double</span> <span class="variable">%addtmp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有这个优化 (Constant folding), 我们得到的代码里就会把 <code>1</code> <code>2</code> 相加, 再把结果加上 <code>x</code>. 这个类型的优化叫做 Constant folding, 很多语言在实现它的时候都是在 AST 表达中进行的. 但是使用 LLVM 实现语言, 使用 <code>IRBuilder</code> 来生成代码时, 这个优化会自动完成.</p>
<p>然而, <code>IRBuilder</code> 自身的优化也受到一定程度的限制:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def test(<span class="keyword">x</span>) (<span class="number">1</span>+<span class="number">2</span>+<span class="keyword">x</span>)*(<span class="keyword">x</span>+(<span class="number">1</span>+<span class="number">2</span>))<span class="comment">;</span></span><br><span class="line">Read the function definition:</span><br><span class="line"><span class="keyword">define</span> <span class="keyword">double</span> <span class="title">@test</span>(<span class="keyword">double</span> <span class="variable">%x</span>) &#123;</span><br><span class="line"><span class="symbol">    entry:</span></span><br><span class="line">        <span class="variable">%addtmp</span> <span class="operator">=</span> <span class="keyword">fadd</span> <span class="keyword">double</span> <span class="number">3.000000e+00</span><span class="punctuation">,</span> <span class="variable">%x</span></span><br><span class="line">        <span class="variable">%addtmp1</span> <span class="operator">=</span> <span class="keyword">fadd</span> <span class="keyword">double</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">3.000000e+00</span></span><br><span class="line">        <span class="variable">%multmp</span> <span class="operator">=</span> <span class="keyword">fmul</span> <span class="keyword">double</span> <span class="variable">%addtmp</span><span class="punctuation">,</span> <span class="variable">%addtmp1</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中, LHS 和 RHS 显然是相同的值, 但 <code>IRBuilder</code> 的 local analysis 不可能能检测到并且优化这些代码. 这需要两个 transformation: (1) reassociation of expressions (重新关联表达式, 使得 <code>+</code> 的表示变得唯一), (2) Common SubExpression Elimination (CSE, 公共子表达式消除, 删除重复的 <code>+</code> 指令).</p>
<p>所以我们要使用 “<strong>pass</strong>“ 来完成这些优化.</p>
<h2 id="LLVM-Optimization-Passes"><a href="#LLVM-Optimization-Passes" class="headerlink" title="LLVM Optimization Passes"></a>LLVM Optimization Passes</h2><blockquote>
<p><code>PassManger</code> 改版了, 这篇教程是基于 <code>llvm::legacy::FunctionPassManager</code> 的, 这个类可以在 <code>LegacyPassManager.h</code> 找到. <del>但我还是尝试用新版的来实现</del></p>
<p>参考Luke的回答, 使用继承了 PassInfoMixin class 的新版 Pass; 使用 FunctionAnalysisManager 类来注册 Pass; 使用 PassBuilder 工具类辅助.</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/48726129/4684264">答案链接</a></p>
</blockquote>
<p>LLVM 提供了很多优化 pass, 而且同时允许编译器开发者定义, 并在合适的时候调用自己的 pass.</p>
<p>举个具体的例子, LLVM 提供了对整个 Module 进行处理的 pass, 同时也包括对单个函数的 pass. 在 Kaleidoscope 中, 我们使用的是针对单个函数的优化 pass, 也就是说用户定义一个我们就优化一个.</p>
<p>首先添加我们需要的全局变量:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;llvm::FunctionPassManager&gt; TheFPM;</span><br><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;llvm::FunctionAnalysisManager&gt; TheFAM;</span><br><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;llvm::PassBuilder&gt; ThePB;</span><br></pre></td></tr></table></figure>

<p>然后我们需要设置好 <code>FunctionPassManager</code>, 用它来添加我们所想运行的 pass, 由于每个 Module 都需要 new 一个 <code>FunctionPassManager</code>， 我们就添加一个初始化它们的函数. 我们在该函数的最后才初始化 <code>TheFAM</code>, <code>ThePB</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// open a new Module</span></span><br><span class="line">    TheModule = std::make_unique&lt;llvm::Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new pass manager attached to it</span></span><br><span class="line">    TheFPM = std::make_unique&lt;llvm::FunctionPassManager&gt;(TheModule.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Combine instructions to form fewer, simple</span></span><br><span class="line">    <span class="comment">// instructions. This pass does not modify the CFG. This</span></span><br><span class="line">    <span class="comment">// pass is where algebraic simplification happens.</span></span><br><span class="line">    <span class="comment">// (https://llvm.org/docs/Passes.html#instcombine-combine-redundant-instructions)</span></span><br><span class="line">    TheFPM-&gt;<span class="built_in">addPass</span>(llvm::<span class="built_in">InstCombinePass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This pass reassociates commutative expressions in an order</span></span><br><span class="line">    <span class="comment">// that is designed to promote better constant propagation, GCSE, LICM, PRE, etc.</span></span><br><span class="line">    <span class="comment">// (https://llvm.org/docs/Passes.html#reassociate-reassociate-expressions)</span></span><br><span class="line">    TheFPM-&gt;<span class="built_in">addPass</span>(llvm::<span class="built_in">ReassociatePass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This pass performs global value numbering to eliminate fully and partially redundant instructions.</span></span><br><span class="line">    <span class="comment">// It also performs redundant load elimination.</span></span><br><span class="line">    <span class="comment">// (https://llvm.org/docs/Passes.html#gvn-global-value-numbering)</span></span><br><span class="line">    TheFPM-&gt;<span class="built_in">addPass</span>(llvm::<span class="built_in">GVN</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Performs dead code elimination and basic block merging.</span></span><br><span class="line">    <span class="comment">// (https://llvm.org/docs/Passes.html#simplifycfg-simplify-the-cfg)</span></span><br><span class="line">    TheFPM-&gt;<span class="built_in">addPass</span>(llvm::<span class="built_in">SimplifyCFGPass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using PassBuilder and FunctionAnalysis Manager Register analysis passes</span></span><br><span class="line">    ThePB = std::make_unique&lt;llvm::PassBuilder&gt;();</span><br><span class="line">    TheFAM = std::make_unique&lt;llvm::FunctionAnalysisManager&gt;();</span><br><span class="line">    ThePB-&gt;<span class="built_in">registerFunctionAnalyses</span>(*TheFAM.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码首先初始化全局的 <code>TheModule</code>, 和 <code>TheFPM</code>. 然后使用一系列的 <code>addPass()</code> 方法来给 <code>TheFPM</code> 添加 Pass. 添加完之后, 使用 <code>ThePB</code> 和 <code>TheFAM</code> 来注册这些 Pass.</p>
<p>然后我们得使用它, 所以在 <code>FunctionAST::codegen()</code> 中生成代码之后加上:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finish off the function</span></span><br><span class="line">Builder.<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line"><span class="comment">// Validate the generated code, checking for consistency</span></span><br><span class="line">llvm::<span class="built_in">verifyFunction</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optimization of the function code</span></span><br><span class="line">    TheFPM-&gt;<span class="built_in">run</span>(*TheFunction, *TheFAM.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TheFunction;</span><br></pre></td></tr></table></figure>

<p>记得在 <code>main()</code> 里面调用 <code>InitializeModuleAndPassManager()</code></p>
<h2 id="Adding-a-JIT-compiler"><a href="#Adding-a-JIT-compiler" class="headerlink" title="Adding a JIT compiler"></a>Adding a JIT compiler</h2><p>将代码生成为 IR 后, 我们可以使用多种不同的工具来对它进行处理. 比如我们可以优化它 (上一节), 或者将它 dump 下来之后, 将 IR 编译为汇编文件 (.s), 或者使用 JIT 来编译它. LLVM IR 就相同于编译器个部分之间的通货 (common currency).</p>
<p>在这节我们将要给解释器添加 JIT 支持, 最基本的要求是: 一旦我们将函数体输入进去之后, 它能够立刻算出 top-level 表达式的值. 比如在输入 <code>1+2;</code> 之后立即输出一个 <code>3</code>. 同时定义好的函数也能直接在命令行被调用.</p>
<p>首先我们先准备 native target 的环境, 并声明和初始化 JIT. 注意这里的 <code>class KaleidoscopeJIT</code> 教程里面引用的是 LLVM 源码中的类, 但我不是源码安装, 所以还是把它复制过来再使用.</p>
<p>首先定义全局变量 <code>static std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT;</code>, <code>class Kaleidoscope</code> 定义在 <a href="./KaleidoscopeJIT.h">KaleidoscopeJIT</a>.</p>
<p>然后在 <code>main()</code> 函数中, 添加这几段:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> JIT</span></span><br><span class="line">    <span class="comment">// Initialize native target</span></span><br><span class="line">    llvm::<span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">    llvm::<span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line">    llvm::<span class="built_in">InitializeNativeTargetAsmParser</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">InitTokPrecedence</span>();</span><br><span class="line">    <span class="comment">// prime the first token</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ready&gt; &quot;</span>);</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    TheJIT = std::make_unique&lt;llvm::orc::KaleidoscopeJIT&gt;();</span><br><span class="line">    <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line">    <span class="built_in">MainLoop</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> JIT</span></span><br><span class="line">    <span class="comment">// Print out all of the generated code</span></span><br><span class="line">    TheModule-&gt;<span class="built_in">print</span>(llvm::<span class="built_in">errs</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时要在 <code>InitializeModuleAndPassManager()</code> 函数中设置 data layout:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open a new Module</span></span><br><span class="line">TheModule = std::make_unique&lt;llvm::Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class="line">TheModule-&gt;<span class="built_in">setDataLayout</span>(TheJIT-&gt;<span class="built_in">getTargetMachine</span>().<span class="built_in">createDataLayout</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new pass manager attached to it</span></span><br><span class="line">TheFPM = std::make_unique&lt;llvm::FunctionPassManager&gt;(TheModule.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<p><code>class Kaleidoscope</code> 是一个简单的 JIT 构造类, 我们会在之后的章节中对它进行扩展. 目前的它提供的 API 非常简单: <code>addModule()</code> 给 JIT 添加了一个 Module, 使得函数能够执行; <code>removeModule()</code> 移除一个 Module, 释放相应的内存空间; <code>findSymbol()</code> 使我们能够通过 <code>string name</code> 来查找编译好代码的指针.</p>
<p>我们能使用这些 API 在 top-level 的 handle 函数中添加表达式值的计算:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = <span class="built_in">ParseTopLevelExpr</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (FnAST-&gt;<span class="built_in">codegen</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// JIT the module containing the anonymous expression, keeping a handle so we free it later</span></span><br><span class="line">            <span class="keyword">auto</span> H = TheJIT-&gt;<span class="built_in">addModule</span>(std::<span class="built_in">move</span>(TheModule));</span><br><span class="line">            <span class="comment">// Optimization of passes</span></span><br><span class="line">            <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search the JIT for the __anon_expr symbol</span></span><br><span class="line">            <span class="keyword">auto</span> ExprSymbol = TheJIT-&gt;<span class="built_in">findSymbol</span>(<span class="string">&quot;__anon_expr&quot;</span>);</span><br><span class="line">            <span class="built_in">assert</span>(ExprSymbol &amp;&amp; <span class="string">&quot;Function not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the symbol&#x27;s address and cast it to the right type (takes no arguments, returns a double) so we can call it as a native function.</span></span><br><span class="line">            <span class="built_in"><span class="keyword">double</span></span> (*FP)() = (<span class="built_in"><span class="keyword">double</span></span> (*)())<span class="keyword">static_cast</span>&lt;<span class="keyword">intptr_t</span>&gt; (ExprSymbol.<span class="built_in">getAddress</span>().<span class="built_in">get</span>());</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Evaluated to %f\n &quot;</span>, <span class="built_in">FP</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Delete the anonymous expression module from the JIT</span></span><br><span class="line">            TheJIT-&gt;<span class="built_in">removeModule</span>(H);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果 Parsing 和 codegen 都成功执行, 下一步就是将包含 top-level 表达式的 Module 添加到 JIT, 我们使用 <code>addModule()</code> 这个方法, 触发这个 Module 中 所有函数的代码生成, 并返回一个 <code>VModuleKey</code> 的对象, 使得我们在之后可以移除 Module. 一旦这个 Module 被加入到 JIT, 它就不能被修改, 所以我们需要调用 <code>InitializeModuleAndPassManager()</code> 来打开一个新的 Module, 去持有接下来生成的代码.</p>
<p>一旦我们将 Module 添加到 JIT, 我们需要找到生成代码的指针, 所以我们使用 JIT 的<code>findSymbol()</code> 方法, 将 top-level 表达式的函数名 “__anon_expr” 当作参数传入, 就可以得到指令地址.</p>
<p>注意 “__anon_expr” 是要在 Parse top-level 表达式时传入的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseTopLevelExpr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// anonymous nullary function</span></span><br><span class="line">        <span class="keyword">auto</span> Proto = std::make_unique&lt;PrototypeAST&gt;(<span class="string">&quot;__anon_expr&quot;</span>, std::vector&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们使用 <code>getAddress().get()</code> 来获取这个函数在内存中的地址. 我们定义的匿名函数没有参数, 返回值为 <code>double</code>. 因为 LLVM JIT 编译器匹配了 native 平台的 ABI, 所以我们可以直接将函数地址转化成一个函数指针, 然后直接调用它. 这意味着, JIT 编译出的代码和静态链接到应用的 native 机器码没有区别.</p>
<p>最后, 由于我们不支持 top-level 的重复计算, 我们在代码生成的最后移除 Module, 释放调关联的内存. 但是我们在之前使用 <code>InitializeModuleAndPassManager()</code> 创建的 Module 仍然开启, 新的代码可以继续添加到其中.</p>
<p>再调用一次之前定义的函数会找不到符号, 因为一个 Module 是 JIT 分配的一个单元, 定义的函数位于前面 Module 中, 当我们把一个 Module 移除之后, 我们就相当于删除了那个 Module 中所有函数的定义, 所以再次调用就找不到符号.</p>
<p>最简单的方式就是将匿名表达式放在一个单独的 Module, 和其他函数定义分开.</p>
<p>实际上, 我们想更进一步, 将每个函数都放到一个单独的 Module, 这样就更加像一个 REPL, 函数能被定义多次, 引用它时, 都是返回最近的定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos;</span><br><span class="line"></span><br><span class="line"><span class="function">llvm::Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Transfer ownership of the prototype to the FunctionProtos  </span></span><br><span class="line">    <span class="comment">// map, but keep a reference to it use below</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">    FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">    <span class="comment">// Check for an existing function from a previous `extern` declaration</span></span><br><span class="line">    llvm::Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llvm::Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Lookup the name in the global module table</span></span><br><span class="line">    llvm::Function *CalleeF = <span class="built_in">getFunction</span>(Callee);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llvm::Function *<span class="title">getFunction</span><span class="params">(std::string Name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First, check if the function has already been added to the </span></span><br><span class="line">    <span class="comment">// current mode</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;<span class="built_in">getFunction</span>(Name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not exist, check wether we can codegen the declaration // from some existing prototype</span></span><br><span class="line">    <span class="keyword">auto</span> FI = FunctionProtos.<span class="built_in">find</span>(Name);</span><br><span class="line">    <span class="keyword">if</span> (FI != FunctionProtos.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> FI-&gt;second-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if no existing prototype exists, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先添加一个全局的 <code>map&lt;string, unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos</code>, 用它来保存每个函数最近的一次函数原型. 并且我们添加了一个 <code>getFunction()</code> , 代替 <code>TheModule-&gt;getFunction()</code>. 自定义的 <code>getFunction()</code>, 首先它搜寻 Module, 看有没有存在的函数声明, 如果没有就生成函数原型的代码. <strong>所以我们可以把之前 <code>Function *FunctionAST::codegen()</code> 之中的那个生成函数原型的代码片段删除</strong>. 同时在 <code>Function *FunctionAST::codegen()</code> 中, 我们首先更新 <code>FunctionProtos</code>, 再调用 <code>getFunction()</code>. 通过使用这个全局的 <code>FunctionProtos</code>, 我们能获取之前声明过的所有函数.</p>
<p>我们还需要更新 <code>HandleDefinition()</code> 和 <code>HandleExtern()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = <span class="built_in">ParseDefinition</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;<span class="built_in">codegen</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Read the function definition: &quot;</span>);</span><br><span class="line">            FnIR-&gt;<span class="built_in">print</span>(llvm::<span class="built_in">errs</span>());</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            TheJIT-&gt;<span class="built_in">addModule</span>(std::<span class="built_in">move</span>(TheModule));</span><br><span class="line">            <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Skip token for error recovery</span></span><br><span class="line">        <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = <span class="built_in">ParseExtern</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;<span class="built_in">codegen</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Read extern: &quot;</span>);</span><br><span class="line">            FnIR-&gt;<span class="built_in">print</span>(llvm::<span class="built_in">errs</span>());</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            FunctionProtos[ProtoAST-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(ProtoAST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Skip token for error recovery</span></span><br><span class="line">        <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>HandleDefinition()</code> 中, 我们需要将刚刚定义好的函数所在的 Module 添加到 JIT, 然后打开一个新的 Module, 这样就使得每个函数都在不同的 Module 中. 在 <code>HandleExtern()</code> 中, 只需要将这个外部声明添加到 <code>FunctionProtos</code> 中即可.</p>
<p>并且, 对于外部声明 <code>e.g., extern sin(x)</code>, JIT 有一套直接的符号解析机制: JIT 按照时间逆序, 搜寻所有添加的 Module, 来查找符号的定义. 如果没找到, 它就 fall back 去调用 <code>dlsym(&quot;sin&quot;)</code>, 去 JIT 的地址空间里面去找这个符号的定义, 然后去调用它 (<code>libm</code>).</p>
<p>后面我们会进一步讨论 JIT 的符号解析机制, 并调整它来实现一些 feature, 比如安全性, 动态代码生成, 甚至是 lazy evaluation.</p>
<p>调整符号解析规则一个最直接的好处就是, 我们能使用任意的 C++ 代码来扩展语言:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">DLLEXPORT <span class="keyword">double</span> <span class="title">putchard</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputc</span>((<span class="keyword">char</span>)X, stderr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接时添加 <code>-rdynamic</code>, 使得 <code>dlopen()</code> 打开的 shared object 能解析到自己程序中的符号.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/Fast-and-generic-metadata-management-with-mid-fat-pointers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/13/Fast-and-generic-metadata-management-with-mid-fat-pointers/" class="post-title-link" itemprop="url">Fast and generic metadata management with mid-fat pointers</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-13 16:14:59" itemprop="dateCreated datePublished" datetime="2019-05-13T16:14:59+08:00">2019-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/workshop-paper/" itemprop="url" rel="index"><span itemprop="name">workshop paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We present <em>mid-fat pointers</em>, an approach to support targeted but composable metadata-based software defenses. The key idea is to strike a balance between traditional fat pointers and low-fat pointers by preserving the pointer size but changing its representation with embed data. This is done by piggybacking on SFI to decode the pointers efficiently. In such a scenario, its use by mid-fat pointers incurs no additional overhead.</p>
<p>With mid-fat pointers, each pointer can embed the location of the metadata for the pointed memory object. Compared to recent generic metadata management schemes, we improve performance because we need fewer lookups as the metadata location is cached in the pointer and security because an out-of-bounds pointer is still associated with the same metadata.</p>
<h2 id="Threat-model"><a href="#Threat-model" class="headerlink" title="Threat model"></a>Threat model</h2><p>Since mid-fat pointers provide a general defense framework, the threat model depends on particular defenses deployed. With regards to these defense, we only assume they require an SFI baseline. As a result, the metadata is inherently protected against both arbitrary memory reads and writes.</p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Pointer-encoding"><a href="#Pointer-encoding" class="headerlink" title="Pointer encoding"></a>Pointer encoding</h3><p>One core insight for our framework is that, given the presence of SFI to protect metadata from attacker, we can use the unused bit in pointers without an additional performance impact. In particular, whenever the program allocates memory, we store a pointer to the metadata for that chunk of memory in the high bits of the pointer. This design has three benefits: (1) it requires a full metadata lookup only once at allocation time, caching the more frequent lookups needed for defenses and increasing efficiency; (2) since we know the base address of newly allocated objects, we do not need range queries; and (3) pointers that go-out-of bounds still point to the metadata for the original object.</p>
<p>By default, we use the 32 lower bits of every pointer to encode where the data is (<em>data pointer</em>), and 32 higher bits to encode where the metadata is (<em>metadata pointer</em>). The downside is that we can use only 32-bit addresses out of the 48 bits implemented on x86-64, which restricts the address space to 4 GB. Note, however, that we could use fewer bits for the metadata pointer by assuming that every object is aligned on 8-byte boundaries.</p>
<h3 id="Allocation-instrumentation"><a href="#Allocation-instrumentation" class="headerlink" title="Allocation instrumentation"></a>Allocation instrumentation</h3><p>We use a compiler pass that searches for calls to memory allocation functions and adds a call to hook our static libraries. The hook looks up metadata for the allocated pointer and adds the metadata pointer in the uppermost bits of the returned pointer.</p>
<p><strong>Load/store instrumentation.</strong> As the program can only dereference encoded pointer safely after decoding, our framework includes a compiler pass that identifies load and store operation add adds the data pointer decoder to each instance. We effectively implement SFI, shielding all memory past the first 4GB from attacker.</p>
<p><strong>Call instrumentation.</strong> While instrumented code can safely dereference encoded pointers due to automatic masking, protected applications may well use unprotected libraries and we must not pass encoded pointers to them to avoid segmentation faults. We therefore instrument calls to external functions by decoding any pointer-type parameters. Note that we can identify which are imported from libraries because our pass is part of LLVM’s link-time optimization. For indirect calls our instrumentation might not know if the current value of a function pointer is to an external call or not. Instead, when a function is address-taken we provide a replacement function that calls the original function with masked arguments.</p>
<p><strong>Pointer comparison and cast instrumentation.</strong> Besides dereferencing operations, compatibility issues arise when comparing pointers, and in integer operations on pointers. <strong>We could use static analysis to determine which pointers could be used in integer arithmetic and exclude them from our tagging scheme and SFI.</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/SGXBounds-Memory-Safety-for-Shielded-Execution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/12/SGXBounds-Memory-Safety-for-Shielded-Execution/" class="post-title-link" itemprop="url">SGXBounds: Memory Safety for Shielded Execution</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-12 15:06:46" itemprop="dateCreated datePublished" datetime="2019-05-12T15:06:46+08:00">2019-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Intel SGX provides an abstraction of <em>secure enclave</em>, which can be used to achieve <em>shielded execution</em> for <strong>unmodified legacy applications</strong> on untrusted infrastructure.</p>
<p>Shielded execution aims to protect confidentiality and integrity of applications when executed in an untrusted environment. The main idea is to isolate the application from the rest of the system, using only a narrow interface to communicate to the outside.</p>
<p>However, shield execution does not protect the program against <em>memory safety</em> attacks. To validate our claim, we reproduced publicly available memory safety exploits inside the secure enclave. These examples highlight that a single exploit can completely compromise the integrity and confidentiality properties of shield execution.</p>
<p>To prevent exploitation of these bugs, we experimented with two prominent software- and hardware based memory protection mechanisms in the context of shield execution: AddressSanitizer and Intel MPX, respectively.</p>
<p>But, both of them incur high performance overhead, due to additional metadata used to track object bounds.</p>
<p>In this paper, we present SGXBOUNDS. The SGXBOUNDS approach is based on a simple combination of tagged pointers and efficient memory layout to reduce overheads inside enclaves. In particular, we note that SGX enclave routine use only 32 lower bits to represent program address space and leave 32 higher bits of pointers unused. We utilize these high bits to represent the upper bound of the referent object (or more broadly the beginning of the object’s metadata area); the lower bound value is stored right after the object. Such metadata layout requires only 4 additional bytes per object and does not break cache locality — unlike Intel MPX and AddressSanitizer.</p>
<p>Futhermore, we show that our design naturally extends for: (1) “synchronization-free” support for multi-threaded application, (2) increased availability instead of usual fail-stop semantics by tolerating out-of-bounds accesses, (3) generic APIs for object’s metadata management to support new use-cases.</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p><strong>SCONE</strong> is a shielded execution framework that enables unmodified legacy application to take advantage of the isolation offered by SGX. With SCONE, the program is recompiled against a modified standard C library (SCONE libc), which facilitates the execution of of system calls.</p>
<p>Clearly, the combination of SCONE and SGX is not a silver bullet: bugs in the enclave code itself can render these mechanisms useless.</p>
<p><strong>Address Sanitizer</strong> is an extension to GCC and Clang/LLVM that detects the majority of object bounds violations. It keeps track of all objects, and checks whether the address is within one of the used objects on each memory access.</p>
<p><strong>Intel MPX</strong> detects all possible spatial memory vulnerabilities including intra-object ones (When one member in a structure corrupts other members). The approach to achieving this goal is different from AddressSanitizer. Instead of separating objects by unaddressable redzones, MPX keeps <em>bounds metadata</em> of all pointers and check against these bounds on each memory access.</p>
<p>One major limitation of the current Intel MPX implementation is a small number of bounded registers. If an application contains many distinct pointers, it will cause frequent loads and stores of bounds in memory.</p>
<h2 id="SGXBOUNDS"><a href="#SGXBOUNDS" class="headerlink" title="SGXBOUNDS"></a>SGXBOUNDS</h2><p>We built SGXBOUNDS based on the following three insights. First, shielded application memory (specifically, its working set) must be kept minimal due to the very limited EPC size in current SGX implementation. Second, applications spend a considerable amount of time iterating through the elements of an array, and a smartly chosen layout of metadata can significantly reduce the overhead of bounds checking. Third, we rely on the SCONE infrastructure with its monolithic build process: all application code is statically linked without external dependencies. The first and second insights dictate the use of per-object metadata combined with <em>tagged pointers</em> to keep memory overhead minimal.</p>
<h3 id="Design-overview"><a href="#Design-overview" class="headerlink" title="Design overview"></a>Design overview</h3><p>All modern SGX CPU operates in a 64-bit mode, meaning that all pointer are 64 bits in size. In SGX enclaves, however, only 36 bit of virtual address space are currently addressable. Thus, SGXBOUNDS relies on the idea of <em>tagged pointers</em>: a 64-bit pointer contains the pointer itself in its lower 32 bits and the referent object’s upper bound in the upper 32 bits.</p>
<p>The value stored in the higher 32 bits (UB) serves not only for the upper-bound check, but also as a pointer to the object’s other metadata (LB). The metadata is stored right after the referent object.</p>
<p>This metadata layout has important benefits: (1) it minimizes amount of memory for metadata, (2) it requires <em>no</em> additional memory accesses, (3) it alleviates problems of fat pointers concerning multi-threading and memory layout changes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *s[N], *d[N]</span><br><span class="line">s = specify_bounds(s, s + N)</span><br><span class="line">d = specify_bounds(d, d + N)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    si = s + i</span><br><span class="line">    di = d + i</span><br><span class="line">    sp, sLB, sUB = extract(si)</span><br><span class="line">    <span class="keyword">if</span> bounds_violated(sp, sLB, sUB)</span><br><span class="line">        crash(si)</span><br><span class="line">    val = load si</span><br><span class="line">    dp, dLB, dUB = extract(di)</span><br><span class="line">    <span class="keyword">if</span> bounds_violated(dp, dLB, dUB)</span><br><span class="line">        crash(di)</span><br><span class="line">    store val, di</span><br></pre></td></tr></table></figure>

<h3 id="Design-details"><a href="#Design-details" class="headerlink" title="Design details"></a>Design details</h3><p><strong>Pointer creation.</strong> Whenever an object is created, SGX-BOUNDS associates a pointer with the bound of this object.</p>
<p>For global and stack-allocated variables, we change their memory layout so they are padded with 4 bytes and initialize them at runtime. More specifically, we wrap such variables in two-member structures, e.g., <code>int x</code> is transformed into <code>struct xwarp &#123;int x; void* LB&#125;</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">specify_bounds</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">void</span> *UB)</span> </span>&#123;</span><br><span class="line">    LBaddr  = UB;</span><br><span class="line">    *LBaddr = p;</span><br><span class="line">    tagged  = (UB &lt;&lt; <span class="number">32</span>) | p;</span><br><span class="line">    <span class="keyword">return</span> tagged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For dynamically allocated variables, SGXBOUNDS wraps memory management functions to append 4 bytes to each newly created object, initialize these with the lower-bound value, and make the pointer tagged with the upper bound:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = malloc_real(size + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> specify_bounds(p, p + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that there is no need to instrument <code>free</code> as the 4 bytes of metadata are removed together with the object itself.</p>
<p><strong>Run-time bounds checks.</strong> SGXBOUNDS inserts run-time bounds check before each memory access: loads, stores, and atomic operations. For this, first the original pointer and the upper and lower bounds are extracted. To extract the original pointer:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">extract_p</span><span class="params">(<span class="keyword">void</span> *tagged)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tagged &amp; <span class="number">0xFFFF&#x27;FFFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To extract the upper bound”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">extract_UB</span><span class="params">(<span class="keyword">void</span> *tagged)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tagged &gt;&gt; <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To extract the lower bound which stored in the padded region:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">extract_LB</span><span class="params">(<span class="keyword">void</span> *UB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *UB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, the bound check:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bounds_violated</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">void</span> *LB, <span class="keyword">void</span> * UB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; LB || p &gt; UB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pointer arithmetic.</strong> SGXBOUNDS instruments pointer arithmetic so that only 32 low bits are affected:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UB = extract_UB(si)</span><br><span class="line">si = s + i</span><br><span class="line">si = (UB &lt;&lt; <span class="number">32</span>) | extract_p(si)</span><br></pre></td></tr></table></figure>

<p><strong>Type casts.</strong> Pointer-to-integer and integer-to-pointer casts are a curse for fat/tagged pointer approaches.</p>
<p><strong>Function calls.</strong> SGXBOUNDS does not need to instrument function calls or altering calling conventions. The only uninstrumented code is the libc, for which we provide wrappers. This implies that any tagged pointer passed as a function argument will be treated as a tagged pointer in the callee.</p>
<h2 id="Advanced-Features-of-SGXBOUNDS"><a href="#Advanced-Features-of-SGXBOUNDS" class="headerlink" title="Advanced Features of SGXBOUNDS"></a>Advanced Features of SGXBOUNDS</h2><h3 id="Multi-threading-support"><a href="#Multi-threading-support" class="headerlink" title="Multi-threading support"></a>Multi-threading support</h3><p>AddressSanitizer does not require any specific treatment of multi-threading, but it can negatively affect cache locality if a multi-threaded application was specifically designed as cache-friendly.</p>
<p>All fat-pointer or disjoint-metadata techniques similar to Intel MPX suffer from multi-threading issues. An update of a pointer and its associated metadata must be implemented as one atomic operation.</p>
<p>SGXBOUNDS does not experience this problem. Indeed, the pointer and the upper bound are always updated atomically since they are stored in the same 64-bit tagged pointer.</p>
<h3 id="Tolerating-bugs-with-boundless-memory"><a href="#Tolerating-bugs-with-boundless-memory" class="headerlink" title="Tolerating bugs with boundless memory"></a>Tolerating bugs with boundless memory</h3><p>To allow applications to survive most bugs and attacks and continue correct execution, SGXBOUNDS reverts to failure-oblivious computing by using the concepts of boundless memory blocks. In this case, whenever an out-of-bounds memory access is detected, SGXBOUNDS redirects this access to a separate “overlay” memory area to prevent corruption of adjacent objects, creating the illusion of “boundless memory allocated for the object.</p>
<p>Consider an example of a classic off-by-one error, SGXBOUNDS will redirect to load and store to an overlay address, instead of a violation of accessing metadata.</p>
<h3 id="Metadata-management-support"><a href="#Metadata-management-support" class="headerlink" title="Metadata management support"></a>Metadata management support</h3><p>So far, we discussed only one metadata type kept per object — the lower bound. However, our memory layout allows us to add arbitrary number of metadata items for each object to implement additional functionality.</p>
<p>All instrumentation in SGXBOUNDS is implemented as calls to auxiliary functions, which we refer to as instrumentation hooks. One can think of these hooks as a metadata management API : (1) <code>on_create()</code> is called at run-tim whenever a new object is created. In the context of SGXBOUNDS, it corresponds to the <code>specify_bounds()</code> function which initializes our only metadata (lowerbound). (2) <code>on_access()</code> is called at each memory access, be it a write, read, or both (for atomic instruction such as compare-and-swap). In SGXBOUNDS, the hook roughly corresponds to the <code>bounds_violated()</code> function. (3) <code>on_delete()</code> is called whenever the object is deallocated, we support this hook only for the head objects.</p>
<table>
<thead>
<tr>
<th>function</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td><code>on_create(base, size, type)</code></td>
<td align="left">called after object creation (global, heap, or stack)</td>
</tr>
<tr>
<td><code>on_access(addr, size, metadata, access_type)</code></td>
<td align="left">called before memory access</td>
</tr>
<tr>
<td><code>on_delete(metadata)</code></td>
<td align="left">called before object destruction(only for heap)</td>
</tr>
</tbody></table>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="SGXBOUNDS-implementation"><a href="#SGXBOUNDS-implementation" class="headerlink" title="SGXBOUNDS implementation"></a>SGXBOUNDS implementation</h3><p>SGXBOUNDS is a compile-time transformation pass implemented in LLVM 3.8.</p>
<p><strong>Compiler Support.</strong> We treat inline assembly as an opaque memory instruction: all pointer arguments to inline assembly are bounds checked. SGXBOUNDS does not yet completely support c++ exception handling.</p>
<p><strong>Run-time Support.</strong> We implement boundless memory feature completely in the run-time support library. To prevent data races, all read/update operations on the cache are synchronized via a global lock. For the tagged pointer scheme, SGXBOUNDS relies on SGX enclaves (thus the virtual address space) to start from 0x0. To allow this, we set Linux security flag <code>vm.mmap_min_addr</code> to zero for our applications. We also modified the original Intel SGX driver to always start the enclave at address 0x0.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhangtong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
