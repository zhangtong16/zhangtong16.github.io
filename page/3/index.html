<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="Zhangtong&#39;s Notebook">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Zhangtong&#39;s Notebook">
<meta property="og:locale">
<meta property="article:author" content="Zhangtong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;3&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Zhangtong's Notebook</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhangtong's Notebook</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhangtong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhangtong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/Block-oriented-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/01/Block-oriented-programming/" class="post-title-link" itemprop="url">Block-oriented programming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-01 10:47:46" itemprop="dateCreated datePublished" datetime="2019-04-01T10:47:46+08:00">2019-04-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Control-flow Integrity still allows the attacker control over the execution along two dimensions: the imprecision in the analysis and CFI’s statelessness; data-only attacks allow an attacker to influence conditional branches arbitrarily. With CFI, exploits become highly program dependent as the set of reachable gadgets is severely limited by CFI policy, so exploits must therefore follow valid paths in the CFG.</p>
<p>We present BOPC (<em>Block Oriented Programming Compiler</em>), an automatic framework to evaluate a program’s remaining attack surface under strong control-flow hijacking mitigation. BOPC compiles an “exploit” into a program trace, which is executed on top of the orignal program’s CFG. To express the desired exploits flexibly, BOPC provides a Turing-complete, high-level language: SPloit language (SPL). BOPC takes as input an SPL payload and a starting point and returns a trace through the program that encodes the SPL payload.</p>
<p>First, BOPC translates the SPL payload into constraints for individual statements and, for each statement, searches for basic blocks in the target binary that satisfy these constraints (called <em>candidate blocks</em>). At this point, SPL abstract register assignments from underlying architecture. Second, BOPC infers a resource (register and state) mapping for each SPL statement, iterating through the set of candidate blocks and turing them into <em>functional blocks</em> which can be used to execute a concrete instantiation of the given SPL statement. Third, BOPC constructs a trace that connect each functional block through <em>dispatcher  blocks</em>. Since the mapping process is NP-hard, to find a solution in reasonable time BOPC first prunes the set of functional blocks per statement to constrain the search space and then use a ranking based on the proximity of individual function blocks as a heuristic when searching for dispatcher gadgets.</p>
<h2 id="Assumption-and-threat-model"><a href="#Assumption-and-threat-model" class="headerlink" title="Assumption and threat model"></a>Assumption and threat model</h2><p>Our threat model consists of a binary with a known memory corruption vulnerability that is protected with the state-of-art control-flow hijacking mitigation, such as CFI along with a <em>shadow stack</em>. Futhermore, the binary is also hardened with DEP, ASLR and Stack Canaries.</p>
<p>We assume that the target binary has an arbitrary memory write vulnerability. The attacker can write any value to any (writable) address which called an <em>Arbitrary memory Write Primitive</em> (AWP). To bypass probabilistic defenses such as ASLR, we assume that the attacker has access to an information leak, i.e., a vulnerability that allows her to read any value from any memory address which called <em>Arbitrary memory Read primitive</em> (ARP).</p>
<p>We also assume that there exist an entry point, i.e., a location that the program reaches naturally after completion of all AWPs (and ARPs). Thus BOPC does not require code pointer corruption to reach the entry point. Determining an entry point is considered to be a part of the vulnerability discovery process.</p>
<p>These assumption enable BOPC to inject a payload into a target binary’s address space, modifying its memory state to execute the payload. BOPC assumes that the AWP (and/or ARP) may be triggered multiple times to modify the memory state of the target binary. After the state modification completes, the SPL payload executes without using the AWP (and or ARP) further.</p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ol>
<li>SPL payload</li>
<li>Selecting functional blocks</li>
<li>Searching for dispatcher blocks</li>
<li>Stiching BOP gagdets</li>
</ol>
<p>First, BOPC providing an exploit programming language, called SPL, that enables analysts to define exploits independent of the target program or underlying architecture. Second, to automate SPL gadget discovery, BOPC finds basic blocks from the target program that implement individual SPL statements, called <em>functional blocks</em>. Third, to chain basic blocks together in a manner that adheres with CFI and shadow stacks, BOPC searches the target program for sequences of basic blocks that connect pairs of neighboring functional blocks, which we called <em>dispatcher blocks</em>. Fourth, BOPC simulates the BOP chain to produce a payload that implements that SPL payload from a chosen AWP.</p>
<p>The BOPC design builds on two key ideas: <em>Block Oriented Programming</em> and <em>Block Constraint Summaries</em>. First, BOP constructs exploit programs called BOP chains from basic block sequences in the valid CFG of a target program. Each BOP gadget is one functional block that implements a statement in an SPL payload and zero or more dispatcher blocks that connect the functional block to the next BOP gadget in a manner that compiles with the CFG.</p>
<p>Second, BOPC abstracts each basic block from individual instruction into <em>Block Constraint Summaries</em>, enabling blocks to be employed in a varity of different ways. That is, a single block may perform multiple functional and/or dispatching operations by utilizing different sets of register for different purposes. That is, a basic block that modifies a register in a manner that may fulfill an SPL statement may be used as a functional block, otherwise it may be considered to serve as a dispatcher block.</p>
<p>BOPC leverages Block Constraint Summaries to apply blocks in multiple contexts. There are two cases: either the candidate dispatcher block’s summary constraints indicate that it will modify the register state set and/or the memory state by the functional blocks, called the <em>SPL state</em>, or it will not, enabling the computation to proceed with out disturbing the effects of the functional blocks.</p>
<p>An important distinction between BOP and ROP is that the problem of computing BOP chains is NP-hard. Conventional ROP assumes that indirect control-flow may target any executable byte in memory while BOP must follow a legal path through the CFG for any chain of blocks, resulting in the need of automation.</p>
<h3 id="Expressing-Payloads"><a href="#Expressing-Payloads" class="headerlink" title="Expressing Payloads"></a>Expressing Payloads</h3><p>BOPC provides a programming language, called SPloit language that allows analysts to express exploit payloads in a compact high-level language that independent of target program or processor architecture.</p>
<p>The architecture independence of SPL has important advantages. First, the same payload can be executed under different ISAs or operating systems. Second, SPL uses a set of virtual registers, accessed through reserved volatile variables.</p>
<p>The environment for SPL differs from that of conventional languages. Instead of running code directly on CPU, our compiler encodes the payload as a mapping of instructions to functional blocks. That is, the underlying runtime environment is the target binary and its program state, where payloads are executed as side effects of the underlying binary.</p>
<h3 id="Selecting-functional-blocks"><a href="#Selecting-functional-blocks" class="headerlink" title="Selecting functional blocks"></a>Selecting functional blocks</h3><p>To generate a BOP chain for a SPL payload, BOPC must find a sequnce of blocks that implement each statement in the SPL payload, which called functional blocks.</p>
<p>Conceptually, BOPC must compare each block to each SPL statement to detemine if the block can implement the statement. However, blocks are in terms of machine code and SPL statements are high-level program statements. BOPC computes <em>Block Constraint Summaries</em>, which define the possible impacts that the block would have on SPL state. Block Constraint Summaries provide flexibly in the matching blocks to SPL statements because there are multiple possible mappings of SPL statements and thier virtual registers to the block and its constraints on register and state.</p>
<p>The constraint summaries of each basic block are obtained by isolating and symbolically executing it. The effect of executing a basic block creates a set of constraints, mapping input to the resultant output. Such constraints refer to registers, memory locations, jump types and external operatons(e.g., library calls).</p>
<h3 id="Finding-BOP-gadgets"><a href="#Finding-BOP-gadgets" class="headerlink" title="Finding BOP gadgets"></a>Finding BOP gadgets</h3><p>The combinaton of a functional block and dispatcher blocks is called a <em>BOP gadgets</em>. However, dispatcher paths between two functional blocks may not exist either because there is no legal path in the CFG between them, or the control flow cannot reach the next block due to unsatisfiable runtime constraint.</p>
<p>BOP gadgets are volatile: gadget feasibility changes based on the selection of prior gadgets for the target binary. The problem of selecting a suitable sequence of functional blocks, such as that a dispatcher path exists between every possible control flow tansfer in the SPL payload, is NP-hard.</p>
<p>We propose several heuristics and optimizations to find solutions in reasonable amount of time. BOPC leverages basic block <em>proximity</em> as a metric to “rank” dispatcher paths and organizes this information into a special data structure called a <em>delta graph</em>.</p>
<h3 id="Searching-for-dispatcher-blocks"><a href="#Searching-for-dispatcher-blocks" class="headerlink" title="Searching for dispatcher blocks"></a>Searching for dispatcher blocks</h3><p>While each functional block executes a statement, BOPC must chain multiple functional blocks together to execute the SPL payload. Functional blocks are connected through zero or more basic blocks that do not clobber the SPL state computed thus far.</p>
<p>Finding such blocks is challenging, thus, we propose a graph data structure called <em>delta graph</em>, to represent the state of the search for dispatcher blocks. The delta graph stores, for each functional block, the shortest path to the next candidate blocks.</p>
<p>The delta graph is a multi-partite, directed graph that has a set of functional block nodes for every payload statement. An edge between two functional blocks represents the <em>minimum</em> number of executed basic blocks to move from one functional block to the other, while avoiding clobbering blocks.</p>
<p>Calculating the shortest path between two basics in a CFG faces a challenge: while the CFG statically allow multiple targets, at runtime they are context sensitive and only have an concrete target.</p>
<p>Our context-sensitive shortest path algorithm is a recursive version of Dijkstra’s shortest path algorithm that avoids all clobbering blocks. Initially, each edge on the CFG has a cost of 1. When it encounters a basic block with a call instruction, it recursively calculates the shortest path starting from the calling function’s entry block (Be). if the destination block, Bd, is inside the callee, the shortest path is the concatenation of the two individual shortest paths from the beginning to Be and from Be to Bd. Otherwise, our algorithm finds the shortest path from the Be to the closest return point and uses this value as an edge weight for that callee.</p>
<p>After creation of delta graph, out algorithm selects exactly one node (i.e, functional block) from each set (i.e payload statement) to minimize the total weight of the resulting induced subgraph.</p>
<h3 id="Stiching-BOP-gadgets"><a href="#Stiching-BOP-gadgets" class="headerlink" title="Stiching BOP gadgets"></a>Stiching BOP gadgets</h3><p>To find a dispatcher between two functional blocks, BOPC leverages <em>concolic execution</em>, which collects the required constraints that are needed to lead the execution to the next functional block.</p>
<p>To construct an SPL payload from a BOP chain, BOPC launches concolic execution from the first functional block in the BOP chain, starting with an empty state. At each step BOPC tries the first K shortest dispather path until it finds one that reaches the next functional block. The corresponding constraints are added to the current state. The search therefore incrementally adds BOP gadgets to the BOP chain.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>BOPC requires three distinct inputs:</p>
<ul>
<li>The exploit payload expressed in SPL,</li>
<li>The vulnerable application on top of which the payload runs,</li>
<li>The entry point in the vulnerable application, which is a location that the program reaches naturally and occurs after all AWPs have been completed.</li>
</ul>
<p>The output of BOPC is a sequence of (<em>address</em>, <em>value</em>, <em>size</em>) tuples that describes how the memory should be modified during the state modification phase to execute the payload.</p>
<h3 id="Binary-Frontend"><a href="#Binary-Frontend" class="headerlink" title="Binary Frontend"></a>Binary Frontend</h3><p>Using angr to lift the target binary into the VEX intermediate representation to expose the application’s CFG. Then, we translate each basic block into a block constraint summary. BOPC executes each basic block in an isolated environment, where every action (e.g., register and memory accesses) is monitored. Therefore, instead of working with the instructions of each basic block, BOPC utilizes its abstraction for all operations.(<strong>CFGa</strong>)</p>
<h3 id="SPL-Frontend"><a href="#SPL-Frontend" class="headerlink" title="SPL Frontend"></a>SPL Frontend</h3><p>The SPL Frontend translates the exploit payload into a graph-based <strong>IR</strong> for further processing. For each statement sequence we build a <em>dependence graph</em> based on a customized version of Kahn’s topological sorting algorithm, to infer all groups of independent statements, Which can be executed out-of-order.</p>
<h3 id="Locating-candidate-block-sets"><a href="#Locating-candidate-block-sets" class="headerlink" title="Locating candidate block sets"></a>Locating candidate block sets</h3><p>SPL is a high level language that hides the underlying ABI. Therefore, BOPC finds all possible ways to map individual elements from the SPL environment to the ABI (though candidate blocks).</p>
<p>Once CFGa and IR are generated, BOPC searches for and marks candidate basic blocks. For a block to be a candidate, it must “semantic match” with one (or more) payload statement. Note that variable assignments, unconditional jumps, and returns do not require a basic block and therefore are excluded from the search.</p>
<p>All statement that assign or modify registers require the basic block to apply the same operation on the same. For function calls, the requirement for the basic block is to invoke the same call, either as a system call or as a library call.</p>
<p>Upon a successful matching, BPC builds the following data stuctures:</p>
<ul>
<li><p>The Register Mapping Graph, which is a bipartite undirected graph. The nodes in the two sets represent the virtual and hardware registers respectively. The edges represent potential associations between them.</p>
</li>
<li><p>The Variable Mapping Graph, which associates payload variables to underlying memory addresses.</p>
</li>
<li><p>The Memory Dereference Set, which has all memory addresses that are dereferenced and their values are loaded into registers.</p>
</li>
</ul>
<h3 id="Identifying-functional-block-sets"><a href="#Identifying-functional-block-sets" class="headerlink" title="Identifying functional block sets."></a>Identifying functional block sets.</h3><p>BOPC iteratively identifies, for each SPL statement, which candidate blocks can serve as functional blocks. This step determines for each candidate block if there is a resource mapping that satisfies the block constraints.</p>
<p>BOPC identifiers the concrete set of hardware registers and memory addresses that execute the desired statement.</p>
<p>This step determines, for each statement, which concrete registers and memory addresses are reserved. Merging this information with the set of candidate blocks constructs each block’s SPL state, enabling the removal of candidate blocks that are unsatisfiable.</p>
<h3 id="Selecting-functional-blocks-1"><a href="#Selecting-functional-blocks-1" class="headerlink" title="Selecting functional blocks"></a>Selecting functional blocks</h3><p>Given the functional block set Fb, this step searches for a subset that executes all payload statements. The goal is to select exactly one functional block for every IR statement and find dispather blocks to chain them together.</p>
<p>Once the delta graph is generated, this step locates the minimum induced subgraph, that contains the complete set of functional blocks to execute the SPL payload. If the subgraph does not result in a solution, the algorithm tries the next minimum induced subgraph, until a solution is found or a limit is reached.</p>
<p>If the resulting deleta graph does not lead to a solution, this step “shuffle” out-of-order payload statement and build a new delta graph.</p>
<h3 id="Discovering-dispatcher-blocks"><a href="#Discovering-dispatcher-blocks" class="headerlink" title="Discovering dispatcher blocks"></a>Discovering dispatcher blocks</h3><p>The simulation phase takes the individual functional blocks and tried to find appropriate dispatcher blocks to compose the BOP gadgets. It returns a set of memory assignments for the corresponding dispatcher blocks.</p>
<p>BOPC is called to find a dispatcher path for every edge in the minimum induced subgraph. That is, we need to simulate every control flow transfer in the adjacency matrix of SPL payload. However, dispatchers are built on the binary’s execution state so far, so BOP gadgets must be stiched with the respect to the program’s current flow originating from the entry point.</p>
<p>Finding dispatcher blocks relies on concolic execution. Our algorithm utilizes functional block proximity as a metric for dispatcher path quality. However, it cannot predict which constrains will take exponential time to solve. Therefore, concolic execution selects the K shortest dispatcher paths relative to current BOP chain, and tries them in order until one produces a set of satisfiable constraints.</p>
<p>When simulation starts it also initializes any SPL variables at locations that are reserved during the variable mapping. These addresses are marked as immutable, so any unintended modification raises an exception.</p>
<p>Simulation traverse the minimum induced subgraph, and incrementally extends the SPL state from one BOP gadget to the next, ensuring that newly added constraints remain satisfiable. When encounting a conditional statement, BOPC clones the current state and continues building the trace for both paths independently.</p>
<h3 id="Synthesizing-exploits"><a href="#Synthesizing-exploits" class="headerlink" title="Synthesizing exploits"></a>Synthesizing exploits</h3><p>If the simulation module returns a solution, the final step is to encode the execution trace as a set of memory writes in the target binary.</p>
<h2 id="Discussion-and-future-work"><a href="#Discussion-and-future-work" class="headerlink" title="Discussion and future work"></a>Discussion and future work</h2><p>BOPC is limited by the granularity of basic blocks. That is, a combination of basic blocks could potentially lead to execution of a desired SPL statement, while individual blocks might not.</p>
<p>BOPC sets several upper bounds defined by user inputs. These configurable bounds include the upper limit of (i) SPL payload permutations P, (2) length of continuous block L, (3) of minimum induced subgraphs extracted from the delta graph N, (4) dispatcher paths between a pair of functional blocks K. These upper bounds along with the timeout for symbolic execution, reduce the search space, but prune some potentially valid solutions.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/Data-Oriented-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/23/Data-Oriented-Programming/" class="post-title-link" itemprop="url">Data-Oriented Programming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-03-23 16:38:19" itemprop="dateCreated datePublished" datetime="2019-03-23T16:38:19+08:00">2019-03-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Control-flow hijacking attacks are the predominant category of memory exploits today. In response, numerous principled defenses which aim to ensure legal control flow has been proposed.</p>
<p>A natural question is to analyze the limits of protection offered by control-flow defenses, and the remaining capabilities of the adversary. Control-flow defenses aim to ensure the execution of the program stay legitimate, by protecting the integrity of the <em>control plane</em> memory of by directly checking the targets of control transfers. However, the data plane of memory can offer an additional source of advantage for adversaries (e.g., <em>non-control data attacks</em>).</p>
<p>In this paper, we show that non-control data attacks with rich expressiveness can be crafted using systematic construction techniques. The key idea in our contribution is to find <em>data-oriented gadgets</em>. then we find <em>gadget dispatchers</em> which are fragment of logic that chain together disjoint gadgets in an arbitrary sequence.</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Non-control-Data-Attacks"><a href="#Non-control-Data-Attacks" class="headerlink" title="Non-control Data Attacks"></a>Non-control Data Attacks</h3><p>Non-control data attacks tamper with or leak security-sensitive memory, which is not directly used in control-flow transfer instruction.  The attack payloads, however, exhibit limited expressiveness, such as writing a target variable of choice or leaking contents of a sensitive memory region. Such simple payloads can enable privilege escalation and sensitive data-leakage attacks.</p>
<p>However, non-control data attacks cannot divert the control flow to arbitrary location, unlike ROP attacks, the expressiveness is believed to be very limited.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>In fact, non-control data attacks can offer rich exploits from common vulnerabilities.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">server</span>&#123;</span> <span class="keyword">int</span> * cur_max, total, typ;&#125; *srv;</span><br><span class="line"><span class="keyword">int</span> connect_limit = MAX_CONN; <span class="keyword">int</span> *size, *type;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLEN];</span><br><span class="line">size = &amp;buf[<span class="number">8</span>]; type = &amp;buf[<span class="number">12</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (connect_limit--) &#123;</span><br><span class="line">  readData(socketfd, buf);        <span class="comment">// stack bof</span></span><br><span class="line">  <span class="keyword">if</span> (*type == NONE)  <span class="keyword">break</span>;      </span><br><span class="line">  <span class="keyword">if</span> (*type == STREAM) &#123;          <span class="comment">// condition</span></span><br><span class="line">    * size = * (srv -&gt; cur_max);  <span class="comment">// dereference</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    srv -&gt; typ = * type;          <span class="comment">// assignment</span></span><br><span class="line">    srv -&gt; total += * size;       <span class="comment">// addition</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code does not invoke any security-critical functions in its benign control-flow, and the vulnerability just corrupts a handful of local variables.</p>
<p>The assignment, dereference and the addition operation can be considered as <em>data-oriented gadgets</em>. The loop structure is called <em>gadget dispatchers</em>.</p>
<h2 id="Data-Oriented-Programming"><a href="#Data-Oriented-Programming" class="headerlink" title="Data-Oriented Programming"></a>Data-Oriented Programming</h2><h3 id="DOP-Overview"><a href="#DOP-Overview" class="headerlink" title="DOP Overview"></a>DOP Overview</h3><p>The key is to manipulate non-control data such the executed instructions do the attacker’s bidding. In order to give a concrete and systematic construction, we define a simple mini-language called MINDOP with a virtual instruction set and virtual register operands, in which payload we can specific.</p>
<p>The MINDOP language has 6 kinds of virtual instructions, each operating on virtual register operands. Each virtual operation is simulated by real x86 instruction sequences available in the vulnerable program, which we call data-oriented gadgets. The control structure allows chaining of gadgets, and the x86 code sequences that simulate the virtual control operations are referred to as gadget dispatchers. None of the gadgets or dispatchers modify any code-pointers or violate CFI in the real program execution.</p>
<table>
<thead>
<tr>
<th>Semantics</th>
<th align="center">Instructions in C</th>
<th align="center">Data-Oriented Gadgets in DOP</th>
</tr>
</thead>
<tbody><tr>
<td>arithmetic/logical</td>
<td align="center">a op b</td>
<td align="center">*p op *q</td>
</tr>
<tr>
<td>assignment</td>
<td align="center">a = b</td>
<td align="center">*p = *q</td>
</tr>
<tr>
<td>load</td>
<td align="center">a = *b</td>
<td align="center">*p = **q</td>
</tr>
<tr>
<td>store</td>
<td align="center">*a = b</td>
<td align="center">**p = *q</td>
</tr>
<tr>
<td>jump</td>
<td align="center"><strong>goto</strong> L</td>
<td align="center">vpc = &amp;input</td>
</tr>
<tr>
<td>conditional jump</td>
<td align="center"><strong>if</strong> a <strong>goto</strong> L</td>
<td align="center">vpc = &amp;input if *p</td>
</tr>
</tbody></table>
<h3 id="Data-Oriented-Gadgets"><a href="#Data-Oriented-Gadgets" class="headerlink" title="Data-Oriented Gadgets"></a>Data-Oriented Gadgets</h3><p>Virtual operations in MINDOP are simulated using concrete x86 instruction sequences in the vulnerable program execution. Such instruction sequences or gadgets read inputs from and write output to memory locations which simulate virtual register operands in MINDOP. Gadgets is within the legitimate CFG of the program, therefore, between two gadgets there maybe several uninteresting instructions which out of the attacker’s control.</p>
<p>Conceptually, a data-oriented gadget simulates three logical micro-operations: the load micro-operation, the intended virtual operation’s semantics, which are different for each gadget, and the final store micro-operation.</p>
<table>
<thead>
<tr>
<th>C code</th>
<th align="left">srv -&gt; total += *size</th>
</tr>
</thead>
<tbody><tr>
<td>ASM Code</td>
<td align="left">1. mov (%esi), %ebx &emsp;// load micro-op<br> 2. mov 0x4(%edi), %eax  &emsp;// load micro-op<br> 3. add %ebx, %eax &emsp;// addition <br> 4. mov %eax, 0x4(%edi) &emsp;//store micro-op</td>
</tr>
</tbody></table>
<p>Data-oriented gadgets are similar to code gadgets employed in return-oriented programming or in jump-oriented programming. However, there are two differences between data-oriented gadgets and code gadgets. First, data-oriented gadgets require to deliver operation result with memory. Second, data-oriented gadgets must execute in at least one legitimate control flow, and need not execute immediately one after another.</p>
<p><strong>Simulating Arithmetic Operations.</strong> With addition over arbitrary values, it is possible to simulate multiplication efficiently if the language supports conditional jumps. MINDOP supports conditional jumps which allow to check if a value is smaller / greater than a constant. This can help us to compute the bit-decomposition of a finite-size integer. With bit-decomposition, simulating a multiplication a * b reduces to the efficient shift-and-add procedure, adding a to itself in each step conditional on the bits in b.</p>
<p><strong>Simulating Assignment Operations.</strong> In MINDOP, assignment gadgets read data from one memory location and directly write to another memory location, e.g., load -&gt; move -&gt; store.</p>
<p><strong>Simulating Dereference (Load/Store) Operations.</strong> In data-oriented programming. registers are simulated by memory, therefore the memory dereference is simulated by two memory dereferences.</p>
<h3 id="Gadget-Dispatcher"><a href="#Gadget-Dispatcher" class="headerlink" title="Gadget Dispatcher"></a>Gadget Dispatcher</h3><p>Various gadgets can be chained sequentially by gadget dispatchers to enable recursive computation. Gadget dispatchers are sequences of x86 instructions that equip attackers with the ability to repeat gadget invocations and, for each invocation, to selectively activate specific gadgets.</p>
<p>Each iteration executes a subset of gadgets using outputs from gadgets in the previous iteration, which done by change the load address if iteration i+1 to the store addresses of iteration i. Additionally, the selector’s behavior is controlled by attackers through the memory error. The corruption is done in a way that it enables only the gadgets of the attacker’s choice. These gadgets take as input the outputs of the previous round’s gadget by selectively corrupting operand pointers. The remaining gadgets may still get executed, but their inputs and outputs are set up such that they behave like NOPs.</p>
<p>An <em>interactive</em> attack means attacker can prepare the memory state at the start of loop iteration i in a way that the desired gadget works as required and other gadgets operate on unused memory.</p>
<p>Another class of DOP attacks are <em>non-interactive</em>, whereby the attacker provides the entire malicious input as a single data transmission. In such a scenario, all the memory setup and conditions for deciding loop termination and selective gadget activation need to be encoded in a single malicious payload. To support such attacks, MINDOP has two virtual operations that enable conditional chaining of operations, or virtual jumps. The basic idea is as follows: the attacker provides the memory configuration Mj necessary for each gadget j to be selectively executed in a particular iteration in the input payload. In addition, it keeps a pointer called <em>virtual PC</em> which points to the desired configuration Mj at the start of each iteration. It suffices to corrupt only the virtual PC, so that the program execution in that iteration operates on the configuration Mj. To decide how to switch to Mk in the next instruction, MINDOP provides virtual operations that set the virtual PC, conditionally or unconditionally.</p>
<p><strong>Simulating Jump Operations.</strong> The key here is to identify a suitable variable to implement a virtual PC which can be corrupted in each loop iteration. To simulate an unconditional jump, attackers just prepare the memory configuration to trigger another operation gadget (e.g., addition, assignment) to change the value of the virtual PC.</p>
<h2 id="DOP-Attack-Construction"><a href="#DOP-Attack-Construction" class="headerlink" title="DOP Attack Construction"></a>DOP Attack Construction</h2><h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h3><p>Though the concept of data-oriented programming is intuitive, it is challenging to construct data-oriented attacks in real-world programs:</p>
<ul>
<li><p><strong>Data-oriented gadget identification.</strong> We use static analysis as an aid in identifying these gadgets.</p>
</li>
<li><p><strong>Gadget dispatcher identification.</strong> Our gadget dispatcher requires a loop with various gadgets and a selector controlled by the memory error. But it is possible to have the selector and gadgets inside the functions called from loop body.</p>
</li>
<li><p><strong>Data-oriented gadget stitching.</strong> The reachability of gadgets depends on concrete memory errors. We need to find malicious input that makes the program execute selected gadgets with the expected addresses and order.</p>
</li>
</ul>
<h3 id="Gadget-Identification"><a href="#Gadget-Identification" class="headerlink" title="Gadget Identification"></a>Gadget Identification</h3><p>A useful data-oriented gadget needs to satisfy the following requirements:</p>
<ul>
<li><strong>MINDOP semantics.</strong> It should have instructions for the load micro-operation, the store micro-operation, and others simulating semantics of MINDOP.</li>
<li><strong>Gadget internal order.</strong> The three micro-operations should appear in the load-operation-store order, and this correct order should show up in at  least one legitimate control flow.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:  G:- the vulnerable program</span><br><span class="line">Output: S:- data-oriented gadget <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">S = ∅;</span><br><span class="line">FuncSet = getFuncSet(G)</span><br><span class="line">foreach f ∈ FuncSet <span class="keyword">do</span></span><br><span class="line">    cfg = getCFG(f)</span><br><span class="line">    <span class="keyword">for</span> instr = getNextInstr(cfg) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> isMemStore(instr) then</span><br><span class="line">            gadget = getBackwardSlice(instr, f)</span><br><span class="line">            input = getInput(gadget)</span><br><span class="line">            <span class="keyword">if</span> isMemLoad(input) then</span><br><span class="line">                S = S ∪ &#123;gadget&#125;</span><br></pre></td></tr></table></figure>

<p>We compile the program source code into LLVM intermediate representation (IR) and perform our analysis on LLVM IR. Our analysis iterates through all functions in the program. We treat each store instruction in the function as a store micro-operation of a new potential gadget. Then our analysis uses a backward data-flow analysis to identify the definitions of the operands in the store instruction. The generated data-flow contains the instructions that derive the operands, like loaded from memory or calculated from registers.</p>
<p><strong>Gadget Classification.</strong> We classify data-oriented gadgets into different categories based on their semantics and computed variables. Gadgets with the same semantics are functional-equivalent to simulate one MINDOP operation. <strong>There are no function call gadgets in data-oriented programming, as it does not change the  control data.</strong> Based on the computed variables, we further classify gadgets into three categories: <em>global gadget</em>, <em>function-parameter gadget</em> and <em>local gadget</em>.</p>
<h3 id="Dispatcher-Identification"><a href="#Dispatcher-Identification" class="headerlink" title="Dispatcher Identification"></a>Dispatcher Identification</h3><p>We use static analysis on LLVM IR for the initial pharse of dispatcher identification. Since loops are necessary for attackers to repeatedly connect gadgets, we first identify all possible loops in the program. For each loop, we scan the instructions in the loop body to find interesting gadgets. For function calls within the loop, we step into functions through the call graph and iterate through all instruction inside.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: G:- the vulnerable program</span><br><span class="line">Output: D:- gadget dispatcher <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">D = ∅;</span><br><span class="line">FuncSet = getFuncSet(G)</span><br><span class="line">foreach f ∈ FuncSet <span class="keyword">do</span></span><br><span class="line">    foreach loop = getLoop(f) <span class="keyword">do</span></span><br><span class="line">        loop.gadgets = ∅</span><br><span class="line">        foreach instr = getNextInstr(loop) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> isMemStore(instr) then</span><br><span class="line">                loop.gadgets ∪= getGadget(instr)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> isCall(instr) then</span><br><span class="line">                target = getTarget(instr)</span><br><span class="line">                loop.gadgets ∪= getGadget(target)</span><br><span class="line">        <span class="keyword">if</span> loop.gadgets != ∅ then</span><br><span class="line">            D = D ∪ &#123;loop&#125;</span><br></pre></td></tr></table></figure>

<p>The second phase of dispatchers identification correlates the identified dispatcher candidates with a known memory error. In this phase, we use a static-dynamic approach to provide identification results with varying degrees of coverage and precision. We mark a loop as reachable if it enfolds the given memory error.</p>
<h3 id="Attack-Construction"><a href="#Attack-Construction" class="headerlink" title="Attack Construction"></a>Attack Construction</h3><p>For a given concrete memory error, the available gadgets and dispatchers rely on the location of the vulnerable code in the program, while the stitchability of gadgets depends on the corruptibility of the memory error. To connect two disjoint data-oriented gadgets, attackers should have the control over the address in the load micro-operation of the second gadget or the address in the store micro-operation of the first gadget.</p>
<ol>
<li><p><strong>Gadget preparation (semi-automated).</strong> Given a memory error, we locate the vulnerable function from the source code. Then we identify the gadget dispatchers that enfold the vulnerable code and collect data-oriented gadgets.</p>
</li>
<li><p><strong>Exploit chain construction (Manual).</strong> We take the expected malicious MINDOP program as input.</p>
</li>
<li><p><strong>Stichability verification (Manual).</strong> We feed concrete input to the program to trigger memory errors to connect expected gadgets.</p>
</li>
</ol>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Feasibility-of-DOP"><a href="#Feasibility-of-DOP" class="headerlink" title="Feasibility of DOP"></a>Feasibility of DOP</h3><p>We study 9 applications and measure how many x86 gadgets in these programs can simulate MINDOP operations. We aim to evaluate the following four aspects in our analysis:</p>
<ul>
<li>Empirically justify the choice of operations in MINDOP based on the prevalence of x86 gadgets.</li>
<li>Study the distribution of various types of gadgets based on the scope of input operands.</li>
<li>Measure the reachability of these x86 gadgets in concrete executions in presence of an exploitable memory corruption.</li>
<li>Verify if the memory error (in the public CVEs) have the capability to control the input operands and activate the gadgets in concrete executions.</li>
</ul>
<p><strong>Gadgets classification.</strong> We classify data-oriented gadgets into three categories based on the scope of the operands, such as global gadgets, function-parameter gadgets and hybrid gadgets</p>
<p><strong>Execution reachability from memory errors.</strong> We run the vulnerable program with given CVE PoC to get dynamic function call trace, including the vulnerable function. From function call trace, we identify the function invoked by the vulnerable function during the execution. The gadgets inside the invoked function and enfolding loops are the reachable gadgets from the dispatcher.</p>
<h3 id="Turing-Complete-examples"><a href="#Turing-Complete-examples" class="headerlink" title="Turing-Complete examples"></a>Turing-Complete examples</h3><p>ProFTPD is a file server and it’s 1.2-1.3 versions have a stack-based buffer overflow vulnerability in the sreplace function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sreplace</span><span class="params">(<span class="keyword">char</span> *s, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *src; *cp, **mptr, **rptr;</span><br><span class="line">    <span class="keyword">char</span> *marr[<span class="number">33</span>], *rarr[<span class="number">33</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[PR_TUNABLE_PATH_MAX] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;;</span><br><span class="line">    src = s; cp = buf; mptr = marr; rptr = rarr;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (*src) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; *mptr; mptr++, rptr++) &#123;</span><br><span class="line">            sstrncpy(cp, *rptr, blen - <span class="built_in">strlen</span>(pbuf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*memory error &amp; assignment*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Conditional assignment operation. We use the sstrncpy function to simulate an assignment which moves data from on arbitrary location to another. In the first iteration of the while loop, the memory error corrupts the variable cp and the content of the array rarr. So in the next iteration, both the source and the target of the string copy sstrncpy are controlled by the attacker. This way, the attacks simulate a assignment operation which is conditional because the attacker can corrupt src.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pr_display_file</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    outs = sreplace(p, buf, ..., <span class="string">&quot;%V&quot;</span>, main_server -&gt; ServerName,);</span><br><span class="line">    pr_response_send_raw(<span class="string">&quot;%s-%s&quot;</span>, code, outs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_response_send_raw</span><span class="params">(<span class="keyword">const</span> chat *fmt, ...)</span> </span>&#123;</span><br><span class="line">    vsnprintf(resp_buf, size, fmt, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Dereference operations(Load/Store). The load operations takes two memory addresser as input(p and q) and performs operation *p == ** q. We decompose the operation into two sub-operations: * ptmp = * q and * p = * tmp, such that the ptmp is the address of tmp. We use the assignment gadgets to move data from resp_buf to &amp;ServerName as the first dereference. Then we use the fuction pr_display_file, which reads the contents of ServerName to the buffer resp_buf as the second dereference. These two dereference from MINDOP load operation *resp_buf = ** resp_buf.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MODRET <span class="title">xfer_log_retr</span><span class="params">(cmd_rec *cmd)</span> </span>&#123;</span><br><span class="line">    session.total_bytes_out += session.xfer.total_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Addition operation. The structure session is a global variable and hence all the operands of this gadget are under attacker’s control. To achieve an addition operation on arbitrary memory locations, we use the MINDOP assignment operation to load operands from desired source locations to the session structure, perform the addition, and then move the result to the desired destination location.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_loop</span><span class="params">( server)</span>rec * server, <span class="keyword">conn_t</span> *c) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (True) &#123;</span><br><span class="line">        pr_netio_telnet_gets(buf, ..);</span><br><span class="line">        cmd = make_ftp_cmd(buf, ...);</span><br><span class="line">        pr_cmd_dispatch(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">pr_netio_telnet_gets</span><span class="params">(<span class="keyword">char</span> * buf, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (* pbuf -&gt; current != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; toread &gt; <span class="number">0</span>)</span><br><span class="line">        * buf++ = * pbuf -&gt; current++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(Conditional) jump operation. pbuf -&gt; current is a pointer to next command in the input, thus forming a virtual PC for attacker’s MINDOP program. By corrupting  pbuf -&gt; current, the attacker can select a particular input that invokes a specific MINDOP operation. We use assignment operation to conditionally update virtual PC, thus simulating a conditional jump operation.</li>
</ul>
<hr>
<p>Wireshark is a widely used network packet analyzer and its versions before 1.80 have a stack-based buffer overflow vulnerability. The buffer pd in function packet_list_dissect_and_cache_record accepts frame data from a mpeg trace file. If the attacker sends a malicious trace file containing a large frame, the frame data overflows the buffer. This is used to overwrite variables col, cinfo, and parameter packet_list with malicious input.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_list_dissect_and_cache_record</span> <span class="params">(PacketList * packet_list, ...)</span> </span>&#123;</span><br><span class="line">    gint col; column_info * cinfo;</span><br><span class="line">    guint8 pd[WTAP_MAX_PACKET_SIZE];    <span class="comment">// vul buf</span></span><br><span class="line">    <span class="comment">// memory error function</span></span><br><span class="line">    cf_read_frame_r(..., fdata, ..., pd);</span><br><span class="line">    packet_list_change_record(packet_list, ..., col, cinfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_list_change_record</span><span class="params">(PacketList * packet_list, ..., gint col, column_info * cinfo)</span> </span>&#123;</span><br><span class="line">    record = packet_list -&gt; physical_rows[row];</span><br><span class="line">    record -&gt; col_text[col] = (gchar * )cinfo -&gt; col_data[col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!record-&gt; col_text_len[col])</span><br><span class="line">        ++packet_list -&gt; const_strings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtk_tree_view_column_cell_set_cell_data</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (cell_list = tree_column -&gt; cell_list; cell_list;</span><br><span class="line">         cell_list = cell_list -&gt; next) &#123;</span><br><span class="line">             ...</span><br><span class="line">             <span class="comment">// finally calls vulnerable function</span></span><br><span class="line">             show_cell_data_func();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Assignment operation. Line <code>record -&gt; col_text[col] = (gchar * )cinfo -&gt; col_data[col];</code> shows the gadget. The attacker corrupts record and cinfo to point to controllable memory location.</p>
</li>
<li><p>Dereference operation(Load / Store). To simulate a load operation, the attacker corrupts record-&gt;col_text and cinfo. To simulate a store operation, the attacker can change the value of record and cinfo-&gt;col_data.</p>
</li>
<li><p>Conditional addition operation. <code>if (!record-&gt; col_text_len[col])</code> and <code>++packet_list -&gt; const_strings;</code> if the attacker corrupts packet_list, she can invoke it to perform add operation on the target location.</p>
</li>
<li><p>Conditional jump operation. The memory error is triggered by the file read, and the program maintains a file position indicator in the FILE structure. The attacker can change the file position indicator which serves as a virtual PC.</p>
</li>
</ul>
<p>To chain a large number of gadgets together, we identify a gadget dispatcher from the parent function <code>gtk_tree_view_column_cell_set_cell_data</code>. In the first invocation of the memory error, the attacker uses the assignment operation to corrupt the loop condition cell_list, and points it to a fake linked-list in the malicious payload, making it an infinite loop.</p>
<h3 id="Why-are-expressive-payload-useful"><a href="#Why-are-expressive-payload-useful" class="headerlink" title="Why are expressive payload useful"></a>Why are expressive payload useful</h3><p><strong>Bypassing Randomization Defenses.</strong> We show how to defeat ASLR with DOP without leaking any addresses to the network. As a real example, consider the vulnerable ProFTPD server, which internally uses OpenSSL for authentication. Our goal is to leak the server’s OpenSSL private key. We found that the private key has a chain of 8 pointers pointing the private key buffer.</p>
<p>The key idea is to use a short MINDOP virtual program that starts from the base pointer (of known location) and dereference it 7 times within the server’s memory to correctly determine the randomized location of the private key. Once we have the private key buffer’s address, we simply replace an address used by a public output function, causing it to leak the private data to the network.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/The-Guard-s-Dilemma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/25/The-Guard-s-Dilemma/" class="post-title-link" itemprop="url">The Guard's Dilemma</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-02-25 17:28:09" itemprop="dateCreated datePublished" datetime="2019-02-25T17:28:09+08:00">2019-02-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>SGX isolates sensitive code and data from the OS, hypervisor, BIOS and other applications. Besides, SGX code and data is always encrypted as soon as it leaves the CPU. sensitive data, e.g. cryptographic keys, of applications is protected by SGX containers called <em>enclaves</em>, which can be dynamiclly created while the applications, known as <em>hosts</em>, is running. enclaves provide predefined entry points to hosts performing sensitive computation.</p>
<p>Ideally, the enclave code only includes minimal carefully-inspected code, which could be formally proven to be free of vulnerabilities. However, legacy applications can be adapted as well to run inside SGX enclaves with necessary modifications. Formally proving or manually inspecting legacy applications is not feasible, meaning that memory corruption vulnerabilities occurs in enclaves with high probability.</p>
<p>Recently, Dark-ROP[1] was proposed to leverage memory-corruption against SGX. Dark-ROP is based on several oracles, which inform the attackers about the internal status of encalves, and return-oriented programming. However, Dark-ROP requires a non-randomized memory layout to locate secret code and data after crashing. Therefore, an implementation of SGX randomization called SGX-Shield[2] mitigates Dark-ROP attack.</p>
<p>However, SGX-Shield does not randomize the part of SGX SDK that handles transitions between host code and enclave code, which contains a number of <em>gadgets</em> to mount a ROP attack. This paper demonstrates that the interface code is enough to mount powerful run-time attacks and bypass SGX-Shield without requiring kernel privileges.</p>
<h2 id="The-Guard’s-Dilemma"><a href="#The-Guard’s-Dilemma" class="headerlink" title="The Guard’s Dilemma"></a>The Guard’s Dilemma</h2><p>Controlling registers is essential in any code-reuse attack, which can prepare data for subsequent gadgets or set arguments for function calls. Thus, attackers always use specific register-setting gadgets, e.g. <em>pop gadgets</em>, to control registers. But, this paper allows attacker to use whole functions in tRTS as building blocks instead of small gadgets. Here lies the dilemma: the SDK is an important part in creating enclaves, but in this case it is actually exposing them to attacks.</p>
<p>two new exploitation primitives:</p>
<ul>
<li><strong>The ORET primitive</strong> allows attacker to gain access to a critical set of CPU registers by exploiting a stack overflow vulnerability.</li>
<li><strong>The CONT primitive</strong> allows attacker to gain access to all general-purpose registers, with the control of a register (on x86_64, rdi).</li>
</ul>
<h3 id="Overview-and-Attack-Workflow"><a href="#Overview-and-Attack-Workflow" class="headerlink" title="Overview and Attack Workflow"></a>Overview and Attack Workflow</h3><h4 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h4><ul>
<li><p><strong>ORET primitive.</strong> asm_oret function is used to restore the CPU context after a OCALL. Once the attacker control the instruction pointer(hijacking control flow) and stack contents, e.g. stack overflow or format string, she can set a subset of CPU registers, e.g. rdi, rip.</p>
</li>
<li><p><strong>CONT primitive.</strong>  continue_execution function is meant to restore CPU context after an exception. The prerequisite is calling this function with a controlled rdi register, e.g. exploiting a memory corruption affecting a function pointer. The attacker can control over all general-purpose CPU registers.</p>
</li>
<li><p><strong>ORET+CONT loop.</strong> the basic idea behind the attack is to use CONT primitive repeatedly to invoke the various gadgets with correct register values.</p>
</li>
</ul>
<p>Each iteration of this loop executes one gadget and is stuctured as follows:</p>
<ol>
<li>A CONT primitive manipulates the stack pointer to hijack it into attack-controlled memory and executes a gadget.</li>
<li>Once the gadget completes, the previous stack manipulation cause the execution of an ORET primitive.</li>
<li>The ORET primitive triggers the CONT primitive for next gadget, continuing the cycle from the first step.</li>
</ol>
<h4 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h4><ol>
<li><p>Payload preparation<br>The attack performs static analysis on the enclave binary to determine the gadgets in the non-randomized part of binary, e.g. tRTS. Next, she construct a gadgets chain and defines the register states that should be set before executing each gadget, e.g. function argument register. According to Threat Model, attacker knows the memory address layout, including enclave binary offset. Also, she has to determine the offset of asm_oret and continue_execution(both in tRTS).</p>
</li>
<li><p>Fake structures preparation<br>The primitives work by abusing functions intended to restore CPU contexts by tricking them into restore fake contexts. Contrast to a standard ROP exploit, attacker requires a number of memory structures to hold the fake context and execution primitives.</p>
</li>
</ol>
<ul>
<li><p>Multiple fake exception information structures</p>
</li>
<li><p>Fake stack is a supporting structure for the ORET+CONT loop that serves two purpose. On the one hand, it is used to bring control back to an ORET primitive after a gadget executes. On the other one hand, it contains fake context for the transition from the ORET primitive to the CONT primitive to continue the loop.</p>
</li>
</ul>
<ol start="3">
<li>Attack execution<br>When the vulnerability satisfies the CONT preconditions (e.g., exploitation of an indirect function call), the attacker can execute the first CONT directly. When the vulnerability satisfies the ORET preconditions (e.g., stack overflow), the attacker can set the first function argument register and the instruction pointer.</li>
</ol>
<h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><h4 id="ORET-Primitives"><a href="#ORET-Primitives" class="headerlink" title="ORET Primitives"></a>ORET Primitives</h4><p>ORET primitive abuses the asm_oret function to restore CPU context from the OCALL frame saved on the stack. The prototype of this function is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sgx_status_t</span> <span class="title">asm_oret</span><span class="params">(<span class="keyword">uintptr_t</span> sp, <span class="keyword">void</span> *ms)</span></span>;</span><br></pre></td></tr></table></figure>
<p>the first argument (sp) points to the OCALL frame, which contains the partial CPU context to be restored, including saved values for rbp, rdi, rsi, and r12 to r15.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ocall_context_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> r15;</span><br><span class="line">  <span class="keyword">uintptr_t</span> r14;</span><br><span class="line">  <span class="keyword">uintptr_t</span> r13;</span><br><span class="line">  <span class="keyword">uintptr_t</span> r12;</span><br><span class="line">  <span class="keyword">uintptr_t</span> xbp;  <span class="comment">//rbp</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> xdi;  <span class="comment">//rdi</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> xsi;  <span class="comment">//rsi</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> xbx;  <span class="comment">//rbx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> ocall_ret</span><br><span class="line">&#125; <span class="keyword">ocall_context_t</span>;</span><br></pre></td></tr></table></figure>
<p>Attacker able to control the OCALL frame can set all registers mentioned; moreover, the new instruction pointer (rip) can also be set.</p>
<p>The values of rsp and rip after asm_oret depend on the SGX SDK version. For versions earlier than 2.0, the stack pointer is set to point to the ocall_ret field before issuing a ret instruction. Hence, the new instruction pointer will be the value of ocall_ret, and the new stack pointer will pointer to the memory location immediately following the OCALL frame.</p>
<p>From the version 2.0, a more traditional epilogue is used: the base pointer(rbp) is moved into rsp, the rbp is popped from the stack, and finally a ret is issued. Therefore, rbp in the OCALL frame points to a memory area containing two 64-bit words: the new value for rbp, and the return address(new instruction pointer).</p>
<p>The first operation done by asm_oret is shifting rsp to the sp argument, i.e., the top of OCALL frame. A attacker can jump to the code after the function prologue and let asm_oret believe that the OCALL frame is at the top of the current stack. It is always possible to abuse asm_oret to restore a fake OCALL frame at the top of the stack, without the need to control the first argument, by jumping to an appropriate instruction inside asm_oret.</p>
<p>An attacker who has control over the stack contents can reuse asm_oret to set the registers. The application is vulnerable to a buffer overflow error on the stack. The attacker exploits this to overwrite the return address with the address of asm_oret, properly adjusted to account for skipped instructions. Moreover, she places a fake ocall_context_t immediately after the return address. Once function call returns, control is transferred to asm_oret with the fake OCALL frame at the top of stack.</p>
<h4 id="CONT-Primitive"><a href="#CONT-Primitive" class="headerlink" title="CONT Primitive"></a>CONT Primitive</h4><p>The CONT primitive is based on exception handle function continue_execution, which used to restore CPU context from a exception information structure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue_execution(<span class="keyword">sgx_exception_info_t</span> *info);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sgx_exception_info_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">sgx_cpu_context_t</span>       cpu_context;</span><br><span class="line">  <span class="keyword">sgx_exception_vector_t</span>  exception_vector;</span><br><span class="line">  <span class="keyword">sgx_exception_type_t</span>    exception_type;</span><br><span class="line">&#125;<span class="keyword">sgx_exception_info_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">cpu_context_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  rax;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rcx;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rdx;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rbx;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rsp;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rbp;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rsi;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rdi;</span><br><span class="line">  <span class="keyword">uint64_t</span>  r8;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  r15;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rflags;</span><br><span class="line">  <span class="keyword">uint64_t</span>  rip;</span><br><span class="line">&#125; <span class="keyword">cpu_context_t</span>;</span><br></pre></td></tr></table></figure>
<p>Note that the stack pointer(rsp) and the instruction pointer(rip) are part of this context, attacker can control stack pointer and hijack it to attacker-controled memory(<em>fake stack</em>). This technique is known as <em>stack pivoting</em>.</p>
<p>As a example, continue_execution can be reused by corrupting a function pointer and hijacking it to it, moreover the attacker needs to control rdi or the memory pointed to by rdi.</p>
<h4 id="Fake-stack"><a href="#Fake-stack" class="headerlink" title="Fake stack"></a>Fake stack</h4><p>The fake stack is used to chain CONT to ORET, and it is composed of a sequences of frames, which consists of the address of asm_oret(properly adjusted) followed by an ocall_context_t structure. The CONT in the loop invokes a gadget with stack pointer set to the top of fake stack. The address of asm_oret will be at the top of the stack before gadget return. Therefore, the gadget will return to asm_oret, launching an ORET primitive and restore the fake context from frame. The fake context is set up so the rdi points to a fake exception structure and the instruction pointer is set to continue_execution.</p>
<h4 id="Fake-exception-information"><a href="#Fake-exception-information" class="headerlink" title="Fake exception information"></a>Fake exception information</h4><p>For each gadget, the attack sets up a fake sgx_exception_info_t structure with desired register values and instruction pointer to the gadget’s address. The stack pointer is set to the top of fake stack.</p>
<h2 id="Attacking-SGX-Shield"><a href="#Attacking-SGX-Shield" class="headerlink" title="Attacking SGX-Shield"></a>Attacking SGX-Shield</h2><h3 id="Overview-on-SGX-Shield"><a href="#Overview-on-SGX-Shield" class="headerlink" title="Overview on SGX-Shield"></a>Overview on SGX-Shield</h3><ul>
<li>Fine-grained randomization</li>
<li>Software DEP</li>
<li>Software Fault Isolation</li>
<li>Coarse-grained Control Flow Integrity</li>
</ul>
<p>Because SGX-Shield needs writable code pages during loading, the enclave code will stay writable for the whole enclave’s lifecycle.</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p><strong>Assumption:</strong> a stack overflow vulnerability in the enclave.<br><strong>Observation:</strong> SGX-Shield enclaves feature writable code pages.<br><strong>Idea:</strong> the first stage, based on code reuse, injects the second-stage code, also known as <em>shellcode</em>.</p>
<h3 id="First-stage"><a href="#First-stage" class="headerlink" title="First stage"></a>First stage</h3><ol>
<li><p><strong>Payload preparation.</strong> The attacker starts by determining the offsets of asm_oret and continue_execution. Next, for the code-injection attack, the attackers needs a gadget (from do_rdrand function in tRTS) to write to memory.</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, (<span class="built_in">rcx</span>)</span><br><span class="line"><span class="keyword">mov</span> <span class="number">1</span>  , <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>Our chain repeatedly invoke this gadget to write the shellcode 4 bytes a time. The address to place the shellcode at is taken from the writeable SGX-Shield code pages.</p>
</li>
<li><p><strong>Fake structures preparation.</strong> The attacker starts by creating a fake stack that contains the address of continue_execution repeated n-1 times, where n is the number of gadgets in the chain. A sgx_exception_info_t structure is set up for all registers, with rip is set up for the shellcode’s address and the other registers at the attacker’s discretion.</p>
</li>
<li><p><strong>Attack execution.</strong> The attacker triggers the stack overflow in the enclave. She overwrites a return address with the address of asm_oret, and place a fake ocall_context_t after the address. The ocall_ret set to the address of continue_execution and the rdi set to the fake sgx_exception_info_t as the argument. This will result in continue_execution being called on fake exception structure, which starts the chain. The fake exception structure set up the rip to gadget’s address, the rax and rcx to proper value to place attacker’s code in SGX-Shield code pages. The rsp will point at fake stack, which are all continue_execution.</p>
</li>
</ol>
<h3 id="Second-stage"><a href="#Second-stage" class="headerlink" title="Second stage"></a>Second stage</h3><p>The Shell code has full control over the enclave. In this case, attacker extract cryptographic keys used during remote attestation process through the shellcode. Therefore, she can sent these keys to remote server.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/19/OpenVPN-Setup-Tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/19/OpenVPN-Setup-Tutorial/" class="post-title-link" itemprop="url">OpenVPN Setup Tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-19 16:08:34" itemprop="dateCreated datePublished" datetime="2019-01-19T16:08:34+08:00">2019-01-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tutorial/" itemprop="url" rel="index"><span itemprop="name">tutorial</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="Via-source-code"><a href="#Via-source-code" class="headerlink" title="Via source code"></a>Via source code</h3><ol>
<li><p>Download tar ball from <a target="_blank" rel="noopener" href="https://openvpn.net/index.php/download/community-downloads.html">release link</a></p>
</li>
<li><p>Dependencies</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install libssl-dev liblzo2-dev libpam0g-dev</span><br><span class="line">apt install easy-rsa</span><br></pre></td></tr></table></figure></li>
<li><p>Build source code</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xfz ./openvpn&lt;version&gt;.tar.gz</span><br><span class="line">cd openvpn&lt;version&gt;</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Via-official-apt-repositories"><a href="#Via-official-apt-repositories" class="headerlink" title="Via official apt repositories"></a>Via official apt repositories</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https://swupdate.openvpn.net/repos/repo-public.gpg|apt-key add -</span><br><span class="line">echo &quot;deb http://build.openvpn.net/debian/openvpn/stable xenial main&quot; &gt; /etc/apt/sources.list.d/openvpn-aptrepo.list</span><br><span class="line">apt update &amp;&amp; apt install openvpn</span><br></pre></td></tr></table></figure>

<h3 id="Via-script"><a href="#Via-script" class="headerlink" title="Via script"></a>Via script</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/Angristan/openvpn-install/master/openvpn-install.sh</span><br><span class="line">chmod +x openvpn-install.sh</span><br><span class="line">./openvpn-install.sh</span><br></pre></td></tr></table></figure>

<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><h3 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make-cadir CA &amp;&amp; cd CA</span><br></pre></td></tr></table></figure>
<p>In <em>CA</em> directory, edit the <em>vars</em> file and set the KEY_COUNTRY, KEY_PROVINCE, KEY_CITY, KEY_ORG and KEY_EMAIL parameters.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ./vars</span><br><span class="line">./clean-all</span><br><span class="line">./build-ca</span><br></pre></td></tr></table></figure>

<h3 id="Key-generation"><a href="#Key-generation" class="headerlink" title="Key generation"></a>Key generation</h3><p>In <em>keys</em> directory, generate the private keys, certification and Diffie Hellman parameters.</p>
<ol>
<li>Server key generation<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server server</span><br></pre></td></tr></table></figure></li>
<li>Client key generation<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build-key client1</span><br><span class="line">./build-key client2</span><br><span class="line">./build-key client3</span><br></pre></td></tr></table></figure></li>
<li>Diffie Hellman parameters generation<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Here is an explanation of the relevant files in <em>keys</em> subdir:</p>
<table>
<thead>
<tr>
<th>Filename</th>
<th>Needed By</th>
<th>Purpose</th>
<th>Secret</th>
</tr>
</thead>
<tbody><tr>
<td>ca.crt</td>
<td>server + all clients</td>
<td>Root CA certificate</td>
<td>NO</td>
</tr>
<tr>
<td>ca.key</td>
<td>key signing machine only</td>
<td>Root CA key</td>
<td>YES</td>
</tr>
<tr>
<td>dh{n}.pem</td>
<td>server only</td>
<td>Diffie Hellman parameters</td>
<td>NO</td>
</tr>
<tr>
<td>server.crt</td>
<td>server only</td>
<td>Server Certificate</td>
<td>NO</td>
</tr>
<tr>
<td>server.key</td>
<td>server only</td>
<td>Server Key</td>
<td>YES</td>
</tr>
<tr>
<td>client1.crt</td>
<td>client1 only</td>
<td>Client1 Certificate</td>
<td>NO</td>
</tr>
<tr>
<td>client1.key</td>
<td>client1 only</td>
<td>Client1 Key</td>
<td>YES</td>
</tr>
</tbody></table>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><ul>
<li>In VPNServer, put <em>server.conf</em>, <em>ca.crt</em>, <em>server.crt</em>, <em>server.key</em> and <em>dh{n}.pem</em> in the same directory(e.g. /etc/openvpn/).</li>
<li>In Client, put <em>client.conf</em>, <em>client{n}.crt</em>, <em>client{n}.key</em> and <em>ca.crt</em> in the same directory.</li>
<li>In <em>client.conf</em>, modify the <strong>remote</strong> value to VPNServer’s IPv4 address, modify <strong>cert</strong> and <strong>key</strong> to corresponding filename.</li>
</ul>
<h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><ol>
<li>In VPNServer:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --config /etc/openvpn/server.conf --daemon</span><br></pre></td></tr></table></figure></li>
<li>In Client:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --config /etc/openvpn/client&#123;n&#125;.conf --daemon</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/Resolution-for-2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/03/Resolution-for-2019/" class="post-title-link" itemprop="url">Resolution for 2019</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-01-03 15:11:14" itemprop="dateCreated datePublished" datetime="2019-01-03T15:11:14+08:00">2019-01-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><h3 id="Wargame"><a href="#Wargame" class="headerlink" title="Wargame"></a>Wargame</h3><p>Wargames are similar to CTF but always ongonging. Typically, they are always organized into levels.</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://microcorruption.com/" title="microcorruption">Microcorruption</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://smashthestack.org/" title="smashthestack">Smashthestack</a></p>
</li>
</ol>
<h3 id="CTF-1"><a href="#CTF-1" class="headerlink" title="CTF"></a>CTF</h3><p>Following the steps in <a target="_blank" rel="noopener" href="https://github.com/ctfs/resources">Resources</a>.</p>
<p>And reading the <a target="_blank" rel="noopener" href="https://github.com/Naetw/CTF-pwn-tips">Tips</a>.</p>
<h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><ol>
<li><p>Finishing the tutorial in <a target="_blank" rel="noopener" href="https://www.cplusplus.com/doc/tutorial/">cplusplus.com</a>.</p>
</li>
<li><p>Practices in <a target="_blank" rel="noopener" href="https://www.codewars.com/">Codewars</a>.</p>
</li>
</ol>
<h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>Compilers, Principles, Techniques and Tools.pdf</p>
<h2 id="Paper-Notes"><a href="#Paper-Notes" class="headerlink" title="Paper Notes"></a>Paper Notes</h2><ol>
<li>Code reuse attack</li>
<li>side-channel related</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhangtong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
