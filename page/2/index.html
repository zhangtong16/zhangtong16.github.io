<!DOCTYPE html>
<html lang="default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="Zhangtong&#39;s Notebook">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Zhangtong&#39;s Notebook">
<meta property="og:locale">
<meta property="article:author" content="Zhangtong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;default&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Zhangtong's Notebook</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhangtong's Notebook</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhangtong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhangtong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Kaleidoscope-Code-generation-to-LLVM-IR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/09/Kaleidoscope-Code-generation-to-LLVM-IR/" class="post-title-link" itemprop="url">Kaleidoscope: Code generation to LLVM IR</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-09 19:40:53" itemprop="dateCreated datePublished" datetime="2019-05-09T19:40:53+08:00">2019-05-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Chapter-3-Introduction"><a href="#Chapter-3-Introduction" class="headerlink" title="Chapter 3 Introduction"></a>Chapter 3 Introduction</h2><p>本章主要是将 <a href="./Chapter2.md">Chapter 2</a> 中构建的抽象语法树 (AST) 转化成 LLVM IR. 这章主要讲述 LLVM 能做哪些工作, 并且告诉你怎么使用.</p>
<p><strong>Note:</strong> 这章的代码需要 LLVM 3.7 或更新版.</p>
<h2 id="Code-Generation-Setup"><a href="#Code-Generation-Setup" class="headerlink" title="Code Generation Setup"></a>Code Generation Setup</h2><p>为了能生成 IR, 我们首先在每个 AST 类中定义一个生成代码的虚方法 (virtual code generation method).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExprAST - Base class for all expression nodes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> llvm::Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberExprAST</span>(<span class="keyword">double</span> Val) : <span class="built_in">Val</span>(Val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> llvm::Value *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>codegen()</code> 方法会根据每个不同的类生成 IR, 都返回一个 <code>class Value</code> 对象的指针. <code>class Value</code> 表示 LLVM 中的一个 SSA (Static Single Assignment) register 或者 SSA value. SSA 表示每个变量都只能被赋值一次, 而且必须在使用前被定义.</p>
<p>同时我们添加一个 <code>LogError()</code> 方法来记录生成 IR 时的错误:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">LogErrorV</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LogError</span>(Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并声明可能需要的静态变量:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> llvm::LLVMContext TheContext;</span><br><span class="line"><span class="keyword">static</span> llvm::IRBuilder&lt;&gt; Builder&#123;TheContext&#125;;</span><br><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;llvm::Module&gt; TheModule;</span><br><span class="line"><span class="keyword">static</span> std::map&lt;std::string, llvm::Value *&gt; NamedValues;</span><br></pre></td></tr></table></figure>

<p><code>LLVMContext TheContext</code> 是一个包含大量 LLVM 核心数据结构的对象, 比如包含类型和常量表 (the type and constant value tables). <code>IRBuilder Builder</code> 是一个辅助对象, 能简化 LLVM 指令的生成. 这个对象能够追踪当前需要插入指令的位置, 并有创建新指令的方法. <code>class Module</code> 的实例用来存储和 一个LLVM module 相关的所有信息. 在 LLVM 中, 一个 Module 表示能被处理的单个代码单元 (a single unit of code that is to be processed together), <del>差不多就是一个源代码文件</del>. <code>TheModule</code> 会拥有我们生成所有 IR 的内存, 这就是我们申明 <code>codegen()</code> 时, 让它返回裸指针 <code>Value *</code> 而不是 <code>unique_ptr&lt;Value&gt;</code> 的原因. <code>map&lt;string, Value *&gt; NamedValues</code> 主要追踪当前作用域内定义的值, 和它们的 LLVM representation. 换句话说 <code>NamedValues</code> 就是一个符号表 (symbol table for the code). 目前在 Kaleidoscope 中, 只有函数参数能被引用, 所以当生成函数体里面的代码时, 我们就会用到存储在它里面的函数参数.</p>
<p>我们现在假设 <code>IRBuilder Builder</code> 已经被设置好可以生成代码.</p>
<h2 id="Expression-Code-Generation"><a href="#Expression-Code-Generation" class="headerlink" title="Expression Code Generation"></a>Expression Code Generation</h2><p>为表达式节点生成 LLVM code 非常直接, 直接调用相应的函数即可, 首先是对数字常量表达式的代码生成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">NumberExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> llvm::ConstantFP::<span class="built_in">get</span>(TheContext, llvm::<span class="built_in">APFloat</span>(Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 LLVM IR 中, 字面常量是用 <code>class ConstantFP</code> 表示的, 字面常量的值由 <code>class APFloat</code> 持有, 即后者是前者的一个成员变量 (AP 表示 Arbitrary Precision). 然后是变量表达式的 <code>codegen()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">VariableExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    llvm::Value *V = NamedValues[Name];</span><br><span class="line">    <span class="keyword">if</span> (!V) &#123;</span><br><span class="line">        <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前针对变量的引用只有在函数体内才有, 所以我们先检查被引用的变量名是否在 <code>map&lt;string, Value*&gt; NamedValues</code> 中, 然后直接返回它的值即可. 在教程后面我们会加上对循环变量和局部变量的支持 (loop induction variables and local variables).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    llvm::Value *L = LHS -&gt; <span class="built_in">codegen</span>();</span><br><span class="line">    llvm::Value *R = RHS -&gt; <span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!L || !R)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (Op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Builder.<span class="built_in">CreateFAdd</span>(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Builder.<span class="built_in">CreateFSub</span>(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Builder.<span class="built_in">CreateFMul</span>(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">        L = Builder.<span class="built_in">CreateFCmpULT</span>(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">        <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">        <span class="keyword">return</span> Builder.<span class="built_in">CreateUIToFP</span>(L, llvm::Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;invalid binary operator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二元操作符表达式也是递归进行操作, 左表达式先进行代码生成, 然后是右表达式, 然后生成二元操作符表达式的代码. 在上述代码中, <code>class IRBuilder</code> 调用自己的成员方法, 例如 <code>CreateFAdd()</code>, 通过传入的参数来生成新的指令. 在 <code>CreateFAdd()</code> 方法中传入的名字仅仅只是一个提示, 如果上面的代码生成函数有多个 <code>CreateFAdd(L, R, &quot;addtmp&quot;)</code>, 那么 LLVM 会自动给每个都加上一个唯一的后缀.</p>
<p>LLVM 指令是被严格约束的: 对于加法指令, 左操作数和右操作数必须是相同类型, 且结果的类型和操作数的类型必须相同. Kaleidoscope 中的所有值都是 <code>double</code>, 所以这里不需要考虑类型.</p>
<p>并且, 在 LLVM 文档中, <code>fcmp</code> 指令返回的是 1个 bit 的整数 <code>i1</code>. 我们的数据类型中没有整数, 所以我们要转化为 0.0 或者 1.0. 所有我们使用 <code>uitofp</code> 指令, 它将第一个参数视为无符号的整数类型， 并把它转化为第二个参数表示的浮点类型 (double). 同时 <code>sitofp</code> 指令也可以完成类似的功能, 不过它是把第一个参数视为有符号的整数类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lookup the name in the global module table</span></span><br><span class="line">    llvm::Function *CalleeF = TheModule -&gt; <span class="built_in">getFunction</span>(Callee);</span><br><span class="line">    <span class="keyword">if</span> (!CalleeF) &#123;</span><br><span class="line">        <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown function referenced&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Argument checking</span></span><br><span class="line">    <span class="keyword">if</span> (CalleeF -&gt; <span class="built_in">arg_size</span>() != Args.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Incorrect number of arguments passed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;llvm::Value *&gt; ArgsV;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.<span class="built_in">size</span>(); i != e; ++i) &#123;</span><br><span class="line">        ArgsV.<span class="built_in">push_back</span>(Args[i] -&gt; <span class="built_in">codegen</span>());</span><br><span class="line">        <span class="keyword">if</span> (!ArgsV.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(CalleeF, ArgsV, <span class="string">&quot;calltmp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用的代码生成也是很直接的, 首先在 LLVM Module 的符号表里面查找这个函数名. LLVM Module 是用来持有函数的容器, 并且通过解析 Module 的符号表, 我们就能引用这些函数.</p>
<p>一旦我们找到函数之后, 就检查它在符号表中的参数数量和实际获取的参数数量是否一致. 并且递归的解析传给它的每个参数. 然后就能创建一个 LLVM <code>call</code> 指令.</p>
<h2 id="Function-Code-Generation"><a href="#Function-Code-Generation" class="headerlink" title="Function Code Generation"></a>Function Code Generation</h2><p>对函数原型和函数定义的代码生成包含不少细节, 不像上面表达式生成代码时那么直观和简洁. 但是我们同时也能看到一些比较重要的概念. 下面是函数原型的代码生成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Function *<span class="title">PrototypeAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make the function prototype: double(double, double).</span></span><br><span class="line">    <span class="function">std::vector&lt;llvm::Type *&gt; <span class="title">Doubles</span><span class="params">(Args.size(), llvm::Type::getDoubleTy(TheContext))</span></span>;</span><br><span class="line">    llvm::FunctionType *FT = llvm::FunctionType::<span class="built_in">get</span>(llvm::Type::<span class="built_in">getDoubleTy</span>(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line">    llvm::Function *F = llvm::Function::<span class="built_in">Create</span>(FT, llvm::Function::ExternalLinkage, Name, TheModule.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<p>这部分的代码包含了很多重要内容. 首先 <code>Function *PrototypeAST::codegen()</code> 返回值的类型是 <code>Function *</code> 而不是 <code>Value *</code>, 因为一个函数原型主要是表示函数的外部接口, 而不是像表达式一样能被计算出值. 对 <code>FunctionType::get()</code> 的调用可以得到函数类型, 第一个参数是返回值类型, 第二个参数是参数类型的列表, 第三个是是否支持可变参数列表.</p>
<p>最后一行就是实际生成 IR 代码的一行, <code>Function::Create()</code> 的参数分别为函数类型, Linkage 类型 (一般熟知的有 external linkage 和 internal linkage, 分别表示能被外部 translation unit (Module) 访问和不能. 例如 c/c++ 关键字 <code>extern</code> 和 <code>static</code>), 函数名, 和 <code>TheModule</code>. <del>在之前版本的 LLVM 文档中, 直接传了 <code>TheModule</code> (unique_ptr) 而不是 <code>TheModule.get()</code>, 会造成编译器错误.</del></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Set names for all arguments</span></span><br><span class="line">    <span class="keyword">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg: F -&gt; <span class="built_in">args</span>()) &#123;</span><br><span class="line">        Arg.<span class="built_in">setName</span>(Args[Idx++]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据函数原型的参数名字, 给 IR 的参数命名, 增加 IR 生成之后的可读性, 并且后续操作中, 能直接根据参数名对参数进行引用, 不需要再到函数原型的 AST 节点中查找.</p>
<p>然后就是函数定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">llvm::Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for an existing function from a previous `extern` declaration</span></span><br><span class="line">    llvm::Function *TheFunction = TheModule -&gt; <span class="built_in">getFunction</span>(Proto -&gt; <span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction) &#123;</span><br><span class="line">        TheFunction = Proto -&gt; <span class="built_in">codegen</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction -&gt; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (llvm::Function *)<span class="built_in">LogErrorV</span>(<span class="string">&quot;Function cannot be redefined&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于函数定义, 我们首先查找 <code>TheModule</code> 的符号表, 看看有没有匹配的函数名. 这样就可以看出这个函数有没有使用 <code>extern</code> 的前向声明. 如果没有声明, 那么我们就生成函数原型的代码. 并且, 我们断言这个时候函数体是没有生成代码的, 也就是说我们这次定义并不是重复定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new Basic Block to start insertion into.</span></span><br><span class="line">llvm::BasicBlock *BB = llvm::BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">Builder.<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">NamedValues.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction -&gt; <span class="built_in">args</span>()) &#123;</span><br><span class="line">    NamedValues[Arg.<span class="built_in">getName</span>()] = &amp;Arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行创建了一个新的 basic block, 并把它插入到 <code>TheFunction</code> 中. 第二行就告诉 <code>Builder</code>, 新的指令应该被插入到这个 basic block 的末尾. Basic block 定义了 LLVM 中的控制流图 (Control flow graph). 虽然我们现在没有控制流, 但在 <a href="./Chapter5.md">Chapter 5</a> 会加上.</p>
<p>然后就是将函数参数添加到 <code>map&lt;string, Value *&gt; NamedValues</code>, 这样 VariableExprAST 的节点就能在函数定义里面来引用它们.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (llvm::Value *RetVal = Body -&gt; <span class="built_in">codegen</span>()) &#123;</span><br><span class="line">        <span class="comment">// Finish off the function</span></span><br><span class="line">        Builder.<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line">        <span class="comment">// Validate the generated code, checking for consistency</span></span><br><span class="line">        llvm::<span class="built_in">verifyFunction</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TheFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TheFunction -&gt; <span class="built_in">eraseFromParent</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦代码的插入点被设置完毕, 我们就调用函数体的 <code>codegen()</code> 方法, 如果没有错误发生的话, 它就会将生成函数体里面表达式的代码, 然后将这些代码插入到上面定义的 entry basic block 中, 然后返回这些表达式计算出来的值. 接着创建 <code>ret</code> 指令完成函数. 生成完毕后使用 <code>verifyFunction()</code> 来检查生成代码的一致性. 如果生成函数体代码失败, 那就调用 <code>eraseFromParent()</code> 删除生成的函数.</p>
<p>但是这部分的代码也有问题, 如果 <code>FunctionAST::codegen()</code> 方法已经找到一个存在的函数声明, 那么它就跳过了函数原型代码的生成, 就导致跳过了对参数名的设置, 所以当前向声明中的参数名和函数定义使用的参数名不一致时, 会发生错误:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">foo</span><span class="params">(a)</span></span>;   <span class="meta"># ok, declare foo</span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(b)</span></span>;      # Error: Unknown variable name</span><br></pre></td></tr></table></figure>

<h2 id="Driver-changes-and-Closing-Thoughts"><a href="#Driver-changes-and-Closing-Thoughts" class="headerlink" title="Driver changes and Closing Thoughts"></a>Driver changes and Closing Thoughts</h2><p>主要就是在 <code>main()</code> 和相应的 <code>HandleDefinition()</code> 之类的函数中， 相应的更改用 preprocess macro 做了判断, 直接看代码即可.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Kaleidoscope-Implementing-a-Parser-and-AST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/09/Kaleidoscope-Implementing-a-Parser-and-AST/" class="post-title-link" itemprop="url">Kaleidoscope: Implementing a Parser and AST</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-09 19:39:37" itemprop="dateCreated datePublished" datetime="2019-05-09T19:39:37+08:00">2019-05-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Chapter-2-Introduction"><a href="#Chapter-2-Introduction" class="headerlink" title="Chapter 2 Introduction"></a>Chapter 2 Introduction</h2><p>这一章将会使用 <a href="./Chapter1.md">Chapter 1</a> 中实现的 lexer 来构造 Kaleidoscope 的 parser. 一旦我们完成 parser 的实现, 我们就能定义并且构造一个抽象语法树 (Abstract Syntax Tree, AST).</p>
<h2 id="The-Abstract-Syntax-Tree-AST"><a href="#The-Abstract-Syntax-Tree-AST" class="headerlink" title="The Abstract Syntax Tree (AST)"></a>The Abstract Syntax Tree (AST)</h2><p>AST 是源代码语法结构的抽象表示, 它以树状的形式来表示源代码中的语法结构, 树上的每个节点都表示源代码中的一种结构, 从而能建模这个语言, 方便编译器后续的解释 (code generation). 在 Kaleidoscope 中, 我们有表达式 (expressions), 函数原型 (prototype), 函数对象 (function object). 我们先从表达式开始:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExprAST - Base class for all expression nodes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprAST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberExprAST</span> :</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberExprAST</span>(<span class="keyword">double</span> Val) : <span class="built_in">Val</span>(Val) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的代码表示了基类 <code>ExprAST</code> 和它的一个子类 <code>NumberExprAST</code> 的定义. <code>NumberExprASR</code> 将数字常量的值存储到实例中的成员变量, 使得编译器能够在后面的步骤中对它进行处理.</p>
<p>然后是其他 AST 节点的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariableExprAST</span> :</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    std::string Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VariableExprAST</span>(<span class="keyword">const</span> std::string &amp;Name) : <span class="built_in">Name</span>(Name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryExprAST - Expression class for a binary operator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryExprAST</span> :</span> <span class="keyword">public</span> ExprAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> Op;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryExprAST</span>(<span class="keyword">char</span> Op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : <span class="built_in">Op</span> (Op), <span class="built_in">LHS</span> (std::<span class="built_in">move</span>(LHS)), <span class="built_in">RHS</span>(std::<span class="built_in">move</span>(RHS)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CallExprAST - Expression class for function calls</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallExprAST</span> :</span> <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    std::string Callee;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CallExprAST</span>(<span class="keyword">const</span> std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; args) : <span class="built_in">Callee</span>(Callee), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上的定义都比较直接, 使用一个 <code>std::string Name</code> 变量来获取变量的名字; 二元操作符使用 <code>char Op</code> 来获取操作符, 然后使用 <code>std::unique_ptr&lt;ExprAST&gt; LHS, RHS</code> 分别持有左边和右边的表达式; 函数调用使用 <code>std::string Callee</code> 来存储被调用的函数名, 使用 <code>std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; args</code> 来持有函数的参数列表.</p>
<p>对于我们最基本的语言, <strong>目前</strong>没有条件跳转的控制流, 所以还不是图灵完全的. 我们会在之后添加条件跳转. 接下来我们讨论函数接口和函数定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrototypeAST - This class represents the &quot;prototype&quot;</span></span><br><span class="line"><span class="comment">// for a function, which captures its name, and its</span></span><br><span class="line"><span class="comment">// argument names (thus implicitly the number of</span></span><br><span class="line"><span class="comment">// arguments the function takes)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeAST</span> &#123;</span></span><br><span class="line">    std::string Name;</span><br><span class="line">    std::vector&lt;std::string&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrototypeAST</span>(<span class="keyword">const</span> std::string &amp;Name, std::vector&lt;std::string&gt; Args) : <span class="built_in">Name</span>(Name), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string &amp;<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> Name&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FunctionAST - This class represents a function definition itself</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionAST</span> &#123;</span></span><br><span class="line">    std::unique_ptr&lt;PrototypeAST&gt; Proto;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FunctionAST</span>(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : <span class="built_in">Proto</span> (std::<span class="built_in">move</span>(Proto)), <span class="built_in">Body</span> (std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意, 在 Kaleidoscope 中,函数原型和函数定义并不是表达式, 所以没有继承 <code>class ExprAST</code>. 由于在 Kaleidoscope 中只有 <code>double</code> 类型, 所以函数的类型也仅仅和参数数量有关. 在更为复杂的语言中, <code>class ExprAST</code> 会有一个 field 专门存放类型信息.</p>
<h2 id="Parser-Basics"><a href="#Parser-Basics" class="headerlink" title="Parser Basics"></a>Parser Basics</h2><p>我们需要使用一个 parser 来构造 AST. 例如, 我们想解析 <code>x + y</code> 这类的表达式, 并生成一个 AST 时， 我们可以进行如下的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> LHS = std::make_unique&lt;VariableExprAST&gt;(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> RHS = std::make_unique&lt;VariableExprAST&gt;(<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> Result = std::make_unique&lt;BinaryExprAST&gt;(<span class="string">&#x27;+&#x27;</span>, std::<span class="built_in">move</span>(LHS), std::<span class="built_in">move</span>(RHS));</span><br></pre></td></tr></table></figure>

<p>为了实现上述操作， 我们先定义一些基本的辅助过程:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CurTok - CurTok is the current token the parser is looking at.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> CurTok;</span><br><span class="line"><span class="comment">// getNextToken - getNextToken reads another token from the lexer and update CurTok with its values.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CurTok = <span class="built_in">gettok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在 lexer 的基础上实现了一个简单的 token buffer. 使得我们能够保存 lexer 返回的 token. Parser 中的函数都假定 <code>static int CurTok</code> 是当前需要被处理的 token.</p>
<p>然后是一些简单的错误处理函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LogError* - These are little helper functions for error handling</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">LogError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;LogError: %s\n&quot;</span>, Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::unique_ptr&lt;PrototypeAST&gt; <span class="title">LogErrorP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LogError</span>(Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Basic-Expression-Parsing"><a href="#Basic-Expression-Parsing" class="headerlink" title="Basic Expression Parsing"></a>Basic Expression Parsing</h2><p>我们首先处理数字常量. 对每种不同的表达式，我们都定义单独的函数进行处理. 下面是对数字常量进行处理的函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// numberexpr ::= number</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseNumberExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Result = std::make_unique&lt;NumberExprAST&gt; (NumVal);</span><br><span class="line">    <span class="comment">// consume the number</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>gettok()</code> 返回 <code>tok_number</code> 时它会被调用. 此时 <code>static int NumVal</code> 已被设置为对应的值, 因此 <code>ParseNumberExpr()</code> 构造一个 <code>NumberExprAST</code> 的节点, 并使 lexer 获取下一个 token, 然后返回构造出的节点.</p>
<p>所以, 递归下降解析器的特点就是: 将当前表达式的 token 全部获取, 构造出表达式节点. 然后使 lexer 获取下一个 token, 再返回构造出的表达式节点.</p>
<p>下面是一个带括号的表达式的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parenexpr ::= &#x27;(&#x27; expression &#x27;)&#x27;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseParenExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// eat &#x27;(&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">auto</span> V = <span class="built_in">ParseExpression</span>();</span><br><span class="line">    <span class="keyword">if</span> (!V) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;Expected &#x27;)&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eat &#x27;)&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数说明了以下几个方法:</p>
<ol>
<li><p>告诉我们怎么使用 <code>LogError</code> 函数来打印错误.</p>
</li>
<li><p>在处理过程中, 递归调用 <code>ParseExpression</code> 来进行表达式的处理. <code>ParseExpression</code> 调用不同的 parser 函数来对不同的表达式进行处理. 这种递归调用使得我们可以实现递归语法.</p>
</li>
</ol>
<p>接下来是变量引用和函数调用的 parser 函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identifierexpr</span></span><br><span class="line"><span class="comment">//       :: = identifier</span></span><br><span class="line"><span class="comment">//       :: = identifier &#x27;(&#x27; expression* &#x27;)&#x27;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseIdentifierExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string IdName = IdentifierStr;</span><br><span class="line">    <span class="comment">// eat identifier</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a variable ref</span></span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;VariableExprAST&gt;(IdName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It&#x27;s a functional call</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// eat &#x27;(&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = <span class="built_in">ParseExpression</span>()) &#123;</span><br><span class="line">                Args.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(Arg));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CurTok == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;Expected &#x27;)&#x27; or &#x27;,&#x27; in argument list&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">getNextToken</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eat &#x27;&#x27;)</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;CallExprAST&gt;(IdName, std::<span class="built_in">move</span>(Args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数和上面的函数类似, 在 <code>gettok()</code> 返回 <code>tok-identifier</code> 时被调用. 它也有递归处理和错误处理. 它使用 <em>lookahead</em> 来判断这是一个简单的变量引用或者是一个函数调用. 在消耗掉第一个 identifier 之后, 它会看看后面是不是一个 <code>(</code>, 如果是的话, 那就构造一个参数列表, 并返回一个 <code>class CallExprAst</code> 节点; 如果不是, 那就直接返回一个 <code>class VariableExprAST</code> 节点.</p>
<p>现在我们有了一个简单的 expression-parser 逻辑. 我们可以定义一个辅助的 primary parser 函数来 wrap 这些 parser 函数. 这个 primary 函数能够根据 <code>static int CurTok</code> 来调用对应的 parser.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary</span></span><br><span class="line"><span class="comment">//      :: = identifierexpr</span></span><br><span class="line"><span class="comment">//      :: = numberexpr</span></span><br><span class="line"><span class="comment">//      :: = parenexpr</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (CurTok)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_identifier:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">    <span class="keyword">case</span> tok_number:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binary-Expression-Parsing"><a href="#Binary-Expression-Parsing" class="headerlink" title="Binary Expression Parsing"></a>Binary Expression Parsing</h2><p>由于二义性， 二元表达式更加难以处理. 比如说当给定一个字符串 <code>x + y * z</code>, parser 可以选择解释为 <code>(x + y) * z</code> 也可以解释为 <code>x + (y * z)</code>. 不过一般来讲, 符合常规的是第二种做法.</p>
<p>所以我们需要使用运算符优先级来处理这个问题, Operator-Precedence Parsing 使用运算符的优先级来告诉我们递归的顺序, 即首先处理哪个表达式. 首先我们定义一个运算符优先级表:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> TokPrec = BinOpPrecedence[CurTok];</span><br><span class="line">    <span class="comment">// Make sure it&#x27;s a declared binOp</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InitTokPrecedence - Install standard binary operators with their precedence</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Install standard binary operators</span></span><br><span class="line">    BinOpPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">    BinOpPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">    BinOpPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">    BinOpPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最基本的 Kaleidoscope 中, 我们只支持 4 个二元操作符. 不过这个可以按需添加. <code>GetTokPrecedence()</code> 会返回当前 <code>static int CurTok</code> 的优先级.</p>
<p>当定义完上述的辅助函数之后, 我们就可以开始解析二元表达式. 操作符优先级解析器的思路就是, 将具有二义性的表达式拆分成不同的部分. 例如, 针对表达式 <code>a + b + (c + d) * e * f + g</code>, 我们可以将它看作被二元操作符分割的 primary 表达式流 (a stream of primary expressions separated by binary operators). 就这样, 首先处理第一个表达式 <code>a</code>, 然后就是 <code>[+, b], [+, (c + d)], [*, e], [*, f] and [+, g]</code>.</p>
<p>所以, 一个表达式就是一个 primary 表达式， 加上后面可能存在的 [binOp, primary expr] 序列.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expression</span></span><br><span class="line"><span class="comment">//      :: = primary binOpRHS</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> LHS = <span class="built_in">ParsePrimary</span>();</span><br><span class="line">    <span class="keyword">if</span> (!LHS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseBinOpRHS</span>(<span class="number">0</span>, std::<span class="built_in">move</span>(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ParseBinOpRHS()</code> 能够解析 [binOp, primary expr] 序列流. 它的参数是优先级 (上述例子为 <code>0</code>), 和目前已经被解析的部分 (上述例子为 <code>LHS</code>). 以表达式 <code>x</code> 为例, 它被划分为 <code>x</code> 和一个空的 <code>binOpRHS</code>. 以 <code>a + b + (c + d) * e * f + g</code> 为例, <code>a</code> 是一个合法的 primary 表达式， 即 <code>LHS</code>, 同时 <code>binOpRHS</code> 为 <code>+ b + (c + d) * e * f + g</code>, 当前的 <code>static int CurTok</code> 是 <code>+</code>.</p>
<p>传给 <code>ParseBinOpRHS()</code> 的第一个参数是优先级值, 它表明了这个函数能处理的最小操作符优先级. 如果当前的 pair stream 是 <code>[+, x]</code> 并且第一个传入的参数为 <code>40</code>, 那它不会再消耗 tokens (因为 <code>+</code> 的优先级为 <code>20</code> 小于 <code>40</code>), 所以:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binOpRHS</span></span><br><span class="line"><span class="comment">//      :: = ( binOp primary)*</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseBinOpRHS</span><span class="params">(<span class="keyword">int</span> ExprPrec, std::unique_ptr&lt;ExprAST&gt; LHS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if this is a binOp, find its precedence</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> TokPrec = <span class="built_in">GetTokPrecedence</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if this is a binOp that binds at least </span></span><br><span class="line">        <span class="comment">// as tightly as the current binOP, </span></span><br><span class="line">        <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">        <span class="keyword">if</span> (TokPrec &lt; ExprPrec) &#123;</span><br><span class="line">            <span class="keyword">return</span> LHS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we know it&#x27;s a binOP</span></span><br><span class="line">        <span class="keyword">int</span> BinOp = CurTok;</span><br><span class="line">        <span class="comment">// eat binOp</span></span><br><span class="line">        <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parse the primary expression after the binOP.</span></span><br><span class="line">        <span class="keyword">auto</span> RHS = <span class="built_in">ParsePrimary</span>();</span><br><span class="line">        <span class="keyword">if</span> (!RHS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If binOP binds less tightly with RHS than the</span></span><br><span class="line">        <span class="comment">// operator after RHS, let the pending operator take</span></span><br><span class="line">        <span class="comment">// RHS and its LHS</span></span><br><span class="line">        <span class="keyword">int</span> NextPrec = <span class="built_in">GetTokPrecedence</span>();</span><br><span class="line">        <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">            <span class="comment">// a + b * c -&gt; a + (b * c)</span></span><br><span class="line">            RHS = <span class="built_in">ParseBinOpRHS</span>(TokPrec + <span class="number">1</span>, std::<span class="built_in">move</span>(RHS));</span><br><span class="line">            <span class="keyword">if</span> (!RHS) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a + b + c -&gt; (a + b) + c</span></span><br><span class="line">        LHS = std::make_unique&lt;BinaryExprAST&gt;(BinOp, std::<span class="built_in">move</span>(LHS), std::<span class="built_in">move</span>(RHS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until the ends of expr.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ParseBinOpRHS()</code> 首先比较当前 token 的优先级和传入参数的优先级. 如果当前 binOp 优先级, <code>TokPrec</code> 低于传入参数的优先级, 那么就说明 binOp 左边的 primary 表达式要优先计算, 直接返回 <code>LHS</code> 即可. 若 binOP 的优先级不低于传入参数, 那么就使用 <code>int BinOp</code> 持有当前的这个 binOp, 并调用 <code>getNextToken()</code> 处理好当前 binOp 右边的这个 primary 表达式, 并使用 <code>RHS</code> 持有引用， 所以现在 <code>static int CurTok</code> 表示的是下一个 binOp, 它的优先级是 <code>NextPrec</code>. 然后, 需要判断上面的这个 <code>RHS</code> 是和 <code>LHS</code> 结合的紧还是和下一个 primary 表达式结合的紧. 如果 <code>NextPrec</code> 优先级大于 <code>TokPrec</code>, 那么 <code>RHS</code> 和它右边的 primary 表达式结合的紧, 所以递归调用 <code>ParseBinOpRHS()</code>, 第一个参数为 <code>TokPrec + 1</code>, 第二个为 <code>RHS</code>, 可以将高优先级的序列先处理完毕, 并作为 <code>RHS</code> 返回. 若 <code>NextPrec</code> 不大于 <code>TokPrec</code> 那么, <code>LHS</code> 和 <code>RHS</code> 结合得更紧, 那么先算出 <code>LHS</code> 和 <code>RHS</code>, 之后再将它们的结果作为 <code>LHS</code> 循环算出后面的值.</p>
<blockquote>
<p>在遇到优先级高的 binOP, 递归调用 <code>ParseBinOpRHS()</code> 时, 传的参数一定是 <code>TokPrec + 1</code> 才能在第一个条件判断中退出.</p>
</blockquote>
<h2 id="Parsing-the-Rest"><a href="#Parsing-the-Rest" class="headerlink" title="Parsing the Rest"></a>Parsing the Rest</h2><p>然后我们要处理函数原型, 和函数定义. 函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prototype</span></span><br><span class="line"><span class="comment">//      :: = id &#x27;(&#x27; id* &#x27;)&#x27;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParsePrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected function name in prototype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string FnName = IdentifierStr;</span><br><span class="line">    <span class="comment">// eat the function name</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// feed the arg list into vector</span></span><br><span class="line">    std::vector&lt;std::string&gt; ArgNames;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getNextToken</span>() == tok_identifier)</span><br><span class="line">    &#123;</span><br><span class="line">        ArgNames.<span class="built_in">push_back</span>(IdentifierStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eat &#x27;)&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;PrototypeAST&gt;(FnName, std::<span class="built_in">move</span>(ArgNames));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数定义就是函数原型加上函数体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function definition</span></span><br><span class="line"><span class="comment">//          :: = &#x27;def&#x27; prototype expression</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// eat def</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> Proto = <span class="built_in">ParsePrototype</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且我们支持使用 <code>extern</code> 关键字进行前向声明:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// external forward declaration</span></span><br><span class="line"><span class="comment">//          :: = &#x27;extern&#x27; prototype</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParseExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// eat &#x27;extern&#x27;</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParsePrototype</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们允许用户使用任意的顶级 (非嵌套) 表达式 (top-level expressions), 我们使用匿名零元函数 (anonymous nullary function) 来处理:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toplevelexpr</span></span><br><span class="line"><span class="comment">//      :: = expression</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseTopLevelExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>()) &#123;</span><br><span class="line">        <span class="comment">// anonymous nullary function</span></span><br><span class="line">        <span class="keyword">auto</span> Proto = std::make_unique&lt;PrototypeAST&gt;(<span class="string">&quot;&quot;</span>, std::vector&lt;std::string&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="The-Driver"><a href="#The-Driver" class="headerlink" title="The Driver"></a>The Driver</h2><p>Driver 就是使用循环来调用不同的 parser 函数 (dispatch loop):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseDefinition</span>()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed a function definition.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Skip token for error recovery</span></span><br><span class="line">        <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseExtern</span>()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed an extern.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Skip token for error recovery</span></span><br><span class="line">        <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseTopLevelExpr</span>()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed a top-level expression.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Skip token for error recovery</span></span><br><span class="line">        <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// top ::= definition | external | expression | &#x27;;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ready&gt; &quot;</span>);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (CurTok) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span> : <span class="comment">// ignore top-level semicolons </span></span><br><span class="line">            <span class="built_in">getNextToken</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> tok_def :</span><br><span class="line">            <span class="built_in">HandleDefinition</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> tok_extern :</span><br><span class="line">            <span class="built_in">HandleExtern</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> tok_eof :</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">HandleTopLevelExpression</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Kaleidoscope-Tutorial-Introduction-and-the-Lexer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/09/Kaleidoscope-Tutorial-Introduction-and-the-Lexer/" class="post-title-link" itemprop="url">Kaleidoscope: Tutorial Introduction and the Lexer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-09 19:37:42" itemprop="dateCreated datePublished" datetime="2019-05-09T19:37:42+08:00">2019-05-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="The-Basic-Language"><a href="#The-Basic-Language" class="headerlink" title="The Basic Language"></a>The Basic Language</h2><p>Kaleidoscope 是一个面向过程的语言, 允许你定义函数, 使用条件判断, 数学计算等. 在后面的教程中, 我们还会扩展    Kaleidoscope 使它支持 <code>if/then/else</code> 结构, 循环结构和用户定义的操作符.</p>
<p>Kaleidoscope 中唯一的数据类型是 64 bit 的浮点类型 (<code>double</code> in C). 下面是使用 Kaleidoscope 实现的斐波拉契数列.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compute the x&#x27;th Fibonacci Number</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">x</span> &lt; 3</span></span><br><span class="line"><span class="function">    <span class="title">then</span> 1</span></span><br><span class="line"><span class="function">    <span class="title">else</span> <span class="title">fib</span>(<span class="params">x-<span class="number">1</span></span>) + <span class="title">fib</span>(<span class="params">x-<span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">This</span> <span class="title">expression</span> <span class="title">will</span> <span class="title">compute</span> <span class="title">the</span> 40<span class="title">th</span> <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="title">fib</span>(<span class="params"><span class="number">40</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>我们还允许 Kaleidoscope 能够调用标准库函数 (LLVM JIT 能够轻易的实现它). 你可以使用 <code>extern</code> 关键字来定义一个函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">atan2</span><span class="params">(arg1 arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">atan2</span>(<span class="built_in">sin</span>(<span class="number">.4</span>), <span class="built_in">cos</span>(<span class="number">42</span>))</span><br></pre></td></tr></table></figure>

<h2 id="The-Lexer"><a href="#The-Lexer" class="headerlink" title="The Lexer"></a>The Lexer</h2><p>当实现一个语言时, 第一件事就是能够处理源代码文件, 并知道它想表达的意思. 传统的做法是使用 lexer (scanner) 将输入的源文件处理为 tokens. Lexer 返回的每个 token 都包括一个 token code 和一些 metadata (比如数字的值). 首先我们定义这些可能使用到的数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The lexer return tokens [0-255]</span></span><br><span class="line"><span class="comment">// if it is an unknown character,</span></span><br><span class="line"><span class="comment">// otherwise one of these known things.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">    tok_eof = <span class="number">-1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// commands</span></span><br><span class="line">    tok_def    = <span class="number">-2</span>,</span><br><span class="line">    tok_extern = <span class="number">-3</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// primary</span></span><br><span class="line">    tok_identifier = <span class="number">-4</span>,</span><br><span class="line">    tok_number     = <span class="number">-5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="keyword">static</span> std::string IdentifierStr;</span><br><span class="line"><span class="comment">// Filled in if tok_number</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> NumVal;</span><br></pre></td></tr></table></figure>

<p>Lexer 返回的每个 token 要么是 Token 枚举中的值, 要么是一个 “未知” 的字符的 <code>ascii</code> 值, 比如 <code>+</code>. 如果当前的 token 是一个标识符, 那么 <code>IdentifierStr</code> 会保存它的名字. 如果当前 token 是一个数字, 那么 <code>NumVal</code> 会保存它的值.</p>
<p>Lexer 实现是 <code>gettok()</code> 函数, <code>gettok()</code> 被调用之后, 会返回从标注输入中获取的下一个 token.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> LastChar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip any whitespace</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    &#123;</span><br><span class="line">        LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>gettok</code> 通过调用 <code>getchar()</code> 从标准输入中读取字符, 并忽略 tokens 之间的空格, 它仅仅是将字符存储到 <code>LastChar</code> 中, 不进行处理.</p>
<p><code>gettok</code> 接下来要识别标识符和关键字.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123;</span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>(LastChar = <span class="built_in">getchar</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        IdentifierStr += LastChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>) <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>) <span class="keyword">return</span> tok_extern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是标识符和关键字，那进一步判断是否为数字.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">    std::string NumStr;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumStr += LastChar;</span><br><span class="line">        LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = <span class="built_in">strtod</span>(NumStr.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当读取的字符为数字时, 使用 <code>strtod()</code> 将它转化为 <code>double</code> 并存储在 <code>NumVal</code> 中. 这一步没有做异常处理, 有需要的可以添加.</p>
<p>然后我们处理注释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LastChar == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; LastChar != <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    <span class="comment">// Return the next token</span></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gettok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释会跳过 <code>#</code> 后面所有的字符，直到下一行或者 <code>EOF</code>. 当跳过之后, 需要重新进行处理并返回下一个 token， 所以直接尾递归调用 <code>gettok()</code> 即可. 如果输入不匹配标识符和关键字, 也不匹配数字, 只有可能是 <code>+</code> 之类的操作符, 和 <code>EOF</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for end of file. Don&#x27;t eat EOF</span></span><br><span class="line">    <span class="keyword">if</span> (LastChar == EOF) &#123;</span><br><span class="line">        <span class="keyword">return</span> tok_eof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, just return the character as its ascii value</span></span><br><span class="line">    <span class="keyword">int</span> ThisChar = LastChar;</span><br><span class="line">    LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 Kaleidoscope 的 lexer.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/ProbeGuard-Mitigating-Probing-Attacks-Through-Reactive-Program-Transformations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/05/ProbeGuard-Mitigating-Probing-Attacks-Through-Reactive-Program-Transformations/" class="post-title-link" itemprop="url">ProbeGuard: Mitigating Probing Attacks Through Reactive Program Transformations</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-05 19:29:31" itemprop="dateCreated datePublished" datetime="2019-05-05T19:29:31+08:00">2019-05-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>As a defense, <em>information hiding</em> is more efficient than <em>integrity-based defenses</em>. In particular, randomization is almost ‘free’, as even a sophisticated defense against code reuse attacks such as Code Pointer Integrity adds a modest 2.9% performance overhead.</p>
<p>Unfortunately, recent research demonstrates that attackers bypass even the most advanced information-hiding defenses. They show that, by repeatedly <code>probing</code> the address space (either directly or by means of side channels), it is possible to break the underlying randomization and reveal the sensitive data.</p>
<p>In this paper, we show that we can transforming from fast information hiding to strong software integrity if (and only when) attacks start probing to break the randomization.</p>
<p><strong>Derandomization primitives.</strong> To break randomization, attackers make use a number of derandomization primitives. Since one-shot leaks are rare in modern defenses—as the defenses move all sensitive information (e.g., code pointers) out of reach of the attacker, state-of-art derandomization primitives invariably must <em>probe</em> by repeatedly executing an operation to exhaust the entropy.</p>
<p><strong>Selective hardening.</strong> The key idea we present is that, in a software protected by a fast baseline defense (information hiding), we keep monitoring the running program for any occurrence of probing attempts. When we encounter any such attempt, we automatically locate it origin, and patch <em>only</em> the offending piece of code at runtime with stronger and more expensive integrity-based defenses.</p>
<p>The first stage of ProbeGuard is form of anomaly detection. We detect probing attempts that characterize derandomization primitives. For most varieties of probing attacks, the anomaly detection itself is simple and non-intrusive (e.g., detecting of repeated exceptions).</p>
<p>The second stage, namely probe analysis, uncovers the particular code site the attacker abused for probing. Doing so is complicated in the general case. However, by leveraging fast control-flow tracing feature (e.g., Intel Processor Trace), ProbeGuard conservatively pinpoints the offending code fragment in a secure way.</p>
<p>Finally, ProbeGuard hotpatch the program by selectively replacing the offending code fragment with a harden variant. In principle, ProbeGuard is agnostic to the hotpatching technique it itself. A simple and elegent way is to create a binary that already contains multiple versions of all code fragments, where each version offers different levels of protection.</p>
<h2 id="Threat-model"><a href="#Threat-model" class="headerlink" title="Threat model"></a>Threat model</h2><p>We consider a determined remote attacker who aims to mount a code reuse attack over the network on a <em>server application</em> hardened by any <em>ideal</em> state-of-art information hiding-base defenses. ProbeGuard’s goal is to address the fundamental weakness of practical (information-hiding based) code reuse defenses, making them resistant to attacks that bypass the defense by derandomizing hidden memory regions.</p>
<p>We trust the underlying operating system, and we assume a modern processor that provides efficient control flow tracing, such as Intel Processor Trace.</p>
<p>We assume a determined attacker who has access to derandomization primitives to probe the victim’s address space. Further, we assume that the attacker has unlimited probing attempts as the application recovers automatically upon any crash.</p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>An application employs information-hiding based on state-of-art defenses. ProbeGuard must ensure what is hidden remain hidden. We embed <em>anomaly detectors</em> within the application that sense probing attacks and a <em>secure code cache</em> consisting of a collection of code fragments hardened by applying LLVM-based integrity checking instrumentations. A separate <em>reactive defense</em> server decodes execution traces obtained by Intel PT and performs fast <em>probe analyses</em>. ProbeGuard then reactively activates hardened code fragments by <em>hotpatching</em> when under attack.</p>
<h3 id="Anomaly-detection"><a href="#Anomaly-detection" class="headerlink" title="Anomaly detection"></a>Anomaly detection</h3><p><strong>Arbitrary reads and writes.</strong> An attacker may exploit an arbitrary memory read or write vulnerability in the application with the goal of derandomization the hidden region. Typically, only a very small fraction of the application’s virtual address is actually mapped. When the attacker uses such a vulnerability to access random address, it is highly likely to hit an unmapped virtual memory address leading to a segmentation fault (or a crash). We detect such probing attacks by simply handling and proxying the signal using a custom <code>SIGSEGV</code> handler.</p>
<p><strong>Kernel reads and writes.</strong> Attackers prefer probing silently and avoid detection. Hence, to avoid the crashes, they could also attempt to derandomize the victim application’s address space by probing memory via the kernel. Certain system calls (e.g., <code>read</code>) accepts memory addresses in their argument list and return specific error codes (e.g., <code>EFAULT</code>) if the argument is a pointer to an inaccessible or unallocated memory location. Using arbitrary-read/write primitives on such arguments, they could attempt CROP attacks to enable probes eliminating application crashes (thereby not generating <code>SIGSEGV</code> signals). We can detect such probing attacks by intercepting system calls, either in <code>glibc</code> or directly in the kernel, and inspecting their results.</p>
<p><strong>Arbitrary jumps.</strong> Attacker can use this primitive to scanning the address space, and looking for valid code pointers, and then locating gadgets. An attempt to execute unmapped or non-executable memory results in either a segmentation fault (raising a <code>SIGSEGV</code> signal) or an illegal instruction exception (raising a <code>SIGILL</code> signal). Thus, we extend our custom signal handler to handle both the signals.</p>
<p><strong>Allocation oracles.</strong> Such probes exploit memory allocation functions in the target application by attempting to allocate large memory areas. Success or failure of the allocation leaks information about the sizeof holes in the address space, which in turn, helps locate the hidden region. We hook into <code>glibc</code> to intercept the system calls used to allocate memory (e.g., <code>mmap()</code> and <code>brk</code>). We choose a configurable threshold on allocation size, above which our detector triggers reactive hardening (half of the address space by default).</p>
<h3 id="Probe-analysis"><a href="#Probe-analysis" class="headerlink" title="Probe analysis"></a>Probe analysis</h3><p>Upon an anomaly detector flagging a potential attack, ProbeGuard must locate the offending code fragment. To locate the probing primitive, we employ hardware-assisted branch tracing to fetch to control flow prior to when we detectd the anomaly. We build a reverse mapping to fetch source-level information from the trace.</p>
<p>We obtain past executed control-flow using Intel PT, which offers low-overhead and secure branch tracing. Control bits in the CPU’s model-specific registers (MSRs) allow an operating system kernel to turn this hardware feature to on or off. The buffer size is configurable, typical values range from 2 MB to 4 MB or more. The backward trace analysis can limit itself to the relevant recent control-flow history and avoid decoding all of the trace in its entirely.</p>
<p>We use <code>perf record</code> command interface’s snapshot mode and dump the trace when required. Although the decoded trace provided, it’s hard to mapping them back to the source file and determining the offending code fragment.</p>
<p>The <em>probe analyzer</em> must locate the affected spot in the source code. We repurpose a field in LLVM’s debug metadata that normally carries <code>column number</code> of the source code location to instead place respective basic block identifiers. This only simplifies out prototype implementation to let LLVM’s default code generator pass on the metadata through DWARF 4.0 symbols onto the resulting application binarym instead of having to use a new metadata stream and write the supporting code.</p>
<p>We choose to mark the entire parent function that includes the probing primitive and use this for hardening.</p>
<h3 id="Hotpatching"><a href="#Hotpatching" class="headerlink" title="Hotpatching"></a>Hotpatching</h3><p>To facilitate hotpatching, we first transform the program using our LLVM compiler passes. The goal is to be able to quickly and efficiently replace each vanilla variant of a function with a different (hardened) variant of the same function at runtime. We clone all functions found in the target application’s LLVM IR and selectively invoke security-hardening instrumentation passes on specific functions clones at <em>compiler time</em>.</p>
<p>A global <code>switchboard</code> (which we insert in the application) allows switching between each function variant at runtime. It contains an entry for each function in the program, controlling which of the variants to use during execution.</p>
<p>To deter attacks against ProbeGuard, we mark the switchboard <strong>as read-only during normal execution</strong>.</p>
<h3 id="Selective-security-hardening"><a href="#Selective-security-hardening" class="headerlink" title="Selective security hardening"></a>Selective security hardening</h3><p><strong>Arbitrary memory reads and writes.</strong> Software Fault Isolation mitigates probing attempts that use arbitrary reads and writes. It simply instruments every load or store operation in the application binary by masking the target memory location with a bit mask (47th bit of the memory pointer).</p>
<p><strong>Kernel reads and writes.</strong> We mask all pointer arguments to library calls.</p>
<p><strong>Arbitrary jumps.</strong> We implemented a type-based CFI policy for forward-edge protection, and a per-thread shadow stack for backward-edge protection.</p>
<p><strong>Allocation oracles.</strong> A white-list based threshold on the size arguments of library functions.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>ProbeGuard’s implementation consists of the following:</p>
<ol>
<li><p>A static library linked with the application: it houses a signal handler registered at startup, and helps in hotpatching to support switching between function variants at runtime.</p>
</li>
<li><p><code>glibc</code> modifications to intercept <code>mmap()</code>, and syscalls that results in <code>EFAULT</code>.</p>
</li>
<li><p>LLVM compiler passes to generate and propagate function identifying markers onto the binary via DWARF 4.0 symbols, and function cloning to facilitate hotpatching.</p>
</li>
<li><p>A seprate reactive defense server that does probe analysis by fetching Intel PT traces using <code>libipt</code> to map them onto the binary by reading the markers using <code>libdwarf</code></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/IMIX-In-Process-Memory-Isolation-EXtension/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/03/IMIX-In-Process-Memory-Isolation-EXtension/" class="post-title-link" itemprop="url">IMIX: In-Process Memory Isolation EXtension</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-03 20:18:09" itemprop="dateCreated datePublished" datetime="2019-05-03T20:18:09+08:00">2019-05-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Defenses against memory-corruption typically reduce the attack surface by preventing the adversary from corrupting part of the application’s memory which is essential for a successful attack, such as W⨁X, CFI, CPI, and DFI.</p>
<p>Some of these defenses can be implemented efficiently using mechanisms that reside entirely outside the underlying application process. For instance, the kernel configures W⨁X and the hardware enforces it. However, using an external mechanism is not always feasible in practice due to high performance overhead. For instance, CFI requires run-time checks and a <em>shadow stack</em>, which is updated every time a function is invoked or returns. CPI requires run-time checks and a <em>safe region</em>, which contains meta-data about the program’s variables. This data cannot be stored outside of the process, e.g., in kernel memory, because accessing it would impose an impratical performance overhead due to the time needed for a context switch. Hence, to prevent the adversary from accessing the data some form of <em>in-process memory isolation</em> is needed.</p>
<p><strong>Goals and Contribution.</strong> In this paper, we present IMIX, which enables lightweight in-process memory isolation for memory-corruption defenses that target the x86 architecture. IMIX enables <em>isolated pages</em>, which marked with a special flag. Isolated pages can only be accessed using a single new instruction called <code>smov</code>.</p>
<h2 id="Adversary-model"><a href="#Adversary-model" class="headerlink" title="Adversary model"></a>Adversary model</h2><ul>
<li><p><strong>Memory corruption.</strong> We assume the presence of a memory-corruption vulnerability, which the adversary can repeatedly exploit to read and write data according to memory access permissions.</p>
</li>
<li><p><strong>Sandboxed code execution.</strong> We assume memory-corruption mitigations cannot be bypassed unless the attacker can corrupt the mitigation’s metadata.</p>
</li>
<li><p><strong>Immutable code.</strong> The adversary cannot inject new code or modify existing code.</p>
</li>
</ul>
<h2 id="IMIX"><a href="#IMIX" class="headerlink" title="IMIX"></a>IMIX</h2><p>Like for applications, the correct functionality of defenses relies on the integrity of their code and data. Thus, the attacker may leverage a memory-corruption vulnerability in the application to bypass those defense. Traditionally, defense developers enforce the integrity of the code using W⨁X or execute-only memory, which forces defense developers to choose between high performance overheads and compromised security. IMIX allocates data belonging to run-time mitigations in <em>isolated pages</em>, which can only be accessed by <code>smov</code>.</p>
<p>In addition to rhe <code>smov</code> instruction and the associated access permissions, IMIX includes a kernel extension and compiler support.</p>
<p><strong>Hardware.</strong> For IMIX, we extend two of the CPU’s main responsibilities, instruction processing and memory management. We add <code>smov</code> instruction to the instruction set, reusing the logic of regular memory access instruction. The memory access logic is modified so that it will generate a fault if (1) an instruction other than <code>smov</code> is used to access a page protected by IMIX, or if (2) an <code>smov</code> instruction is used to access a normal page.</p>
<p><strong>Kernel.</strong> We extend the kernel to support an additional access permission, which identifies all pages protected by IMIX. This enables protected memory allocation for code generated at runtime.</p>
<p><strong>Compiler.</strong> IMIX provides two high-level primitives: one for allocating protected memory and one for accessing it. Mitigations like CPI are implemented as an LLVM optimization pass that works at the IR level. For applications developers, IMIX provides source code annotations.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Developers can build programs with IMIX, using our extented Clang compiler. We also modified its backend to support <code>smov</code> instructions. Programs protects by IMIX mark isolated pages using the system call <code>mprotect</code> with a special flag. Therefore, we extented the kernel’s existing page-level memory protection functionality to support this flag and mark isolated pages appropriately. To support IMIX, the CPU must be modified to support the <code>smov</code> instruction and must perform the appropriate checks when accessing memory.</p>
<h3 id="CPU-extension"><a href="#CPU-extension" class="headerlink" title="CPU extension"></a>CPU extension</h3><p>We mapped the IMIX protection flag to an ignored bit in the PTE; specifically, we chose bit 52, as it is the first bit not reserved, and is normally ignored by the MMU. We used a hardware simulator to show the feasibility of our design.</p>
<p><strong>Simulated hardware.</strong> We use Wind River Simics, a full system simulator, in order to simulator a complete computer which supports IMIX. And we use the complementary Intel Simulation and Analysis Engine (SAE) add-on to boot the Linux kernel and test our Linux extension. SAE supports emulating an x86 system running in a full operating system within its processes, while allowing various architecture instrumentations. This is done using extensions, called <em>ztools</em>.</p>
<p>To instrument a simulated system, ztools registers callback for specific hooks either at initialization time or dynamically. First, we make sure that our ztool is initialized by registering a callback for the initialization hook. Then, we register a callback that is executed when an instruction is added to the CPU’s instruction cache. If either a <code>mov</code> or <code>smov</code> instruction that accesses memory is found, we register an instruction replacement callback.</p>
<p>First, we check the protection flag of the memory accessed by the instruction. To identify protected memory, we look up the related PTE by combining the virtual address and the base address of the page table hierarchy linked from the <code>cr3</code> register.</p>
<p>If a regular instruction attempts to access regular memory, we execute the original instruction to avoid instruction cache changes. For <code>smov</code> instruction attempting to access an isolated page, we first remove the instruction from the instruction cache, and the execute our ztool implementation of this instruction.</p>
<p><strong>Real hardware.</strong> Adding IMIX support to a real CPU would require extending the CPU’s instruction decoder to make it aware of our <code>smov</code> instruction. Moreover, we need to modify the MMU to perform necessary checks.</p>
<h3 id="Operating-system-extension"><a href="#Operating-system-extension" class="headerlink" title="Operating system extension"></a>Operating system extension</h3><p>The isolated pages need to be marked as such in the PTEs, which are located in kernel memory. We add a dedicated <code>PROT_IMIX</code> flag into the <code>mprotect</code> system call. Note that once a pages is marked as <code>PORT_IMIX</code>, the only way to remove this flag from a page is by unmapping it first.</p>
<h3 id="Compiler-extension"><a href="#Compiler-extension" class="headerlink" title="Compiler extension"></a>Compiler extension</h3><p>Our modification mainly concerns the IR to provide access to the <code>smov</code> instruction to mitigations like CPI, and the x86 backend to emit the instruction. Further, we introduced an attribute that can be used the protect a single variable by allocating it in an isolated page.</p>
<p><strong>IR Extension.</strong> Runtime defenses are usually implemented as LLVM optimization passes that interact with and modify LLVM’s IR. In order to allow those defenses to generate <code>smov</code> instructions, we extended the IR instruction set. We created two IMIX instructions: <em>sload</em> and <em>sstore</em>.</p>
<p>LLVM IR instructions are implemented as C++ classes and therefore supports inheritance. We implemented our IR instructions to as subclass of their regular counterparts in order to reuse the existing translation functionality from LLVM IR to machine code, called <em>lowering</em> in LLVM parlance.</p>
<p>To allocate memory in isolated pages, we implemented an LLVM function that can be called from an optimization pass, which allocates memory at page granularity using <code>malloc</code> and sets the IMIX permission using <code>mprotect</code>.</p>
<p><strong>Attribute support.</strong> We added a IMIX attribute which can be used to annotate C/C++ variables which should be allocated in isolated pages. All instructions accessing those annotated variables will use the IMIX IR instructions instead of regular ones. We implemented this as an LLVM optimization pass that replaces regular variable allocations with indexed slots in a IMIX protected safe region (one per compilation module).</p>
<p><strong>Modification to x86 backend.</strong> In the backend, we added the code needed to process <em>sload</em> and <em>sstore</em> instructions. The process of lowering IR instructions to machine code is two-staged. First, the <em>FastEmit</em> mechanism is used. It consists of transformation rules explicitly coded in C++ that are too complex to be processed using regular expressions. The mechanism can be used either generate machine code directly, or to assign a rule that should be applied in the next stage. In the second stage, LLVM applies rule-based lowering using pattern matching. The IR instructions and its operands are matched against string pattern in LLVM’s <em>TableGen</em> definitions. We modified both stage of the lowering process, similarly to how <em>load</em> and <em>store</em> are handled.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/02/SGX-Shield-Enabling-Address-Space-Layout-Randomization-for-SGX-programs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/02/SGX-Shield-Enabling-Address-Space-Layout-Randomization-for-SGX-programs/" class="post-title-link" itemprop="url">SGX-Shield: Enabling Address Space Layout Randomization for SGX programs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-02 18:43:18" itemprop="dateCreated datePublished" datetime="2019-05-02T18:43:18+08:00">2019-05-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The traditional memory corruption vulnerabilities, such as buffer overflow, exist inside SGX programs, which not only nullifies the security guarantee that SGX claims to provide, but also, perhaps more critically, allows attacker to exploit isolation and confidentiality to lurk. For example, by exploiting a stack overflow vulnerability in a trusted web server or database running in a <em>enclave</em>, an adversarial client can launch traditional return-orient programming (ROP) attacks to disclose security-sensitive data in an enclave.</p>
<p>To defeat such attack, Intel includes a simple ASLR scheme for SGX in Intel SDKs for Linux and Windows. However, we find that Intel’s ASLR’s design has several critical limitations that invalidate the security guarantees of ASLR.</p>
<p><em>Challenges:</em></p>
<ol>
<li><p>The strong, unique attack model of SGX exposes the enclave memory layout to untrusted system software, leaving SGX programs completely unprotected by ASLR.</p>
</li>
<li><p>SGX provides the limited memory to an enclave typically 64 MB or 128 MB in total can be protected. Thus, the degree of randomness and the security of ASLR has been significantly limited.</p>
</li>
<li><p>ASLR requires a dynamic relocation scheme that updates relative addresses in the code and data section, which comflict with the attestation process of SGX; specifically, SGX finalizes the integrity measurement before an enclave execution starts, but the relocation for ASLR must be performed afterwards. <strong>The inherent design disagreement results in writable code pages, invalidating executable space protection.</strong></p>
</li>
<li><p>The SGX specification forces the use of a fixed address for security-critical data in an enclave.</p>
</li>
</ol>
<p>To address these issues, this paper proposes SGX-Shield. It introduces the concept of a multistage loader, which pushes back all ASLR-related operations to its secure in-enclave loader, hiding all security-sensitive operations from adversaries. SGX-Shield employs fine-grained randomization by splitting the code into a set of randomization units. SGX-Shield also enforces a software data execution protection to guarantee W⨁X in enclave’s code pages.</p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Threat-model"><a href="#Threat-model" class="headerlink" title="Threat model"></a>Threat model</h3><p>SGX-Shield assumes the same attack model as SGX, as our ASLR scheme is designed for SGX program. Our attack model consideration focuses on an attacker who wishes to exploit a vulnerability in the target program running in the enclave.</p>
<h3 id="Multistage-loader"><a href="#Multistage-loader" class="headerlink" title="Multistage loader"></a>Multistage loader</h3><p>SGX-Shield consists of three phases: preparation, bootstrapping, and secure in-enclave loading.</p>
<p>First, the preparation phase builds the target SGX program that a user wants to deploy. This built executable contains a secure in-enclave loader in its code section and the target SGX program in its data  section.</p>
<p>Second, in the bootstrapping phase, SGX-Shield performs the first part of multistage loading. The primary role of the bootstrapping phase is to create an enclave and initialize the secure in-enclave loader with the help of the untrusted kernel. Because the memory layout of an enclave is assumed to be visible to the non-trusted party in this phase, it is designed to make as minimal decision on resource provisioning as possible and defer all security-sensitive decisions to the secure in-enclave loader. This phase allocates code pages with read, write and execute permissions, and data pages with read and write permissions. The read/write permissions granted the code pages can be written with target SGX program (performing relocation as well), and then execute it. While the code pages can be writable and executable, SGX-Shield removes read and write permissions from these pages using a software-level enforcement.</p>
<p>Finally, the secure in-enclave loader loads the target SGX program into the memory space from its data pages. The secure in-enclave loader randomly picks the base address using the <code>RDRAND</code> instruction, which relies on the non-deterministic on-processor entropy. Then, it loads each section of the target program, where the address of each section is further adjusted independently at random. Before finishing the loading, SGX-Shield resolves all relocation information, which includes global variables, static variables, and the destination of all branches. At last step, SGX-Shield wipes out the secure in-enclave loader from the memory space, and the jumps to the entry point of the target SGX program.</p>
<h3 id="Fine-grained-randomization-for-enclaves"><a href="#Fine-grained-randomization-for-enclaves" class="headerlink" title="Fine-grained randomization for enclaves"></a>Fine-grained randomization for enclaves</h3><p><strong>Preparation.</strong> SGX-Shield relocates code at smaller granularity, called a randomization unit. Our implementation supports 32- and 64- byte units. During the compilation, SGX-Shield ensures that the terminating instructions of randomization unit are not fall-through cases. This is because fall-through assumes that randomization units are placed consecutively, which is not true when they are relocated for ASLR. Thus, for each fall-through case, SGX-Shield appends an unconditional branch instruction that points to the entry point of the next randomization unit.</p>
<p>Note that this instruction pass cannot be done naively at the intermediate language (IR) level. Even when IR does not have conditional branch instructions with fall-through features, the compiler backend may automatically introduce this.</p>
<p>Finally, the size of the randomization unit introduces a trade off between security and performance.</p>
<p><strong>Stage 1: Bootstrapping.</strong> We let the loading scheme in the bootstrapping phase over-estimate the memory space (both code and data pages are 32 MB) required to load the target program, as the size is directly related to the ASLR entropy.</p>
<p><strong>Secure in-enclave loading.</strong> Using the target SGX program in data pages, the secure in-enclave loader starts to place each randomization unit into previously allocated memory space. SGX-Shield randomizes all data objects as well, which includes stack, heap, and global variables.</p>
<p>Since SGX-Shield randomizes all code and data objects, all reference to memory objects including the absolute address and the PC-relative address must be determined after placing them. The secure in-enclave loader conducts the relocation for all memory objects after loading them.</p>
<h3 id="Software-DEP-in-enclaves"><a href="#Software-DEP-in-enclaves" class="headerlink" title="Software DEP in enclaves"></a>Software DEP in enclaves</h3><p>SGX-Shield enforces the <em>NRW boundary</em>, which is a virtual barrier between code and data pages. SGX-Shield guarantees this by (1) shepherding all memory access instructions and (2) ensuring only aligned control transfer are made.</p>
<p><strong>Shepherding memory access.</strong> In general, there are two types of memory access instruction: (1) explicit memory accessing instructions (e.g., <code>mov</code>, <code>inc</code>, <code>add</code> with memory operands in x86) and (2) stack accessing instructions (e.g., <code>push</code>, <code>pop</code>, <code>ret</code> or <code>sub</code> with an explicit stack register operand).</p>
<p>In order to prevent read or write attempts through the first type of instruction, SGX-Shield makes sure that a memory address to be accessd is always higher tha the NRW boundary. SGX-Shield reserves the register <code>r15</code> to hold the boundary, and transform the original instruction such that it accesses memory using a positive offset from the NRW boundary. We then enfoce that the maximum positive offset is smaller than 2^32 to ensure that the instruction never accesses memory beyond the NRW boundary.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Before enforcing non-writable code</span><br><span class="line">mov [rdx + 0x10], rax</span><br><span class="line"></span><br><span class="line">; After enforcing non-writable code</span><br><span class="line">; (r15 is initialized to hold the NRW boundary)</span><br><span class="line">; (enfoce rdx &gt;= r15)</span><br><span class="line"></span><br><span class="line">lea r13, [rdx + 0x10]       ; r13 = rdx + 0x10</span><br><span class="line">sub r13, r15                ; r13 = r15 - r13</span><br><span class="line">mov r13d, r13d              ; r13 = r13 &amp; 0xffff&#x27;ffff</span><br><span class="line">mov [r15 + r13], rax        ; *(r15 + r13) = rax</span><br></pre></td></tr></table></figure>

<p>To enfoce no-writable code pages on stack accessing instruction, SGX-Shield makes sure that a stack pointer (i.e., <code>rsp</code>) never points to code pages. To handle instructions that adjust stack pointer implictly, we simply map a guard page (i.e, no permission is granted) at the top and buttom of the stack area.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Before enforcing non-writable code</span><br><span class="line">sub rsp, 0x40</span><br><span class="line"></span><br><span class="line">; After enforcing non-writable code</span><br><span class="line">; (r15 is initialized to hold the NRW boundary)</span><br><span class="line">; (enfoce rdx &gt;= r15)</span><br><span class="line">sub rsp, r15                ; rsp = rsp - r15</span><br><span class="line">sub rsp, 0x40               ; rsp = rsp - 0x40</span><br><span class="line">mov esp, esp                ; rsp = rsp &amp; 0xffff&#x27;ffff</span><br><span class="line">lea rsp, [rsp + r15]        ; rsp = rsp + r15</span><br></pre></td></tr></table></figure>

<p><strong>Ensuring aligned control transfer.</strong> SGX-Shield restricts the control transfers only to the entry point of the randomization unit. It enforces that there is only one way to decode instructions, ensuring that only shepherded memory access takes place. This enforcement is performed for all control transfer instructions, including indirect branches as well as return instruction.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; Before enforcing aligned indirected branch</span><br><span class="line">jmp rax</span><br><span class="line"></span><br><span class="line">; After enforcing aligned indirected branch</span><br><span class="line">; (enforce rax % [random unit size] = 0)</span><br><span class="line">and rax, $-0x20             ; rax = rax &amp;&amp; 0xffff&#x27;ffff&#x27;ffff&#x27;ffe0</span><br><span class="line">jmp rax                     ; jump to the address pointed by rax</span><br></pre></td></tr></table></figure>

<h3 id="Isolating-access-to-security-critical-data"><a href="#Isolating-access-to-security-critical-data" class="headerlink" title="Isolating access to security-critical data"></a>Isolating access to security-critical data</h3><p>SGX places the page for the State Save Area (SSA) at a known location and does not permit its relocation. We using software DEP mechanism implements SFI to isolate SSA.</p>
<h2 id="Implemenataion"><a href="#Implemenataion" class="headerlink" title="Implemenataion"></a>Implemenataion</h2><p><strong>Preparation.</strong> The preparation phase includes an LLVM compiler 4.0, a tatic linker, and a sign tool of Intel SGX SDK for Linux. By modifying the backend of LLVM, we insert two kinds of instructions: (1) unconditional jump instructions (instead of fall-through) at the end of randomization unit and (2) instructions to enforce the software DEP. In addition, the LLVM emits each randomization unit as a symbol. The fine-grained symbol information is used in the secure in-enclave loading.</p>
<p>The current version of SGX-Shield supports only static linking. We modify Intel SDK for Linux to provide the enclave program with sufficient code and data pages for shuffling. We emebed the binary of enclave program into the binary of secure in-enclave loader as a section using the <code>objcopy</code> command.</p>
<p><strong>Bootstrapping.</strong> The bootstrapping simply creates an enclave and loads the secure in-enclave loader to the enclave.</p>
<p><strong>Secure in-enclave loader.</strong> The secure in-enclave loader is a dynamic loader that conducts the randomization unit-level memory object loading and relocations. It resolves the relocation information for all the memory reference including the absolute address and the PC-relative address. We implements this (parsing the ELF file, randomly loading and relocation ) with a single C file.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/Shuffler-Fast-and-Deployable-Continuous-Code-Re-Randomization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/29/Shuffler-Fast-and-Deployable-Continuous-Code-Re-Randomization/" class="post-title-link" itemprop="url">Shuffler: Fast and Deployable Continuous Code Re-Randomization</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-29 19:51:07" itemprop="dateCreated datePublished" datetime="2019-04-29T19:51:07+08:00">2019-04-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We propose a system, called <em>Shuffler</em>, which provides a deployable defense against JIT-ROP and other code reuse attacks. Other defenses have had significant barriers to deployment: some utilize a custom hypervisor; others involve a modified compiler, runtime, or operating system kernel. In comparison, Shuffler runs in userspace along side the target program, and requires no system modification beyond a minimal patch to the loader.</p>
<p>Shuffler operates by performing continuous code re-randomization at runtime, within the same address space as the program it defends. Additional, we bootstrap into a self-hosted and self modifying <em>egalitarian</em> environment — Shuffler always shuffles itself.</p>
<p>We achieve a <em>shuffle period</em> on the order of tens of milliseconds, so fast that is nearly impossible to form a complete exploit. Shuffler creates new function permutations asynchronously in a separate thread, and then atomically migrates program execution from one copy of code to the next. This migration requires a vanishingly small global pause time, as program threads continue to execute unhindered 99.7% of the time. Thus, if the host machine has a spare CPU core, shuffling at faster rates does not significant impact the target’s performance.</p>
<p>Our system operates on program binaries, analyzing them and performing binary rewriting.</p>
<h2 id="Threat-model"><a href="#Threat-model" class="headerlink" title="Threat model"></a>Threat model</h2><p>We assume that the protection against code injection (W^X) is in place, and that an x86_64 architecture is in use. Our system does not require (and, in fact, is orthogonal to) other defensive techniques.</p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>Shuffer is design to require minimal system modifications. To aviod kernel changes, it runs entirely in userspace; to avoid requiring source or a modified compiler, it operates on program binaries. Performing re-randomization soundly requires complete and precise pointer analysis, we leverage symbol and relocation information from the (unmodified) compiler and linker.</p>
<p>At load-time, Shuffler transforms the program’s code using binary rewriting. The goal of rewriting is to be able to track and update all code pointers at runtime. We leverage our complete and accurate disassembly to transform all code pointers into unique identifiers —indices into a <em>code pointer table</em>. These indices cannot be altered after load time. We handle return addresses (dynamically generated code pointers) differently, encrypting them on stack rather than using indices.</p>
<p>Our system performs re-randomization at the level of functions within a specific <em>shuffle period</em>, a randomization deadline specific in milliseconds. Shuffler runs in a separate thread and prepares a new shuffled copy of code within this deadline. The vast majority of the re-randomization process is performed as asynchronously: creating new copies of code, fixing up instruction displacements, updating pointers in the code table. The threads are globally paused only to atomically update return addresses. Since any existing return addresses reference the old copy of code, we must revisit saved stack frames and update them.</p>
<p>To prevent our own code from being used in a code reuse attack, Shuffer randomizes it the same way it does all other code. In fact, our scheme uses binary rewriting to transform all code in a userspace application (the program, Shuffler, and all shared libraries) into a single code sandbox, essentially turning it into a staticlly linked application at runtime.</p>
<h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h3><p><strong>Changing function pointer behavior.</strong> Normal program’s memory layout remains consistent and function pointers have indefinite lifetime. Re-randomization introduces an arbitrary lifetime for each block of code, and it becomes an exercise in avoiding dangling code pointers.</p>
<p>Hence, we need to accurately track and update every code pointer during the re-randomization process. We opt to statically transform all code pointers into unique identifiers—namely, indices into a hidden <em>code pointer table</em>. Then wherever the code pointer is copied throughout memory, it will continue to refer to the same entry in the table.</p>
<p>Some code pointers are dynamically generated, in particular, return addresses on the stack. We could dynamically allocated table indices, but <code>call</code>/<code>ret</code> pairs are highly optimized, and replacing them with table mechanism would involve a large performance degradation. Instead, we allow ordinary calls to proceed as usual, and at re-randomization time we unwind the stack and update return addresses to new values. Rather than leave return addresses exposed on the stack, we encrypt each address with an XOR cipher.</p>
<p><strong>Augmented binary analysis.</strong> We propose a <em>augment binary analysis</em>, which involves analyzing program binaries that have additional information included by the compiler.</p>
<p>The common problems with binary analysis are distinguishing code from data, and distinguishing pointers from integers. To tackle these problems, we require that (i) the compiler preserve the symbol table, and (ii) that the linker preserve relocations. The symbol table indicates all valid <code>call</code> targets and makes disassembly straightforward—we iterate through symbols and disassemble each one independently. Reloactions are used to indicate portions of an object file (or executable) that needs to be patched up once its base address is known. Since each base address is initially zero, every absolute code pointer must have a relocation—but as object files are linked together, most code pointers get resolved and their relocations are discarded. We simply ask the linker to preserve these relocations.</p>
<p><strong>bootstrapping into shuffled code.</strong> Shuffler defends its own code the same way it defends all other code. Shuffled code cannot start running until the code pointer table is initialized, requiring some unshuffled startup code. Shuffled and original code are incompatible if they use code pointers; the process of transforming code pointers to indices overwrites data that the original code accesses, and then the original code will no longer execute correctly. Hence, we would have to call new function as they became available, and carefully order the function-pointer rewrite process to avoid invalidating any functions currently on the call stack.</p>
<p>Instead, we opted for a simpler and more general solution. Shuffler is split into two stages, a minimal and a runtime stage. The minimal stage is completely self-contained, and it can safely transform all other code, including <code>libc</code> and the second-stage Shuffle. The it jumps to the shuffled second stage, which erases the previous stage (and all other original code). The second stage inherits all the data structures created in the first so that is can easily create new shuffled code copies.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Code pointers are directed through the code pointer table and return address are stored on the stack, encrypted with an XOR cipher. In each shuffle period, Shuffler makes a new copy of code, updates the code pointer table and sends a signal to tell all threads (including its self); each thread unwinds and fixes up its stack. Shuffler waits on a barrier until all threads have finished unwinding, then erases the previous code copy.</p>
<p>Our Shuffler Implementation supports many system-level features, including shared libraries, multiple threads, forking, <code>&#123;set/long&#125;jmp</code>, system call re-entry, and signals.</p>
<h3 id="Transformation-to-support-shuffling"><a href="#Transformation-to-support-shuffling" class="headerlink" title="Transformation to support shuffling"></a>Transformation to support shuffling</h3><p><strong>Code pointer abstraction.</strong> We allocate the code pointer table at load-time and set the base address of the <code>GS</code> segment at it. Then, we transform every function pointer at its initialization point from an address value to an index into this table. Jump tables are handled similarily, with indices assigned to each offset within a function that is used as a target.</p>
<p>Every instruction which originally used a function pointer value is rewritten to instead indirect through the <code>%gs</code> table. This adds an extra memory dereference. Since x86 instruction can contain at most one memory reference, if there is already a memory reference, we use the caller-saved register <code>%r11</code> as scratch space. For (position-dependent) jump tables, there is no register we can safely overwrite, so we use a thread-local variable allocated by Shuffler as a scratch space (denoted as <code>%fs: 0x88</code>).</p>
<p><strong>Return address encryption.</strong> We encrypt return address on the stack with a per-thread XOR key. We reuse the stack canary storage location for our key; our scheme operates similarly to stack canaries, but does not affect the layout of the stack frame. We add two instruction <code>mov %fs:0x28, %r11; xor r11, (%rsp)</code> at the beginning of every function and before every exit jump; after each <code>call</code>, we insert a <code>mov</code> instruction to erase the now-visible return address on the stack. We again use <code>%r11</code> as a scratch register, since it is a caller-saved register according to the x86-64 ABI.</p>
<p><strong>Displacement reach.</strong> A normal call instruction has a 32-bit displacement and must be within ± 2GB of its target to “reach” it. Shared libraries use Procedure Linkage Table trampolines to jump anywhere in the 64-bit address space.</p>
<h3 id="Completeness-of-disassembly"><a href="#Completeness-of-disassembly" class="headerlink" title="Completeness of disassembly"></a>Completeness of disassembly</h3><p>While shuffling some libraries and programs, we encountered myriad special cases. The issues boil down to: (a) dealing with inaccurate/missing metadata, especially in the symbol table; (b) handling special types of symbols and relocations; and (c) discovering jump table entries and invocations.</p>
<p>Our major challenge is identifying whether relocations are part of jump tables, and distinguishing between indirect tail-recursive jumps and jump-table jumps. If we fail to realize a relocation in a jump table, we will calculate its target incorrectly and the jump will branch to the wrong location; if we decide that a jump table’s jump is actually tail recursive, we will insert return-address decryption instruction before it, corrupting <code>%11</code> and scrambling the top of the stack.</p>
<p>GCC generates jump tables differently in position-dependent and position-independent code (PIC). Position-dependent jump tables use 8-byte direct pointers, and are nearly always invoked by an instruction of the form <code>jmpq *(%rax, %rbx, 8)</code> in any optimization level. PIC jump tables use 4-byte relative offsets added to the address of the beginning of the table—and the <code>lea</code> that loads the table address may be quite distant from the final indirect jump. To find PIC jump tables, we use outgoing <code>%rip</code>-relative references from functions as bounds and check if they point at sequences of relocation in the data section.</p>
<p>It is difficult to tell whether a <code>jmpq *%rax</code> instruction is used for indirect tail recursion, or a PIC jump table. We use a liner sweep to record <code>push</code> instructions in the function’s first basic block, and keep a log of the <code>pop</code> instruction seen since the last jump. If an indirect jump is preceded by <code>pop</code> instructions that are in the reverse order of the <code>push</code> instructions, we assume we have found a function epilogue and that the jump is indirect tail recursive.</p>
<h3 id="bootstrapping-and-requirements"><a href="#bootstrapping-and-requirements" class="headerlink" title="bootstrapping and requirements"></a>bootstrapping and requirements</h3><p>We carefully bootstrap into shuffled code using two libraries (stage 1 and stage 2), so that the system never overwrites code pointers for the module that is currently executing. The constructor of stage 1 is called before any other via the linker mechanism <code>-z initfirst</code>. Then, stage 1 make sure all other constructors run in shuffled code. The last constructor to be called is stage 2’s own constructor; stage 2 creates a dedicated Shuffler thread.</p>
<ol>
<li><p><strong>Compiler flags.</strong> We require the program binary and all dependent libraries to be compiled with <code>-Wl, -q</code>, a link flag that preserves relocations, and <code>-gdwarf-2</code>, when compiling with c++. Since we require symbols and DWARF unwind information, the user must avoid <code>-s</code> and <code>-fno-asynchronous-unwind-tables</code>.</p>
</li>
<li><p><strong>System modifications.</strong> The <code>-z initfirst</code> loader feature currently only supports one shared library, and <code>libpthread</code> already use it. Since shuffled functions must be within ± 2GB of each other, we simplify Shuffler’s task and map all ELF <code>PT_LOAD</code> sections into the lower 32 bits of the address space. Finally, we disabled a manually-constructed jump table in the <code>vfprintf</code> of <code>glibc</code>.</p>
</li>
</ol>
<h3 id="Implementation-Optimizations"><a href="#Implementation-Optimizations" class="headerlink" title="Implementation Optimizations"></a>Implementation Optimizations</h3><p><strong>Generating new code.</strong> The Shuffer thread maintains a large code <em>sandbox</em> that stores shuffled functions. In each shuffle period, every function within the sandbox is duplicated and the old copies are erased. The sandbox is split in half, so that one half may be erased with a single <code>mprotect</code> system call. We maintain servral <em>buckets</em> and each function is placed in a random bucket; when a bucket fills up, it is committed with an <code>mprotect</code> call and a fresh bucket is allocated.</p>
<p>We use a Binary Indexed Tree for function allocations. Our tree keeps track of all valid addresses for new buckets, storing disjoint intervals; it also tracks the sum of interval lengths.</p>
<p><strong>Stack unwinding.</strong> We wrote a custom unwind library with a straightforward DWARF state machine.</p>
<p><strong>Binary rewritting.</strong> Suffler’s load-time transformations are all implemented through binary rewriting. We disassemble each function with diStorm and produce intermediate data structures which we call <em>rewrite blocks</em>. Rewrite blocks are similar to basic blocks but may be split at arbitrary points to accommodate newly inserted instructions.</p>
<h2 id="Security-analysis"><a href="#Security-analysis" class="headerlink" title="Security analysis"></a>Security analysis</h2><h3 id="Analysis-of-traditional-attacks"><a href="#Analysis-of-traditional-attacks" class="headerlink" title="Analysis of traditional attacks"></a>Analysis of traditional attacks</h3><p><strong>Normal ROP.</strong> Absolutely.</p>
<p><strong>Indirect JIT-ROP.</strong> Indirect JIT-ROP relies on leaked code pointers and computes gadgets accordingly. Because code pointers are replaced with table indices, the attack cannot gather code pointers from data structures; nor can the attacker infer code pointers from data pointers, since the relative offset between code and data sections changes continuously.</p>
<p><strong>Direct JIT-ROP.</strong> In direct JIT-ROP, the attacker is assumed to know one valid code address, and employs a memory disclosure recursively, harvesting code pages and finding enough gadgets for a ROP attack. The entire attack must be completed within the shuffle period of <em>r</em> milliseconds.</p>
<p><strong>Blind ROP.</strong> BlindROP tries to infer the layout of a server process by probing it workers, which are <code>fork</code>ed from the parent and have the same layout. The attack uses a timing channel to inter information about the parent based on whether the child crashed or not. Shuffler easily thwarts this attack because it randomizes child and parent processes independently.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/Enforcing-kernel-security-invariants-with-data-flow-integrity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/21/Enforcing-kernel-security-invariants-with-data-flow-integrity/" class="post-title-link" itemprop="url">Enforcing kernel security invariants with data-flow integrity</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-21 20:54:22" itemprop="dateCreated datePublished" datetime="2019-04-21T20:54:22+08:00">2019-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>More recently, researchers have demonstrated the feasibility of enforcing Control-Flow Integrity (CFI) in kernel space. However, in addition to problems discovered in CFI, a more fundamental problem is that because OS kernel are mainly data-driven, CFI can be easily by passed by non-control-data attacks.</p>
<p>The objective of this work is to provide a defense system that is both <em>principled</em> and <em>practical</em>. We achieve the first goal by utilizing Data-Flow Integrity. Similar to CFI, DFI guarantees that runtime data-flow cannot deviate from the data-flow graph generated from static analysis. For example, data from a string buffer should never flow to the return address on the stack (control-data) or the <code>uid</code> (non-control-data). In this work, we focus on enforcing invariants that are related to kernel access control mechanisms (a.k.a., reference monitors) so as to defeat privilege escalation attacks.</p>
<p>While this approach sounds intuitive at high level, enforcing it with practical runtime performance overhead is very challenging. First, access control checks are scattered through out the kernel, and related data are mixed with other data. Therefore, the protection must be deployed kernel-wide. Moreover, without hardware support, software-based DFI implementation can be every expensive.</p>
<p>We propose a system called KENALI, which consists of two key techniques. Our first technique, INFERDISTS, is based on the observation that although the protection has to be kernel-wide, only a small portion of data is essential for enforcing the two security invariants. For ease of discussion, we refer to this set of data as <em>distinguishing regions</em>. Our technique, INFERDISTS, overcomes these challenges with a new program-analysis-based approach. Specifically, by leveraging implicit program semantics, INFERDISTS is able to infer security checks with out any manual annotation. After this, by considering both data and control-dependencies of data that can affect each security check, as well as sensitive pointers, INFERDISTS generates a <em>complete</em> set of distinguishing regions.</p>
<p>Our second technique, PROTECTDISTS, is a new technique to enforce DFI over the distinguishing regions. PROTECTDISTS uses a two-layer protection scheme. The first layer provides a coarse-grained but low overhead data-flow isolation that prevents illegal data-flow from non-distinguishing regions to distinguishing regions. After this separation, the second layer the enforce fine-grained DFI over the distinguishing regions. <strong>Because the access pattern to most data in the distinguishing regions is very asymmetric, read accesses are usually magnitudes more frequent than write accesses</strong>, PROTECTDISTS employs the Write Integrity Test (WIT).</p>
<h2 id="Problem-scope"><a href="#Problem-scope" class="headerlink" title="Problem scope"></a>Problem scope</h2><h3 id="Threat-model-and-assumptions"><a href="#Threat-model-and-assumptions" class="headerlink" title="Threat model and assumptions"></a>Threat model and assumptions</h3><p>We only consider attacks that originate from unprivileged code. The attacker can read and write word-size value at an arbitrary memory address.</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ol>
<li><p><strong>Simple rooting attacks.</strong> CVE-2013-6282 allows attacker to read and write arbitrary kernel memory, which matches our adversary model. (i) Retrieving the address of <code>prepare_kernel_cred()</code> and <code>commit_creds()</code>. Depending on the target system, they can be at fixed address, or obtainable from the kernel symbol table (<code>kallsyms_addresses</code>); (ii) Invoking <code>prepare_kernel_cred()</code> and pass the results to <code>commit_creds()</code>, then the kernel will replace the credential of the current thread with one of root privilege.</p>
</li>
<li><p><strong>Bypassing CFI with non-control-data attacks.</strong> The above attack can be prevented by kernel wide CFI. But CFI can be easily bypassed by locating the <code>cred</code> structure and overwriting the <code>euid</code> field. The <code>cred</code> structure can be located in many ways. (i) if <code>kallsyms</code> is available and contains the address of <code>init_task</code>, we can traverse the process list to locate the <code>task_struct</code> of the current process, then <code>task_struct-&gt;cred</code> (ii) if there is a vulnerability that leaks the stack address, attackers can directly obtain the address of the <code>thread_info</code>, then follows the links to locate the <code>task_struct</code>.</p>
</li>
<li><p><strong>Diversity of non-control-data attacks.</strong> From the target kernel we evaluated, we found that 2419 data structures contain critical data.</p>
</li>
</ol>
<h2 id="Technical-approach"><a href="#Technical-approach" class="headerlink" title="Technical approach"></a>Technical approach</h2><h3 id="Inferring-distinguishing-regions"><a href="#Inferring-distinguishing-regions" class="headerlink" title="Inferring distinguishing regions"></a>Inferring distinguishing regions</h3><p>The challenge is that for security, our solution must be sound (i.e., no false positives), but for performance, we want the size of the inference result to be as small as possible.</p>
<ol>
<li><p><em>Control-Data</em></p>
</li>
<li><p><em>Non-Control-Data:</em> Access controls are implemented as security checks, and while a kernel may have many security checks scattered throughout different components, they all follow one consistent semantic: <strong>if a security check fails, it should return a security related error codes.</strong> Leveraging this observation, we can collect security check without manual annotation. Then, distinguishing regions can be constructed via standard dependency analysis over the conditional variables of security check.</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acl_permission_check</span> <span class="params">(struct inode * inode, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode = inode -&gt; i_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_cred -&gt; fsuid == inode -&gt; i_uid)</span><br><span class="line">        mode &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in_group_p (inode -&gt; i_gid))</span><br><span class="line">        mode &gt;&gt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; ~mode &amp; (MAY_READ | MAY_WRITE | MAY_EXEC)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We must consider branches that dominate a security check. However, naively including all dominators will introduce many false positives. To reduce false positives, INFERDISTS conservatively excludes two cases: (i) a branch can lead to non-related error return and (ii) a branch instruction is post-dominated by either a security check or checks in (a).</p>
<ol start="3">
<li><em>Sensitive pointers:</em> pointers to sensitive regions must be protected as well; otherwise, attackers can indirectly control the data in distinguishing regions by manipulating the pointers.</li>
</ol>
<h3 id="Protecting-distinguishing-regions"><a href="#Protecting-distinguishing-regions" class="headerlink" title="Protecting distinguishing regions"></a>Protecting distinguishing regions</h3><p>The challenge for this step is how to minimize the performance overhead on commodity processors that lack support for fine-grained data-flow tracking. To address this challenge, our key observation is that, <strong>after separating the memory into distinguishing region and non-distinguishing region, there could be three types of data-flow: (i) within non-distinguishing region, (ii) between two regions, and (iii) within distinguishing regions.</strong></p>
<p>We design a two-layer scheme: lightweight data-flow isolation on second type, and more expensive DFI enforcement to prevent illegal data-flow of the third type.</p>
<ol>
<li><p><em>Data-flow isolation:</em> We explored the feasibility of hardware-based data-flow isolation for AArch64. We developed a novel, virtual address space-based isolation mechanism by tagging the TLB with an identifier (i.e., Process Context ID)</p>
</li>
<li><p><em>Write Integrity Test:</em> In addition to preventing illegal data-flow from non-distinguishing regions to distinguishing regions, we use DFI to prevent illegal data-flow within distinguishing regions. We leveraged the write integrity test.</p>
</li>
<li><p><em>Shadow Objects:</em> As a hardware protection unit (e.g., page) may contain both distinguishing and non-distinguishing regions, once we write-protect that page, we also have to pay additional overhead for accessing non-distinguishing regions. Our solution to this problem is <em>shadow objects</em>: a normal copy for non-distinguishing regions and a shadow copy for distinguishing regions.</p>
</li>
<li><p><em>Safe Stack:</em> Using <em>shadow stack</em>.</p>
</li>
</ol>
<h2 id="A-prototype-for-Android"><a href="#A-prototype-for-Android" class="headerlink" title="A prototype for Android"></a>A prototype for Android</h2><h3 id="Data-flow-isolation"><a href="#Data-flow-isolation" class="headerlink" title="Data-flow isolation"></a>Data-flow isolation</h3><ol>
<li><p><em>AArch64 VMSA (Virtual Memory System Architecture):</em> The AArch64 supports a maximum of 48-bit virtual address (VA), which is split into two parts: the bottom part is for user space, and the top part is for kernel space.</p>
</li>
<li><p><em>Shadow Address Space:</em> Our data-flow isolation implementation leverages the ASID (Address Space IDentifier) tagging feature and is based on shadow address space. Under this isolation scheme, the same physical page is mapped into two different address spaces with different permissions.</p>
</li>
<li><p><em>Atomic Primitive Operations:</em> Considering the security of the shadow address space, we make every operation under the shadow address space atomic, such as write a single data, <code>memcpy</code> and <code>memset</code>.</p>
</li>
</ol>
<h3 id="MMU-integrity"><a href="#MMU-integrity" class="headerlink" title="MMU integrity"></a>MMU integrity</h3><p>Three additional security invariants: (i) <strong>MMU isolation:</strong> Only MMU management code can modify MMU-related data. (ii) <strong>Code integrity:</strong> Kernel code integrity. (iii) <strong>Dedicated entry and exit:</strong> MMU management code is always invoked through dedicated entries and exits.</p>
<h3 id="Shadow-objects"><a href="#Shadow-objects" class="headerlink" title="Shadow objects"></a>Shadow objects</h3><ol>
<li><p><em>SLUB Allocator:</em> In our target kernel, most distinguishing regions are allocated from the SLUB allocator. When SLUB allocates pages for a new slab, we allocate a shadow slab of the same size and map it read-ony at a fixed offset (4GB) from the original slab.</p>
</li>
<li><p><em>Global Objects:</em> While most distinguishing regions are dynamically allocated, some of them are statically allocated in the form of global objects. We allocate shadow memory for entire <code>.data</code> section, copy all the contents to populate the shadow memory and then map it.</p>
</li>
<li><p><em>Analysis and instrumentation:</em> We first identify all allocation sites for objects in distinguishing regions and modify the allocation flag. Next, we identify all pointer arithmetic operations for accessing distinguishing regions and modify them to access the shadow objects. Finally, we identify all write to distinguishing regions, and modify them to invoke our atomic operations instead. <strong>inline assembly needs to be handled manually.</strong></p>
</li>
</ol>
<h3 id="Kernel-stack-randomization"><a href="#Kernel-stack-randomization" class="headerlink" title="Kernel stack randomization"></a>Kernel stack randomization</h3><p>We map kernel stack to a unused AV above the logical map (top 256GB), because kernel stacks are small (16KB), we have around 24-bit of entropy available.</p>
<p>We contain the risk of information leak as follows. First, we mark functions like <code>copy_to_user</code> as unsafe. Then, we store the real stack pointer in a redirection table and replace the original pointer with an index into the table, which mapped as inaccessible under normal context. So does the page tables of shadow stack.</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Distinguishing-regions-discovery"><a href="#Distinguishing-regions-discovery" class="headerlink" title="Distinguishing regions discovery"></a>Distinguishing regions discovery</h3><p>For control data, our analysis identified 6192 code pointers, 991 are function args, 11 are return addresses, both of them are protected by safe stack. 1490 are global variables, and 3699 are fields over 783 data structures.</p>
<p>For non-control data, the error codes we used were <code>EPERM</code>, <code>EACCES</code>, and <code>EROFS</code>. 526 functions as capable of returning permission-related errors; 1077 function args, 279 global variable, and 1731 data fields over 855 data structures as security-critical.</p>
<p>For sensitive pointers, we combined both control and non-control data to result a total of 4096 data fields over 1316 data structures as the sensitive pointer inference. Futher, there are 4002 fields over 1103 structures as distinguishing regions. <strong>For the target kernel, we should protect about 27.30% of all data structures.</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/Shining-Light-on-Shadow-Stacks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/11/Shining-Light-on-Shadow-Stacks/" class="post-title-link" itemprop="url">Shining Light on Shadow Stacks</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-11 21:57:40" itemprop="dateCreated datePublished" datetime="2019-04-11T21:57:40+08:00">2019-04-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Code pointers can be divided into two categories: <em>backward edge</em>, i.e., return address or <em>forward edge</em> pointers, such as function pointers or virtual table pointers. Control-Flow Integrity protects forward edges and assumes that the backward edges are protected. However, stack canaries and safe stacks are the strongest backward edge protection available in mainline compilers, and both are easily bypassed by information leaks.</p>
<p>Shadow stacks enforce stack integrity, protecting against stack pivot attacks and overwriting return addresses. Shadow stacks store the return address in a separate, isolated region of memory that is not accessible by the attacker. Upon returning, the integrity of the program return address is checked against the protected copy on the shadow stack. Two shadow stack designs have been proposed: compact shadow stacks, which rely on a separate shadow stack pointer, and parallel shadow stacks, which place the shadow stack at a constant offset to the orignal stack. These existing shadow stack designs suffer from a combination of poor performance, i.g., greater than 5%, and difficulty supporting C and C++ programming paradigms, i.g., multi-threading and exception handling.</p>
<h2 id="Shadow-stack-design-space"><a href="#Shadow-stack-design-space" class="headerlink" title="Shadow stack design space"></a>Shadow stack design space</h2><p>For any shadow stack mechanism to be adopted in practice, it must be highly performance, compatible with existing code, and provide meaningful security.</p>
<p>Shadow stack mechanisms are defined by how they map from the program stack to the shadow stack. This includes the type of mapping, as well as how the mapping is encoded in the protected binary.</p>
<h3 id="Shadow-stack-mechanisms"><a href="#Shadow-stack-mechanisms" class="headerlink" title="Shadow stack mechanisms"></a>Shadow stack mechanisms</h3><p>Direct mapping schemes for parallel shadow stacks use the location of the return address on the program stack to directly find the corresponding entry on the shadow stack. The parallel shadow stack is as large as the program stack, and a simple offset maps from the program stack to the shadow stack.</p>
<p>Indirect mapping schemes for compact shadow stacks maintain a shadow stack pointer, equivalent to the stack pointer used for the program stack. The shadow stack pointer points to the last entry on the shadow stack, exactly as the stack pointer does for the program stack. Maintaining a shadow stack pointer allows a compact shadow stack to allocate significantly less memory, as only room for the return address is required, instead of duplicating the program stack.</p>
<p>Parallel and compact shadow stacks have different compatibility implications. if calls and returns were always perfectly matched, there would be no difference. However, the <code>setjump / longjump</code> functionality of C, which allows jumping mutiple stack frames back up the stack, and the equivalent stack unwinding capability used by C++ for exception handling, both break the assumption of perfectly matched calls and returns. Consequently, this leads to additional overhead for indirect shadow stack mapping schemes, while having no effect on direct mapping schemes.</p>
<h3 id="Shadow-stack-mechanisms-based-on-register"><a href="#Shadow-stack-mechanisms-based-on-register" class="headerlink" title="Shadow stack mechanisms based on register."></a>Shadow stack mechanisms based on register.</h3><p>All 64 bit architecture have at least 16 general purpose registers, and it is possible to dedicate a general purpose register to the shadow stack mechanism.</p>
<p><strong>Parallel shadow stack mechanisms:</strong> The existing mechanism places shadow stack entries at a constant offset from the program stack, which is very efficient but higher memory overhead and lower security. However, the compatibility concerns arise from requiring a constant offset, which is limited to 32 bits for immediate operand in x86, from the program to the shadow stack from all threads, severely constraining the address space layout for programs with many threads, such as browsers.</p>
<p>To mitigate the compatibility and security concerns, we propose a new parallel shadow stack mechanism, which encodes the offset in a dedicated register, allowing the offset to the shadow stack to be determined at runtime. Further, the offset may vary from thread to thread as register are thread as register are thread local, and the offset can be set when the thread is created.</p>
<p><strong>Compact Shadow Stack Mechanisms:</strong> For compact shadow stack mechanisms, the key question is where to store the shadow stack pointer. The shadow stack pointer will be dereferenced twice in every function: once in the prologue to push the correct return address, and once in the epilogue to pop the shadow return address.</p>
<p>The earliest approach of a shadow stack scheme with a dedicated register focuses on x86_32. We rejuvenate this idea for 64 bit architectures as gerneral purpose register provide the fastest possible option for storing the shadow stack pointer.</p>
<h2 id="Shadow-stack-implementations"><a href="#Shadow-stack-implementations" class="headerlink" title="Shadow stack implementations"></a>Shadow stack implementations</h2><p>Each of the shadow stack mechanisms we evaluate is implemented as a backend compiler pass in LLVM 7.0.0. In particular, each shadow stack mechanism must instrument calls and returns to update its shadow stack and validate the return address before using it to transfer control. We show that the best way to accomplish this is to instrument function prologues and epilogues.</p>
<h3 id="Instrumented-locations"><a href="#Instrumented-locations" class="headerlink" title="Instrumented locations"></a>Instrumented locations</h3><p>The instrumentation is responsible for pushing the return address to the shadow stack, and updating the shadow stack pointer for compact shadow stacks. Returns must be instrumented to pop from the shadow stack and validate the program return address in the function epilogue before the control-flow transfer to mitigate control-flow hijacking attacks.</p>
<p>The elegant solution for instrumenting calls is to place the protection in the function prologue. In this way, the <em>function</em> is protected, not particular call sites. instrumenting function prologues and epilogues maintains the symmetry of calls and returns naturally, as each will be executed for every function call.</p>
<p>On x86, instrumenting the function prologues results in  a one-instruction wide Time Of Check To Time Of Use (TOCTTOU) opportunity due to architecture limitations. The <code>call</code> instruction pushes the return address to the stack where it may be modified by an attacker before it is picked up by the prologue in the called function. <strong>Architectures, such as ARM</strong>, where the address of the called function is stored in a register, do not have this limitation.</p>
<p>Our proposed mechanism halves the attack window as we jump to the verified address, but not fully mitigate the TOCTTOU window. Intel Control Enforcement Technology (CET) introduces a shadow stack based on hardare and compiler support. This extension will mitigate the TOCTTOU window on x86 and simplify the required instrumentation.</p>
<p>Stack unwinding mechanisms such as <code>longjmp</code> and c++ exceptions require additional instrumentation for compact shadow stacks. We must be able to unwind to the correct point on the shadow stack as well. Simply matching return addresses does not suffice for this, as the same address can show up multiple times in the call stack due to, e.g., recursive calls. To deal with this, our compact shadow stack implementations also push the stack pointer, i.g., <code>rsp</code>. The stack pointer and return address uniquely identify the stack frame to unwind to, allowing our mechanisms to support stack unwinding.</p>
<p>For the shadow stack mechanisms that use a register to encode the shadow stack mapping, ensuring compatibility with unprotected code constrains our selection of register. Our implementations use <code>r15</code> in practice.</p>
<h3 id="Runtime-support"><a href="#Runtime-support" class="headerlink" title="Runtime support"></a>Runtime support</h3><p>Our runtime library is responsible for allocating the shadow stack, and hooking <code>setjump</code> and <code>longjmp</code>. We add a new function in the <code>pre_init</code> array that initializes the shadow stack for the main program thread. This function also initializes the shadow stack pointer for compact shadow stack mappings.</p>
<p>For compact shadow stack mappings to support multi-threading and libunwind, we preload a small support library. It intercepts calls to <code>pthread_create</code> and <code>pthread_exit</code> to set up and tear down shadow stacks for additional threads.</p>
<h3 id="Shadow-stack-epilogue-optimizations"><a href="#Shadow-stack-epilogue-optimizations" class="headerlink" title="Shadow stack epilogue optimizations"></a>Shadow stack epilogue optimizations</h3><p>Traditionally, shadow stacks have relied on compare instructions to validate the shadow return address and program return address are equivalent, which potentially leads to pipe line stalls even with branch prediction. Consequently, as an optimization, we explore two different methods to optimize this validation.</p>
<p>To replace the compare instruction, we propose an <code>xor</code> of the program return address and shadow return address. This will result in <code>0</code> bits anywhere the two are identical, and <code>1</code>s elsewhere. x86 has an instruction, <code>popcnt</code>, that returns the number of bits set to <code>1</code>. Consequently, if the <code>popcnt</code> of the <code>xor</code> of the program return address and shadow return address is <code>0</code>, then two are equivalent.</p>
<p>We leverage the memory managment unit (MMU) to compare the <code>popcnt</code> to zero as a side effect by creating a protection fault: triggering a page fault.</p>
<ol>
<li><p>By shifting this value left 48 and <code>or</code> it into the return address, we create a general purpose fault for a non-canonical address from if its value is not zero.</p>
</li>
<li><p>The Last Byte in Page (LBP) scheme create two pages in memory, the first of which is mapped read write, the second of which has no permissions. We then attempt to read from the first page at the address of the last valid byte, plus the <code>popcnt</code> value. If the <code>popcnt</code> value is zero, we read the last byte of the valid page, otherwise we read from the guard page, causing the <code>MPU</code> to return a fault.</p>
</li>
</ol>
<h2 id="Hardware-integrity-mechanisms"><a href="#Hardware-integrity-mechanisms" class="headerlink" title="Hardware integrity mechanisms"></a>Hardware integrity mechanisms</h2><p>Once a shadow stack design has been chosen, the shadow stack mechanism must guarantee the integrity of the shadow stack. Integrity guarantees are best provided by hardware solutions, which offer greater security and performance than software solutions, and can be as generic.</p>
<p>Existing hardware mechanisms take two different approaches to encoding access privileges to provide integrity protection. (i) MPK which encodes access privileges in each thread’s register file, providing per thread integrity, and (ii) MPX which encodes access in the individual instructions, so that access privileges are the same across all threads and depend only on the execution instruction</p>
<h3 id="Thread-centric-solutions"><a href="#Thread-centric-solutions" class="headerlink" title="Thread centric solutions"></a>Thread centric solutions</h3><p>Thread centric solutions operate by changing the permissions on the page of the protected memory region. Adding write permissions elevates the thread’s privileges, thereby creating a privileged region that is able to modify the protected memory region, i.e., shadow stack.</p>
<p>Memory Protection Keys (MPK) aims to address this by providing a single, unprivileged instruction that can change page access permissions on a per thread basis.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Read Write (disable all MPKs)</span><br><span class="line">mov $0, %eax</span><br><span class="line">xor %ecx, %ecx</span><br><span class="line">xor %edx, %edx</span><br><span class="line">wrpkru</span><br><span class="line"></span><br><span class="line"># protection is off, write to the shadow stack</span><br><span class="line">....</span><br><span class="line"># Read Only (enable write disable bit for shadow stack)</span><br><span class="line">mov $8, %eax</span><br><span class="line">xor %ecx, %ecx</span><br><span class="line">xor %edx, %edx</span><br><span class="line">wrpkru</span><br></pre></td></tr></table></figure>

<p>Note that the <code>wrpkru</code> instructions requires <code>edx</code> and <code>ecx</code> to be set to 0. Consequently, for functions which take more that two arguments, it is necessary to preserve the original values of these registers.</p>
<h3 id="Code-centric-solutions"><a href="#Code-centric-solutions" class="headerlink" title="Code centric solutions"></a>Code centric solutions</h3><p>The Intel ISA extension Memory Protection Extension (MPX) provides a hardware mechanism that can be used to implement segmentation in a flexible manner. MPX segmentation schemes divide writes into two categories, those that are privileged to write into the protected region, and all others. This approach is surprisingly performant.</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>We believe that Shadesmar, a compact, register based shadow stack that directly uses the shadow RA, and relies on information hiding to protect the shadow stack, is the best candidate for adoption by mainline compilers based on our initial experiments with SPEC CPU 2006.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/05/Securing-software-by-enforcing-data-flow-integrity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhangtong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhangtong's Notebook">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/05/Securing-software-by-enforcing-data-flow-integrity/" class="post-title-link" itemprop="url">Securing software by enforcing data-flow integrity</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-05 16:49:18" itemprop="dateCreated datePublished" datetime="2019-04-05T16:49:18+08:00">2019-04-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-22 17:03:11" itemprop="dateModified" datetime="2021-05-22T17:03:11+08:00">2021-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/paper/" itemprop="url" rel="index"><span itemprop="name">paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Most software is written in unsafe languages like C and C++, which is vulnerable to attacks. Almost all these attacks subvert the intended data-flow in the program. <em>Control-data attacks</em> exploit buffer overflows or other vulnerabilities to overwrite a return address, a functional pointer. <em>Non-control-data attacks</em> exploit similar vulnerabilities to overwrite security critical data without subverting the intended control-flow in the program.</p>
<p>This paper present a technique that prevent both attack by enforcing data-flow integrity. This technique computes a data-flow graph for a vulnerable program using static analysis, and instruments the program to ensure that flow of data at runtime is allowed by the data-flow graph.</p>
<p>We implemented data-flow integrity enforcement which using reaching definition analysis to compute a static data-flow graph. For each value read by an instruction, it computes the sets of instructions that may write the value.</p>
<p>To enforce data-flow integrity at runtime, our implementation instruments the program to compute the definition that actually reaches each use at runtime. It maintains a table with the identifier of the last instruction to write to each memory location. The program is instrumented to update this table before every write and prevent attacker from tampering this table. We also instrument reads to check if the identifier of the instruction that wrote the value being read is an element of the set computed by the static analysis.</p>
<h2 id="Data-flow-integrity-enforcement"><a href="#Data-flow-integrity-enforcement" class="headerlink" title="Data flow integrity enforcement"></a>Data flow integrity enforcement</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>The first phase uses static analysis to compute a data-flow graph for the vulnerable program. The second instruments the program to ensure that the data-flow at runtime is allowed by the graph. The last one runs the instruments program and raises an exception if data-flow integrity is violated.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> authenticated = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> packet[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!authenticated) &#123;</span><br><span class="line">    PacketRead(read);</span><br><span class="line">    <span class="keyword">if</span> (Authenticate(packet)) &#123;</span><br><span class="line">        authenticated = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (authenticated)</span><br><span class="line">    ProcessPacket(packet);</span><br></pre></td></tr></table></figure>

<p>We use reaching definitions analysis to compute the static data-flow graph. An instruction that writes to a memory position <em>defines</em> the value in the memory position, and an instruction that reads the value is said to <em>use</em> the value. The analysis computes the set of reaching definitions for each use and assigns an identifier to each definition. It returns a map from instructions to definition identifiers and a set of reaching definition identifiers for each use, which we call the static data-flow graph.</p>
<p>The analysis can be imprecise but it is important that it be conservative. It must include in the set all definitions that may reach a use at runtime but it may include additional definitions.</p>
<p>The second phase instruments the program to enforce a simple safety property that we call data flow integrity, i.e., whenever a value is read, the definition identifier of the instruction that wrote the value is in the set of reaching definitions for the read.</p>
<p>The program is instrumented to compute the definition that reaches each read at runtime and to check if this definition is in the set of reaching definition identifiers that was computed statically. We maintain the <em>runtime definitions table</em> (RDT) that records the identifier of the last instruction to write to each memory position. Every write is instrumented to update the RDT. The instrumentation before reads uses the address of the value being read to retrieve the identifier from the RDT. Then, it checks if the identifier is in the statically-computed set.</p>
<p>The attacker must be prevented from tampering with the RDT (Any attempt to write to the RDT generates an exception), tampering with the code (Read-only protection for code pages) or bypassing the instrument (Instrumentation of control-data, e.g., CFI).</p>
<h3 id="Static-analysis"><a href="#Static-analysis" class="headerlink" title="Static analysis"></a>Static analysis</h3><p>We compute reaching definitions using a combination of two analyses: a flow-sensitive intra-procedural analysis and a flow-insensitive and context-insensitive inter-procedural analysis.</p>
<p>The intra-procedural analysis takes flow control into account. We use this analysis to compute reaching definitions for uses of local variables that have no definitions external to the function in which they are declared. The inter-procedural analysis is used to compute reaching definitions for all other uses.</p>
<p>The inter-procedural analysis is less precise to allow it to scale to large programs. It ignore control-flow and it does not take the calling context into account when analyzing functions. We implemented points-to analysis to compute the set of objects that each pointer can point to, and we use these point-to sets to compute reaching definitions.</p>
<p>The points-to analysis makes a global pass over all source files to collect <em>subset constraints</em>. Each assignment x = y results in a subset constraints x ⊇ y, which means that the set of possible values of x contains the set of possible values of y. The analysis compiles each source file to IR, and it writes all subset constraints in the IR to a file. After this global pass, it computes the points-to sets by iterating over all the constraints until it reaches a fix point.</p>
<p>During the global pass, we also collect the target locations and identifiers of instruction that write to locations that may be read in other functions.</p>
<p>We compute inter-procedural reaching definitions using the points-to sets and information about write instructions collected during global pass.<br>For uses of variables, the set of reaching definitions is the union of the set containing the identifiers of all writes to the variables with the sets containing the identifiers of all writes to dereferences of pointers that may point to the variable. For pointer dereferences, the set of reaching definitions is the union of set containing the identifier of all writes to the dereferences pointer with the sets of reaching definitions of all the variable the pointer can point to.</p>
<p><strong>Both the intra-procedural and the inter-procedural analyses assume that correct programs do not use pointer arithmetic to navigate between independent objects in memory.</strong> However, it is precisely this assumption that is violated by most attacks.</p>
<p>Since we control code generation, we can ensure that these temporaries are placed in registers beyond the reach of an attack. The attacker cannot voilate data-flow integrity by overwriting these registers because our instrumentation prevents it from subverting thr control flow. We only compute reaching definitions and instrument accesses of temporaries that are spilled to memory.</p>
<h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h3><p>We add instrumentation by inserting new instruction into the IR of the program.</p>
<ul>
<li>SETDEF   opnd id</li>
<li>CHECKDEF opnd setName</li>
</ul>
<p>The first instruction sets the RDT entry for opnd to id. The second retrieves the runtime definition identifier for opnd from the RDT and checks if the identifier is in the reaching definitions set with name setName. The compiler maintains a map from the setName to set values that is used when lowering CHECKDEF instructions to the assembly of the target machine.</p>
<p>We do not instrument temporaries that we can ensure are allocated to registers, and we also do not instrument the use of local variables of which address are computed by adding a constant to the frame pointer.</p>
<p>To enable efficient accesses, the RDT is implemented as an array with a definition identifier for each 32-bit memory word in the instrumented program. Each definition identifier is two bytes long, which seems sufficient even for large programs (2 ^ 16 identifiers).</p>
<p>Since programs can access memory at byte granularity, it would seem necessary to record a 2-byte definition identifier for every byte of memory. This would result in a space overhead of approximately 200%, which is not practical. We are able to record a single identifier for each 32-bit word because we can generate code in which no two variables with distinct reaching definition sets share the same aligned 32-bit memory word. We only changed the compiler to use a minimum alignment of 32 bits when laying out local variables in a stack frame and globals in the data segment.</p>
<p>In current implementation, we allocate the lowest 1 GB of virtual address space to the program being instrumented and 512 MB to the RDT with a guard page between them, that is, the guard page is at address 4000 0000h and the base address of RDT is at 4000 1000h. This layout also enables efficient bounds checking of the target addresses: we raise an exception if the bitwise and of the target address with c000 0000h is non-zero.</p>
<p>The high-level instrumentation is lowered to x86 assembly as illustrated by the following examples:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># SETDEF authenticated 1</span><br><span class="line"></span><br><span class="line">    lea ecx, [_authenticated]</span><br><span class="line">    test ecx, C0000000h</span><br><span class="line">    je L</span><br><span class="line">    int 3</span><br><span class="line">L:  shr ecx, 2</span><br><span class="line">    mov word ptr [ecx*2 + 40001000h], 1</span><br><span class="line"></span><br><span class="line"># CHECKDEF authenticated 100</span><br><span class="line"></span><br><span class="line">    lea ecx, [_authenticated]</span><br><span class="line">    shr ecx, 2</span><br><span class="line">    mov cx, word ptr [ecx*2 + 40001000h]</span><br><span class="line">    cmp cx, 1</span><br><span class="line">    je L</span><br><span class="line">    cmp cx, 8</span><br><span class="line">    je L</span><br><span class="line">    int 3</span><br><span class="line">L:</span><br></pre></td></tr></table></figure>

<h2 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h2><p>A naive implementation of a data-flow integrity enforcement can perform poorly: each definition introduces a write to the RDT and each use check introduces a read from the RDT followed by comparisons against each identifier in the set of reaching definitions for the use.</p>
<h3 id="Renaming-equivalent-definitions"><a href="#Renaming-equivalent-definitions" class="headerlink" title="Renaming equivalent definitions"></a>Renaming equivalent definitions</h3><p>The first Optimization partitions definitions into equivalence classes in a way that allows us to safely assign the same identifier to all definitions in the same class. Two definitions are equivalent if they have a exactly the same set of use.</p>
<h3 id="Removing-bounds-check-on-writes"><a href="#Removing-bounds-check-on-writes" class="headerlink" title="Removing bounds check on writes"></a>Removing bounds check on writes</h3><p>We can optimize SETDEFs by removing these checks from all safe writes. In the current implementation, a write is safe if the target address is obtained by adding a small constant offset (possibly) zero to the stack pointer, frame pointer, or to the address of a global or static variable.</p>
<h3 id="Removing-SETDEFs-and-CHECKDEFs"><a href="#Removing-SETDEFs-and-CHECKDEFs" class="headerlink" title="Removing SETDEFs and CHECKDEFs"></a>Removing SETDEFs and CHECKDEFs</h3><p>To identify redundant instrumentation, we use symbolic execution of the native code augmented with SETDEF and CHECKDEF operations. Two addresses are equal if they are syntactically equal. They are different if they are computed by adding different offsets to the same symbolic register state. Otherwise, they may refer to aliased memory locations. A write to memory invalidates the symbolic state of a register if the state refers to the content of a memory position that may be aliased with the write’s target. Additionally, it removes mappings for any memory that may be aliased with the write’s target from the symbolic RDT state. We apply the rules to eliminate redundant instrumentation after each SETDEF and CHECKDEF by examining the symbolic RDT state.</p>
<h3 id="Optimizing-membership-checks"><a href="#Optimizing-membership-checks" class="headerlink" title="Optimizing membership checks"></a>Optimizing membership checks</h3><p>Another optimization renames definitions to reduce the cost of membership checks in the CHECKDEFs. Membership checks can be implemented more efficiently when sets contain ranges of consecutive identifier: a check against {0 .. n} can be implemented by a single unsigned integer camparison against n.</p>
<h3 id="Removing-SETDEFs-for-safe-difinitions"><a href="#Removing-SETDEFs-for-safe-difinitions" class="headerlink" title="Removing SETDEFs for safe difinitions"></a>Removing SETDEFs for safe difinitions</h3><p>The last optimization identifies local variables that have no definitions outside the function and that are written only by safe writes. It replaces all SETDEFs for such a variable by a single SETDEF with identifier 0 that is placed on function entry.</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Overhead"><a href="#Overhead" class="headerlink" title="Overhead"></a>Overhead</h3><p>We used serveral programs from the SPEC CPU 2000 benchmark suite to measure overhead added by our instrumentation. These benchmarks are CPU-intensive and they spend most time executing instrumented code at user level.</p>
<p>The first set of experiments measured two variants of the overhead of data-flow integrity enforcement: <em>intraproc</em> DFI only instruments uses of control-data and use of local variables without definitions outside their function, and <em>interproc</em> DFI is the variant described earlier in the paper.</p>
<p>The average overhead of execution time is 43% for <em>intraproc</em> DFI and 104% for <em>interproc</em> DFI.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhangtong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
